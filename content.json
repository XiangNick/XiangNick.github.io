[{"title":"第二章 Java内存区域与内存溢出异常","date":"2017-03-02T06:10:10.000Z","path":"2017/03/02/第二章-Java内存区域与内存溢出异常/","text":"2.2 运行时数据区域 图1.1 Java虚拟机运行时数据区 2.2.1 程序计数器 (线程私有) 程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都依赖这个计数器。java多线程是通过处理器轮流切换并分配处理器执行时间的方式来实现，在一个处理器，或者多核处理器的一个内核中，都只会执行一条线程中的指令，为了在java多线程切换后能回到正确的执行位置，所以程序计数器是每个线程独立独占的。 线程执行：Java方法： 计数器记录的是正在执行的虚拟机字节码指令的地址。Native方法： 计数器为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OOM情况的区域。 2.2.2 Java虚拟机栈 (线程私有) 生命周期与线程相同,虚拟器栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储 局部变量表、操作数栈、动态连接、方法入口等。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：存放编译期可见的各种数据类型(boolean,byte,char,short,int,float,long,double)、对象引用(reference类型)、returnAddress类型(指向一条字节码指令的地址) Jvm栈有两种异常情况：StackOverflowError：线程请求的栈深度大于虚拟机允许的深度OutOfMemoryError：虚拟机栈可以动态扩展，当扩展时无法申请到足够内存抛出 2.2.3 本地方法栈 (线程私有) 与虚拟机栈作用非常相似，不过执行的是本地方法，语言、数据结构都没强制规定，为虚拟机使用到的Native方法服务。也会抛出StackOverflowError和OutOfMemoryError 2.2.4 Java堆 (线程共有) 在虚拟机启动时创建，是Java虚拟机管理的最大一块内存，也是垃圾收集器管理的主要区域(所以很多时候也称作GC堆)。此内存区域唯一目的就是：存放对象的实例。 从内存回收角度，Java堆可以细分为：新生代和老年代，再细点就是 Eden空间、Form Survivor空间、To Survivor空间从内存分配角度，线程共享的Java堆可以划分出： 多个线程私有的分配缓冲区(TLAB，Thread Local Allocation Buffer) 不论怎么划分，都与存放内容无关，存放的都是对象实例，划分都为了更好的回收内存或更快地分配内存。 —未完待续","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"http://yoursite.com/tags/《深入理解Java虚拟机》/"}]},{"title":"JVM常用参数种类","date":"2017-03-02T05:22:09.000Z","path":"2017/03/02/JVM常用参数种类/","text":"一、配置堆区(-Xms、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn)①-Xms：表示Java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。 ②-Xmx：表示Java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的1/4大小。但是开发时，通常会将-Xms与-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配隔离计算堆区大小而浪费资源。一般对堆区的内存分配只需配置上述两个参数(-Xms,-Xmx)即可，但如果想细化，可配置以下三个参数(-XX:newSize、-XX:MaxnewSize、-Xmn) 对堆区进一步细分。 1)-XX:newSize：新生代内存的大小，应小于-Xms的值2)-XX:MaxnewSize：由字面意思可知，新生代可被分配的最大内存，应小于-Xmx的值3)-Xmn：对上面两个参数同时配置，即 -Xmn = -XX:newSize = -XX:MaxnewSize 在JDK1.4以后才可用-Xmn这个很厉害的参数 二、配置非堆区①-XX:PermSize：表示非堆区初始内存分配大小.(Permanent Size)持久化内存 ②-XX:MaxPermSize：表示非堆区分配的最大内存上限 注意！在配置之前要慎重考虑该非堆区内存大小，因为此处是不会被Java垃圾回收机制进行处理同时，最大堆内存+最大非堆内存 &lt; 操作系统可用内存 eg示例: 1VM参数：-verbose : gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX : SurvivorRatio = 8 表示为：Java堆大小为20M，不可扩展，10M给新生代，10M给老年代，新生代中Eden区： Survivor区 = 8：1新生代可用总空间为: Eden区 + 1个Survivor区 即 10M * 9/10 = 9M","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"正则表达式小结 ","date":"2017-03-01T15:04:47.000Z","path":"2017/03/01/正则表达式小结/","text":"一、创建方式js中，创建正则表达式的两种方式： 121.通过构造函数定义var 变量名= new RegExp(/表达式/); 122.通过直接量定义var 变量名= /表达式/; 二、五大内置对象1.预定义类① .除了换行和回车符(\\r\\n)其他的都可以 12console.log(/./.test(\"\\n\\r\"));//false console.log(/./.test(\"sa35490df574!@@$\"));//true ②\\d数字才能匹配 12console.log(/\\d/.test(\"132465465\"));//trueconsole.log(/\\d/.test(\"abs\"));//false ③\\D非数字才能匹配 12console.log(/\\D/.test(\"132465465\"));//false console.log(/\\D/.test(\"abs\"));//true ④\\s空格才能匹配 12console.log(/\\s/.test(\" \"));//true console.log(/\\s/.test(\"sad\"));//false ⑤\\S非空格才能匹配 12console.log(/\\S/.test(\" \"));//falseconsole.log(/\\S/.test(\"sad\"));//true ⑥\\w对单词的匹配12\\w：单词才能匹配，匹配字母或数字或下划线 [a-zA-Z_0-9] 单词字符\\W：非单词才能匹配[^a-zA-Z_0-9] 非单词字符 ⑦\\d代表单词的开头和结尾 1/\\dstudy\\d/ 2.简单类 12345678①/string/.test(\"string\") //中间是任意字符串，只要完整包含他即可(有他就行，完整的他)console.log(/git520/.test(\"gi\"));//fasleconsole.log(/git520/.test(\"asdgit520#$\"));//trueconsole.log(/git520/.test(\"052tig\"));//false 反向不行②/[string]/.test(\"string\") //[]整体对应一个字符，如[abc]，只要有[string]内的任意一个字符，都可以 console.log(/[520git]/.test(\"ilove\"));//true 3.负向类 123456 //[^string] 对括号内的字符取反，不够和正好返回false，多了和没有返回true(eg:[^abc]中，只有test a,ab,abc都返回false,其他的都是true)console.log(/[^abc]/.test(\"a\"));//falseconsole.log(/[^abc]/.test(\"ab\"));//falseconsole.log(/[^abc]/.test(\"abc\"));//falseconsole.log(/[^abc]/.test(\"abs\"));//true//就是/[^abc]/.test() 只要test 的是a,ab,abc就错,其他的都对 4.范围类 123456//只要存在字符在这个范围内的都行console.log(/[a-c]/.test(\"b\"));//trueconsole.log(/[a-c]/.test(\"ss\"));//falseconsole.log(/[a-c]/.test(\"sasd\"));//true 5.组合类 123456789//组合起来，存在这个范围内的字符都可以,一个[]就代表一个字符console.log(/[a-c1-3]/.test(2));//trueconsole.log(/[a-c1-3]/.test(\"a\"));//trueconsole.log(/[a-c1-3]/.test(\"abs23fz\"));//trueconsole.log(/[a-c1-3]/.test(\"z5\"));//true 三、正则边界 1.正则边界 12345//1.以^开始，以$结尾，代表精确匹配//注：^只有在[]里表示取反。在//表示正则的开头console.log(/^rick$/.test(\"rick\"));//trueconsole.log(/^rick$/.test(\"rickl\"));//fasleconsole.log(/^rick$/.test(\"ric\"));//false 四、量词 1.量词 ❤（多个字母，重复最后一个）❤ 12345678910111213141516171819202122232425// * 贪婪 大于等于0// + 懒惰 大于等于1// ? 占有 要么0要么1console.log(/^a*$/.test(\"\"));//true 0次可以console.log(/^a*$/.test(\"a\"));//trueconsole.log(/^a*$/.test(\"aaaa\"));//trueconsole.log(/^a*$/.test(\"aaab\"));//false 因为^$控制了边界内只能有大于等于0个aconsole.log(/^a*$/.test(\"b\"));//false b更错了console.log(/^zxcv*$/.test(\"zxcvv\"));//true 多个字母，重复最后一个console.log(/^zxcv*$/.test(\"zxc\"));//true 大于等于0，0个也可以console.log(/^zxcv*$/.test(\"zxzv\"));//false 边界定义了，边界内必须要完全匹配 // &#123;&#125;重复多少次的意思，&#123;n&#125; n次 &#123;n,&#125; n次即以上 &#123;n,m&#125; n&lt;=x&lt;=m// * &#123;0,&#125;// + &#123;1.&#125;// ? &#123;0.1&#125;// x|y x或者y //()括号：提高权限，优先计算 | :前后只要有一个符合即可console.log(/(abc)|(xyz)/.test(\"abcq\"));//trueconsole.log(/(abc)|(xyz)/.test(\"sxyz\"));//trueconsole.log(/(abc)|(xyz)/.test(\"abxy\"));//false 都没有完整符合abc或xyz中的一个console.log(/(abc)|(xyz)/.test(\"ab\"));//false 同上 五、练习 1.练习 12//eg: 0562-2812914 (0开头，4位)-(2开头，7位) var RegExp = /^0\\d&#123;3&#125;-2\\d&#123;6&#125;$/; —未完待续","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"springmvc使用hibernate-validator校验框架实现后端校验","date":"2017-02-28T05:20:18.000Z","path":"2017/02/28/springmvc使用hibernate-validator校验框架实现后端校验/","text":"一 springmvc校验springmvc使用JSR-303校验规范，JSR-303是javaEE6的规范。 springmvc具体使用hibernate-validator校验框架（和hibernate的ORM没有关系），hibernate-validator基于javabean的属性校验。 二 实现步骤① 添加jar包支持 本例使用hibernate-validator 4.3.0.Final版本 maven的pom文件引入以下内容即可 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;4.3.0.Final&lt;/version&gt;&lt;/dependency&gt; jboss-logging和validation-api为其依赖。 ② 在springmvc的处理器适配器中配置validator：1&lt;mvc:annotation-driven validator=\"validator\"/&gt; 定义validator的bean 1234567891011121314151617181920&lt;!-- 定义校验器 --&gt; &lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;!-- 校验器 --&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" /&gt; &lt;!-- 指定校验使用的资源文件，如果不指定则默认使用classpath下的ValidationMessages.properties--&gt; &lt;property name=\"validationMessageSource\" ref=\"messageSource\" /&gt; &lt;/bean&gt; &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomerValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=\"fileEncodings\" value=\"utf-8\"/&gt; &lt;!-- 对资源文件内容缓存时间，秒 --&gt; &lt;property name=\"cacheSeconds\" value=\"120\"/&gt; &lt;/bean&gt; ③ 在需要校验的javaben实体类中添加相关校验注解，此处以Items这个po类为例 123456789public class Items &#123; @Size(min=1,max=30,message=\"&#123;item.name.length&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) @NotNull(message=\"&#123;item.name.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private String name; private String pic; @NotNull(message=\"&#123;item.createdate.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private Date createtime; 相关的校验规则由注解名称即可理解，这里解释下注解内的属性含义。message为出现错误时的提示信息，groups为将我们的校验器分组，因为po类是共用的，可能同一个字段在不同的场景下有不同的校验需求，所以将其分组，在controller中进行校验时，可指定分组，来进行校验。分组groups中的XXX.class为定义的一个“空的interface”，没有含义，仅仅只是为了分组。 在po类中利用注解进行校验分类和定义后，可以在后台进行校验，一般选择在service层，因为判断数据合法性属于业务需求，可是在有些情况下，对于用户的体验性来说，如果在controller就进行数据合法性校验，如果不合法可以直接返回，不调用service，响应稍微快些，用户体验好。所以此例中在controller层进行校验。 ④ 在后台通过注解校验 12345678910111213141516// 修改商品提交 @RequestMapping(\"/saveItems\") public String saveItems(Model model, Integer id, @Validated(value = &#123; ItemsValidationForEdit.class&#125;) Items item, BindingResult bindingResult) throws Exception &#123; if (bindingResult.hasErrors()) &#123; List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); model.addAttribute(\"allErrors\", allErrors); return \"editItem\"; &#125; // 更新 itemsService.updateItems(id, item); // 返回成功页面 // 重定向到商品查询 return \"forward:queryItems.action\"; &#125; controller方法参数中的@Validated(value = { ItemsValidationForEdit.class}) Items item, BindingResult bindingResult） 含义为： 对Items这个形参进行校验，选择他其中定义的ItemsValidationForEdit这个分组的校验规则。 注意：如果你需要进行校验，在方法参数中，需要在校验对象的前后加上@Validated和BindingResult bindingResult，他们是成对出现的。 顺便贴下hibernate-validator的校验注解 123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"SpringMVC中post、get乱码解决","date":"2017-02-28T05:14:14.000Z","path":"2017/02/28/SpringMVC中post、get乱码解决/","text":"一 乱码原因由于中间件为Tomcat，用户请求和返回的响应都需要经过tomcat，tomcat默认编码为ISO-8859-1和我们程序的编码(一般为UTF-8)不同，导致post、get请求乱码。 二 解决方案 Post乱码解决方案：在web.xml中添加编码过滤器来解决，可以自己编写过滤器，最常用的方法是使用spring提供的编码过滤器：在Web.xml中增加如下配置（要注意的是它的位置一定要是第一个执行的过滤器） 12345678910111213&lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 该过滤器要做的其实就是强制为所有请求和响应设置编码格式：request.setCharacterEncoding(“utf-8”);response.setCharacterEncoding(“utf-8”); GET乱码解决方案 针对Get方式的乱码问题，由于参数是通过URL传递的，所以上面通过request设置的编码格式是不起作用的12345678910方法①修改tomcat目录 的conf/server.xml文件，添加URIEncoding=\"utf-8\"&lt;Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;只需增加 URIEncoding=\"UTF-8\" 这一句，然后重启tomcat即可。方法②对参数进行重新编码：String userName = new String(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\")ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 通过以上对POST和GET的处理，妈妈再也不用担心我们遇到乱码了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"以mybatis为例浅聊SQL注入","date":"2017-02-28T05:03:08.000Z","path":"2017/02/28/以mybatis为例浅聊SQL注入/","text":"以用户登录为例，传统代码为一个form表单，输入username和password去数据库发送sql检索，用的是字符串拼接${}。 select * from t_user where password = '${password}'and username = '${username}' 如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 此时无论用户名为zhangsan的该用户密码为何值，均能查询出一条记录。 而用了预编译的#{}占位符后代码为 select * from t_user where password = #{password} and username = #{username} 即mybatis发送给数据库的sql为 select * from t_user where password = ? and username = ? 在数据库端便会对该sql进行编译，如果下次有该查询时，mabatis会发送 select * from t_user where password = #{password} and username = #{username} 作为“KEY”，页面传入的参数作为“VALUE”去数据库查询，预编译的方式使得发送至数据库的值为sql “KEY” 和 参数 “VALUE”，数据库根据KEY找到编译好的sql，将参数注入进行查询如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 看到这也许会有疑问，这和传统的字符串拼接，得到的sql还是一样的啊？其实并不是，sql只是数据库端给我们看的一段字符串，真正的查询方式，传统字符串拼接查询，传入数据库的是一个参数，为在程序端拼接好的sql，直接去数据库执行。而预编译方式，传入数据库的是两个参数，一个是 select * from t_user where password = ? and username = ? 语句，一个是值。如果数据库里没该条SQL就会编译好缓存，如果缓存有的话，直接类似“函数接收参数”的方式去执行sql，那么，数据库里是不会有任何一条记录的密码为1111’ or ‘1 = 1，就不会返回记录。从某种意义上来说防止了SQL注入。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"MySQL和Oracle分页的区别","date":"2017-02-28T05:01:20.000Z","path":"2017/02/28/MySQL和Oracle分页的区别/","text":"MySQL和Oracle分页的区别 MySQL 分页 (利用LIMIT关键字） 计算参数为 开始序号(startNum)，要查的总条数 (totalNum) Oracle 分页 (利用自带的rownum) 计算参数为 开始序号(startNum) ， 结束序号 (endNum) Oracle分页利用其自带的rownum，但是rownum在表中不能使用&gt;号(比如select rownum,e.* from emp where rownum &gt; n,n为除了0以外的任何值,查出的都是空)，但是可以使用&lt;,为了避免，所以采用子查询将其rownum转换为子查询表中的一列数据列,而不是数据表自带的rownum属性使其可以使用 这种方式的好处在于，除了中间的业务查询，其余的都是固定的模版，我们只需要关心中间的业务查询即可。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"OCUpload、pinyin4j、poi简单入门","date":"2017-02-28T04:50:16.000Z","path":"2017/02/28/OCUpload、pinyin4j、poi简单入门/","text":"通过几个小demo完成以上三项的简单入门，通过此篇博客，您可以对它们有初步的认识，编写日常简单的应用。具体深入可以查询相关api。 OCUpload OCUpload为JQuery的插件(One Click Upload)，意思为一键上传，封装了对于文件上传的一些方法，只需几行代码，文件上传优雅而简洁。 对于传统的文件上传，只是通过input标签，通过设置enctype为multipart/form-data，选中文件后还需点击按钮，提交表单，才能在后台进行相关字段解析，通过流来进行文件上传，上传成功后，页面多半要刷新，无法给用户良好的体验。 OCUpload实现了页面“不刷新”，选择文件后直接上传，不需要选中文件后再点击按钮上传表单。简单实现为： 在页面的head里引入JQuery的类库，由于这里使用了easyUI使按钮和提示相对美观些，所以也导入了easyUI的核心类库，当然别忘了导入我们的OCUpload的库，本篇博客使用的版本为jquery.ocupload-1.1.2.js.首先在body中使用一个元素来“占位子”，任何标签元素都可以，不过上传文件一般点击按钮，所以我们使用easyUI的linkbutton，给按钮设置id为import.123&lt;body&gt; &lt;a id=\"import\" class=\"easyui-linkbutton\" data-options=\"iconCls:'icon-redo'\"&gt;上传文档&lt;/a&gt;&lt;/body&gt; 在head中给id为import的按钮添加upload事件，这是OCUpload的上传方法，参数为json对象，由于是简单入门，在这里即使用三个主要的属性：action(处理上传文件的后台action路径)，name(给文件设置name，便于后台通过name获取)，onComplete(参数为function，执行上传完毕的回调函数)。12345678910111213141516&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#import\").upload(&#123; action:'$&#123;pageContext.request.contextPath&#125;/regionAction_importXls', name:'upload', onComplete: function (data, self, element) &#123; if(data=='1')&#123; $.messager.alert(\"提示信息\",\"数据导入成功!\",\"info\"); &#125;else&#123; $.messager.alert(\"提示信息\",\"数据导入失败!\",\"info\"); &#125; location.reload(); &#125; &#125;);&#125;);&lt;/script&gt; 到此便完成一键上传的前台代码，只需要后台对上传文件进行解析处理即可完成文件上传。 让我们来看看这些代码做了些什么。访问页面，打开F12调试。可以看到，OCUpload将我们的linkbutton底部添加了一个带有文件input的form和一个display:none 不可见的iframe。 选择文件后form中的input触发onChange事件，直接提交表单，实现了选择文件后直接上传 文件上传后，本来页面是要刷新的，但是OCUpload将target指向底部隐藏的iframe，使得隐藏的iframe刷新，从而达到我们的页面“不刷新”的效果 poixls文件解析 在后台使用poi对上传的xls文件进行解析，将文件中的一行(row)解析成javabean，通过hibernate存入数据库。 12345678910111213141516171819202122232425262728293031public class RegionAction extends BaseAction&lt;Region&gt; &#123; private File upload; public String importXls() throws FileNotFoundException, IOException &#123; HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(upload));//此为poi的核心对象，通过构造方法中的InputStream生成HSSWorkbook对象。 HSSFSheet sheetAt = workbook.getSheetAt(0);//这里得到第一张表格(sheet) List&lt;Region&gt; regions = new ArrayList&lt;Region&gt;(); for (Row row : sheetAt) &#123; //通过遍历sheetAt获取每一行(row),再通过每一行获取每一个值 String value1 = row.getCell(0).getStringCellValue();//id String value2 = row.getCell(1).getStringCellValue();//province String value3 = row.getCell(2).getStringCellValue();//city String value4 = row.getCell(3).getStringCellValue();//district String value5 = row.getCell(4).getStringCellValue();//postcode Region region = new Region(value1, value2, value3, value4, value5); region.setShortcode(StringUtils.join(PinYin4jUtils.getHeadByString(value2+value3), \"\"));//此处利用PinYin4jUtils将表格中的字段转成拼音封装到javabean，暂且不提 region.setCitycode(PinYin4jUtils.hanziToPinyin(value3)); regions.add(region); &#125; String flag = \"1\"; try&#123; regionService.saveBatch(regions);//批处理保存到数据库中，如果抛异常返回标志字符串回前台，做出相应友好提示 &#125;catch(Exception e)&#123; flag = \"0\"; &#125; ServletActionContext.getResponse().setContentType(\"text/html;charset=UTF-8\"); ServletActionContext.getResponse().getWriter().print(flag); return NONE;//上传文件，不需要配视图 &#125; ｝ 那么在poi中，sheet、row、cell分别是什么呢？ sheet: xls中的工作表 row: xls中的行 cell: xls中的每一个数据 xls文件生成 在后台查询出数据list，封装进HSSFWorkbook对象生成xls文件,提供一个输出流，告知浏览器文件名和文件类型，在前台提供按钮或链接，指向此action，实现xls文件导出。 12345678910111213141516171819202122232425262728293031public String exportXls() throws IOException&#123; List&lt;Subarea&gt; list = subareaService.findAll(); HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(\"分区数据\"); HSSFRow headRow = sheet.createRow(0);//标题行 headRow.createCell(0).setCellValue(\"分区编号\"); headRow.createCell(1).setCellValue(\"省\"); headRow.createCell(2).setCellValue(\"市\"); headRow.createCell(3).setCellValue(\"区\"); headRow.createCell(4).setCellValue(\"信息\"); headRow.createCell(5).setCellValue(\"城市编码\"); if(list!=null &amp;&amp; list.size()&gt;0)&#123; for (Subarea subarea : list) &#123; HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum()+ 1); dataRow.createCell(0).setCellValue(subarea.getId()); dataRow.createCell(1).setCellValue(subarea.getRegion().getProvince()); dataRow.createCell(2).setCellValue(subarea.getRegion().getCity()); dataRow.createCell(3).setCellValue(subarea.getRegion().getDistrict()); dataRow.createCell(4).setCellValue(subarea.getRegion().getInfo()); dataRow.createCell(5).setCellValue(subarea.getRegion().getCitycode()); &#125; &#125; String filename = URLEncoder.encode(\"分区数据.xls\", \"UTF-8\"); ServletActionContext.getResponse().setContentType(ServletActionContext.getServletContext().getMimeType(filename));//完成文件下载不要忘了\"一个流，两个头\" ServletActionContext.getResponse().setHeader(\"content-disposition\", \"attachment;filename=\"+filename);//完成文件下载不要忘了\"一个流，两个头\" ServletOutputStream out = ServletActionContext.getResponse().getOutputStream(); workbook.write(out);//通过HSSFWorkbook的write方法，关联一个输出流 return NONE; &#125; pinyin4j主要利用PinYin4jUtils的相关方法进行汉字转拼音。","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":" EasyUI的datagrid组件实现分页","date":"2017-02-28T04:40:30.000Z","path":"2017/02/28/EasyUI的datagrid组件实现分页/","text":"本篇博客用于EasyUI的datagrid组件实现分页展示，后台为Struts2+Spring+Hibernate，利用DetachedCriteria对象进行简单的分页查询。 要点： datagrid组件的参数和响应格式 DetachedCriteria对象的条件查询 首先利用EasyUI渲染出datagrid数据表格 先在body中声明一个table 123&lt;div&gt; &lt;table id=\"grid\"&gt;&lt;/table&gt;&lt;/div&gt; 再去head中通过JQuery代码将table渲染为datagrid对象 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; $(function()&#123; $('#grid').datagrid( &#123; border : false, rownumbers : true, pageList: [10,20,30],//选择一页显示多少数据 pagination : true,//在DataGrid控件底部显示分页工具栏。 columns :[ [ &#123; field : 'name',//简单的测试字段 title : '姓名', width : 120, align : 'center' &#125;, &#123; field : 'telephone', title : '手机号', width : 120, align : 'center' &#125; ] ], url :\"$&#123;pageContext.request.contextPath&#125;/staffAction_pageQuery\", //提交的url地址 idField : 'id' &#125;); &#125;);&lt;/script&gt; 此时你的页面应该是(因为没有在后台提供数据，所以现在页面为空表格) 接下来我们来看下这个datagrid组件发送了什么请求数据 打开浏览器的F12调试，我用的是火狐浏览器，不同的浏览器调试工具页面不同。找到网络栏，我们重新刷新下网页，可以看到 该条post请求是向后台获取数据 点开可以查看到他的请求参数为page、rows ###tips注意：在datagrid的请求参数中，page为当前页码，rows为所要展示的数据条数，而在datagrid的响应参数中，必须有total和rows，返回来的响应参数中，total为通过该条件查询到的总记录数，而这里的rows为所有的记录内容，为一个List集合。 有了请求参数，我们就可以去后台编写了。接下来为后台代码。 后台采用的是Struts2+Spring+Hibernate，我们利用struts2的驱动获取页面请求的page和rows参数。 在StaffAction中，我们提供了page、rows字段以及他们的get、set方法。为了方便起见，我们将分页有关的数据封装成一个名称为PageBean的Class对象。 PageBean StaffAction的pageQuery方法 StaffServiceImpl StaffDao 相关介绍在代码截图中有注释。最后，通过dao查询出来的数据，经过service传到action，在action中通过Jsonlib将数据转成json格式，返回前台。 接下来我们就可以在前台显示出数据库里的数据了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]}]