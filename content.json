[{"title":"色彩设计推荐","date":"2017-06-17T08:39:25.000Z","path":"2017/06/17/色彩设计推荐/","text":"色彩设计推荐 [ 十六进制 ]","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"webpack学习","date":"2017-06-13T01:22:05.000Z","path":"2017/06/13/webpack学习/","text":"一、快速开始1.全局安装webpack 1npm install -g webpack 2.搭建项目目录结构 3.配置项目目录环境 新建package.json1npm init 本地安装webpack 1npm i -D webpack//存入开发依赖 4.编写src/index.html和src/js/app.jsindex.html1234&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt; app.js12document.getElementById('container').innerHTML = \"&lt;h1&gt;Hello WebPack!&lt;/h1&gt;\" 5.编写webpack配置文件我们先编写webpack.develop.config.js开发配置文件。123456789101112var path = require('path');//引入path模块，方便我们//处理文件路径module.exports = &#123; //要处理的js入口文件 entry : path.resolve(__dirname,'src/js/app.js'), //导出的文件 output : &#123; path : path.resolve(__dirname,'dist'), filename : 'bundle.js', &#125;&#125; 6.在根目录命令行打包12webpack --config webpack.develop.config.js//--config 指定配置文件名 7.效果查看此时可以看到在根目录生成了一个dist目录,里面有打包好的bundle.js文件将我们的index.html拷入dist目录 ( 因为index.html引入js的路径就是src=’bundle.js’ ) ，打开查看。 tips: webpack 的命令行配置项 webpack 最基本的启动webpack命令 webpack –-config 指定配置文件 webpack -w 提供watch方法，监听文件变化，实时进行打包更新 webpack -p 对打包后的文件进行压缩 webpack -d 提供SourceMaps，方便调试 webpack –colors 输出结果带彩色，比如：会用红色显示耗时较长的步骤 webpack –profile 输出性能数据，可以看到每一步的耗时 webpack –display-modules 默认情况下 node_modules 下的模块会被隐藏，加上这个参数可以显示这些被隐藏的模块 webpack –display-error-details 方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。 tips webpack配置文件结构一览12345678910111213141516171819202122232425262728293031323334353637383940414243var path = require('path')var OpenBrowserPlugin = require('open-browser-webpack-plugin')//...引入的外部模块...module.exports = &#123; entry:[ //实体 ], output: &#123; //输出 path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', &#125;, eslint: &#123; //eslint配置文件 configFile: '.eslintrc.js' &#125;, //模块 module: &#123; preLoaders: [ //预加载器 ], loaders: [ //加载器 ] &#125;, resolve: &#123; //处理，如自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 // 注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况. extensions: ['', '.js', '.json', '.scss', '.jsx'] // 模块别名定义，方便后续直接引用别名，无须多写长长的地址。后续直接 require('AppStore') 即可 alias: &#123; AppStore: 'js/stores/AppStores.js', ActionType: 'js/actions/ActionType.js', AppAction: 'js/actions/AppAction.js' &#125; &#125;, plugins: [ //插件 new OpenBrowserPlugin(&#123;url: 'http://localhost:8080/', browser: 'chrome'&#125;) ]&#125; 二、webpack进阶 -实现半自动化1.将冗长的命令存入package.json如果每次构建都要输入类似于1webpack --config webpack.develop.config.js 这么长的命令，体验很差，我们可以将该命令存入package.json 修改package.json的scripts属性 1234 \"scripts\": &#123; \"develop\": \" webpack --config webpack.develop.config.js\", \"publish\": \" webpack --config webpack.publish.config.js\"&#125; 这样我们可以直接12npm run develop //执行开发构建npm run publish //执行部署构建 2.开启webpack-dev-server服务webpack-dev-server封装了webpack和express，所有webpack里的配置选项，他都能用。他是一个基于Node.js Express框架的开发服务器，是一个静态资源Web服务器，对于简单静态页面或者仅依赖于独立服务的前端页面，都可以直接使用这个开发服务器进行开发。 (很方便有木有，直接”送”一个开发服务器) 在开发过程中，开发服务器会监听每一个文件的变化，进行实时打包，并且可以推送通知前端页面代码发生了变化，从而可以实现页面的”自动刷新”。 安装该模块，存入开发依赖 1npm i -D webpack-dev-server 修改package.json的启动命令 因为用了webpack-dev-server，所以启动命令也要修改为webpack-dev-server的命令 123456789&#123; \"scripts\": &#123; \"develop\": \"webpack-dev-server --config webpack.develop.config.js --devtool eval --progress --colors --hot --content-base src\",\"publish\": \"webpack --config webpack.publish.config.js\",\"watch\": \"webpack --config webpack.develop.config.js --watch --hot\" &#125;&#125; webpack-dev-server - 在 localhost:8080 建立一个 Web 服务器 –devtool eval - 为你的代码创建源地址。当有任何报错的时候可以让你更加精确地定位到文件和行号 –progress - 显示合并代码进度 –colors – hot，命令行中显示颜色！ –content-base 指向设置的输出目录//这点一定是我们的发布目录 即以该目录为项目根目录，启动一个服务器，所有的构建代码在服务器下都可以访问到 此时执行1npm run develop 就可以去浏览器访问localhost:8080来查看效果了 ( 因为–content-base设置了项目根目录，这个静态服务器在根目录下的index.html就可以默认作为主页访问了) 同时，我们如果修改了src/js/app.js里的代码，也就是webpack配置文件里配置的entry : path.resolve(__dirname,&#39;src/js/app.js&#39;)。实体一修改，会自动监听构建，为了让浏览器自动刷新，我们可以修改webpack.develop.config.js里的entry为1234entry:[ 'webpack-dev-server/client?http://localhost:8080', path.resolve(__dirname,'src/js/app.js') ] 注意！ 用webpack-dev-server生成bundle.js文件是在内存中的，为了构建速度快一点，并没有实际生成。同时因为他是以–content-base为根目录创建了静态服务器，所以我们src/index.html里引入js的路径直接写bundle.js即可。 如果引用的文件夹中已经有bundle.js就不会自动刷新了，需要先把bundle.js文件手动删除 webpack开发模式的插件推荐 plugins open-browser-webpack-plugin构建完毕会自动打开浏览器先1npm i -D open-browser-webpack-plugin 安装该模块，然后在webpack.develop.config.js的顶部引入该插件1var OpenBrowserPlugin = require('open-browser-webpack-plugin') 最后修改webpack.develop.config.js，在module.exports里添加一个插件123plugins: [ new OpenBrowserPlugin(&#123;url: 'http://localhost:8080/', browser: 'chrome'&#125;) ] 再进行构建时会自动打开浏览器。 三、常用加载器介绍 loaders tips:除了Loader加载器，还有预加载器preLoader,preloader是在loader加载器之前再预处理 加载器：在真正构建我们的代码之前，做一些预处理操作。 3.1 babel的loader – 编译jsx和es6成原生js代码 安装以下模块依赖 ( 开发依赖 ) 12npm i babel-loader -Dnpm i babel-core babel-preset-es2015 babel-preset-react -D 修改webpcak.develop.config.js这个配置文件 12345678910111213module: &#123; loaders: [ // babel来处理jsx语法和ES6语法 &#123; test: /\\.jsx?$/, // 用正则来匹配文件路径，这段意思是匹配 js 或者 jsx loader: 'babel-loader',// 加载模块 \"babel-loader\"，现在不再支持省略\"-loader\"这个缩写的写法了 query: &#123; //babel的一些preset，可以处理es6和react代码为原生js代码 presets: ['es2015', 'react'] //需要提前npm install,格式为:babel-preset-xx名 &#125; &#125;]&#125; babel常见的presets选项有： es2015 react stage-0 stage-1 stage-2 stage-3在webpack开发版配置文件中使用babel的loader的query的presets里可以填入以上选项。前提是先预先安装好，安装格式为：1npm i -D babel-preset-xx名 安装和配置了babel-preset-es2015和babel-preset-react 这两个加载器后，就可以利用webpack来构建es6和react语法成原生js了。 3.2 css的loader – css-loader和style-loaderwebpack允许像加载任何代码一样加载 CSS。你可以选择你所需要的方式，但是你可以为每个组件把所有你的 CSS 加载到入口主文件中来做任何事情。加载 CSS 需要 css-loader 和 style-loader，他们做两件不同的事情，css-loader会遍历 CSS 文件，然后找到 url() 表达式然后处理他们，style-loader 会把原来的 CSS 代码插入页面中的一个 style 标签中。 这样在我们的代码中直接使用1import '../css路径' 来引入css，css-loader和style-loader 会帮我们加载css，并且插入到页面的style标签里。 太方便了有木有！以后用css直接import即可，不用自己考虑引入了。 同时在react中，可以在不同组件中import不同css，方便管理。 安装以下模块依赖 ( 开发依赖 ) 1npm i css-loader style-loader -D 修改webpcak.develop.config.js这个配置文件 添加css的2个loader12345678module: &#123; loaders: [ // 两个css的loader来import css &#123; test: /\\.css$/, // Only .css files loader: 'style-loader!css-loader' // Run both loaders &#125;]&#125; tips: ！用来定义loader的串联关系，”-loader”是可以省略不写的，多个loader之间用“!”连接起来 所以1loader:'style-loader!css-loader` 的意思是使用style-loader和css-loader来处理test里面的文件。 css加载策略 既然我们使用了css-loader 和 style-loader使得我们可以import css文件。那么就涉及到了css的加载策略 全局加载 [ 不太好 ] 在项目的主入口文件中，如app.js中，引入css的入口文件，就可以为整个项目加载所有的css文件，css就完全包含在我们的应用中，以后再也不用被加载。 懒加载 [ 推荐 ] 可以把我们的模块用文件夹分类，如 src/entryA/ 文件夹下有main.js和main.css 直接在src/entryA/main.js里引入import &#39;./main.css&#39; 在src/entryB/main.js里引入import &#39;./main.css&#39; 即用不同的文件夹给组件分类，在当前的组件文件夹内引入当前的css文件，归类，等加载这个组件，才会加载我们组件中import的css。 定制组件css 可以根据这个策略为每个组件创建 CSS 文件，可以让组件名和 CSS 中的 class 使用一个命名空间，来避免一个组件中的一些 class 干扰到另外一些组件的 class 如在src/components/下有chatListComponent.jsx那么在同目录下的chatListComponent.css里，给所有的class命名都带上charList前缀。这样既用文件夹分类了组件，又解决了命名冲突问题。 3.3 less/sass的loader – sass-loader/less-loader可以处理构建less或sass 安装以下模块依赖 ( 开发依赖 ) 1npm i less less-loader -D 如果要处理less，就用less-loader,如果要处理sass，就用sass-loader，以下同理。 修改webpcak.develop.config.js这个配置文件 添加1234&#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' &#125; tips:less的test: /^.less$/,sass的test: /^.scss$/ 3.4 css中图片处理，fonts加载的loader – url-loader通过上面css-loader和style-loader的使用，我们已经可以在js中import css了，这样便于组件管理。但是会出现一个问题： 我们使用css设计样式的时候，免不了在css里要引入图片，一般通过url(‘路径’)来引入。12345img&#123; width: 497px; height: 270px; background-image: url('../images/demo.jpg'); &#125; 面对这样的css代码，在import入js文件中，就相当于在js文件里使用url(路径)，js自然是不识别的。 如图，构建报错。 所以要使用到url-loader 安装以下模块依赖 ( 开发依赖 ) 1npm i url-loader file-loader -D 修改webpcak.develop.config.js这个配置文件 添加1234 &#123; test: /\\.(png|jpg|jpeg|gif)$/, loader: 'url-loader?limit=8192'&#125; 这样，js中就可以识别import的css里的url()了同时，这个url-loader还可以接收一个limit参数： 如果在 CSS 中加载了太多图片的话，就会向服务器发很多次请求，影响性能，所以可以自动把小图片转成 BASE64 字符串然后内联到 CSS 里，和CSS一起加载，来降低必要的请求数，这个方法取决与图片大小。 url-loader 传入的 limit 参数是告诉它图片如果不大于 8KB 的话要自动在它从属的 css 文件中转成 BASE64 字符串和css一起发来。 大图片的处理 在上面，我们使用了url-loader使得js中import的css里的url()可以被识别，同时给url-loader添加了limit参数使得小于该limit大小的图片可以被转为base64字符串以减少请求次数，对小图片进行了优化。 那么不适合转base64字符串的大图片该如何加载呢？ 我们可以修改webpack.develop.config.js文件的url-loader 给他再加一些参数来处理大图片 1234 &#123; test: /\\.(png|jpg|jpeg|gif)$/, loader: 'url-loader?limit=8192&amp;name=images/[name][hash].[ext]'&#125; tips: limit的大小自己斟酌设置 url-loader的参数： limit: 小于该大小的图片转成base64，以减少请求次数 name: 大于limit的图片将会以name的路径存储 [name]指文件名 [hash]生成的hash值 [ext]文件的后缀名这三个我们可以随意搭配位置。 这样，url-loader可以自动识别并处理。根据loader中的设置，webpack会将小于指定大小的文件转化成 base64 格式的 dataUrl，其他图片会存放在name值的路径里。 tips:在html标签里的图片，建议使用require来加载 通过url-loader的使用，我们把小于limit大小的图片转成了base64字符串，大于limit大小的图片修改了文件名，添加了hash，存在了定义好的文件夹目录里。 但是这样的改变，都会修改图片的文件名，所幸，url-loader会帮我们修改构建过的css里url()的路径和修改过的文件名匹配。但是html标签里的图片，就无法匹配修改了。如&lt;img src=&quot;img/demo.jpg&quot;/&gt;的图片，建议使用require来加载，在编写js里的html时，就改为&lt;img src={require(&#39;img/demo.jpg&#39;)}/&gt;，这样url-loader也会识别它，将它或压缩或改名存入路径，然后修改我们引用的路径。 内联fonts的处理 1234&#123; test: /\\.(eot|woff|ttf|woff2|svg)$/, loader: 'url'&#125; 这样也能加载字体文件了。 3.5 特殊模块的loader –expose-loader [ 了解 ]比如我们的项目要依赖一些外部的库，如jquery，想在全局都能挂载使用window.jQuery, 需要从 npm 模块中将 jquery 挂载到全局 举例：比如我们用到 Pen 这个模块,这个模块对依赖一个 window.jQuery, 可手头的 jQuery 是 CommonJS 语法的而 Pen 对象又是生成好了绑在全局的, 可又需要通过 require(‘pen’) 获取变量 最终的写法就是做 Shim 处理直接提供支持:先安装expose-loader依赖进开发依赖1npm i -D expose-loader 修改webpack.publish.config.js里的loaders 分别增加Pen和jquery模块12345678&#123; test: require.resolve('jquery'), loader: 'expose-loader?jQuery'&#125;,&#123; test: require.resolve('pen'), loader: 'exports-loader?window.Pen'&#125; 四、部署策略1. 修改npm的package.json文件“scripts”里新增一个publish脚本1\"publish\": \" webpack --config webpack.publish.config.js -p\" 指向生产的配置文件，并且加上了webpack的cli的-p,他会自动做一些优化 2. 修改webpack.publish.config.js文件123456789101112131415161718192021222324252627282930313233343536var path = require('path')module.exports = &#123; entry : path.resolve(__dirname,\"src/js/app.js\"), output : &#123; path : path.resolve(__dirname,\"dist\"), filename : \"bundle.js\" &#125;, module:&#123; loaders : [ //es6和jsx处理的loader &#123; test : /\\.jsx?$/, loader : 'babel-loader', query : &#123; presets : ['es2015','react'] &#125; &#125;, //js里import css &#123; test: /\\.css$/, // Only .css files loader: 'style-loader!css-loader' // Run both loaders &#125;, //less &#123; test: /\\.less$/, loader: 'style-loader!css-loader!less-loader' &#125;, //url-loader &#123; test: /\\.(png|jpg|jpeg|gif)$/, loader: 'url-loader?limit=8192&amp;name=images/[name][hash].[ext]' &#125; ] &#125;&#125; 可以看到，其实生产环境的配置和开发的配置没有太大的不同，主要是把不需要的东西给去掉了 然后我们1npm run publish 看看效果。 还是挺大的，我们需要分离第三方库 3. 分离第三方库 修改我们的webpack.publish.config.js 将1entry : path.resolve(__dirname,\"src/js/app.js\") 修改为：1234entry : &#123; app:path.resolve(__dirname,\"src/js/app.js\"),//自己的入口文件 vendors:['react','react-dom']//第三方库&#125; 新增一个webpack自带的CommonsChunkPlugin插件 修改webpack.publish.config.js文件 因为该插件是webpack自带的，所以将在webpack.publish.config.js文件中先把webpack引进来 顶部引入1var webpack = require('webpack') module.exports里新增plugins123plugins : [ new webpack.optimize.CommonsChunkPlugin(&#123;name:'vendors',filename:'vendors.js'&#125;)] tips: plugins是和entry,output,module等同级的 CommonsChunkPlugin插件是分离第三方应用的插件，属性： name：自动指向entry中vendros属性 filename：属性中的文件会自动构建到output中的path里 修改index.html 在引入bundle.js之前引入vendors.js12&lt;script src=\"vendors.js\"&gt;&lt;/script&gt;&lt;script src=\"bundle.js\"&gt;&lt;/script&gt; 再删除原来的dist目录，重新构建1npm run publish 可以看到，我们自己写的代码，bundle.js现在只有7.47kb了，第三方库全分离出去，合并为vendors.js文件，有151kb 4. 分割代码，模块按需加载 在我们之前写的代码中，引入某模块或者依赖使用require或者import会导致所有我们的代码都打包在一个bundle.js文件中，很臃肿，如果可以实现点击某按钮或者通过某路由再去加载js、css之类的，这样就可以把bundle.js给抽离出来，用户首屏加载快，需要的代码再按需加载。 对于分割代码，分割多了会导致http请求多，加大服务器负担。分割少了导致js过于庞大，首屏加载慢，用户体验差。这个平衡需要掌握好。一般都是首页的资源同步加载。后面的模块采用异步加载。通过webpack实现的require.ensure可以轻松实现。 配置 修改webpack.publish.config.js1234567output : &#123; path : path.resolve(__dirname,\"dist\"), filename : \"js/bundle.js\",//把bundle.js放到dist/js/目录下 // 为了做代码的异步加载 publicPath:\"./\", // 设置require.ensure路径 chunkFilename: \"js/chunk/[name]_[chunkhash:8]_chunk.js\"// 设置require.ensure 文件 &#125; 对于平常写的普通代码。我们将之前写的import和require之类的同步引入代码改为12345require.ensure([依赖的模块],function(require)&#123; //回调函数 require('引入的其他模块');//引入他就是执行他 //这样就可以异步地加载再执行其他模块的代码了。&#125;) 如果其他模块使用export default的方式，ensure的回调里的require(‘引入其他模块’)要改为1234require.ensure([依赖的模块],function(require)&#123; require('引入的其他模块').default; //这样就能获取他export出来的接口，我们再处理 &#125;) 如果是react-router里的路由，我们也可以采用异步加载以前在Router.js文件里，我们写的通常是：1import MovieContainer from '../containers/MovieContainer.js' 1234567render() &#123; return ( //...之前的省略 &lt;Route path=\"movie\" component=&#123;MovieContainer&#125;&gt; //...之后的省略 )&#125; 这样的格式，但是这样都是同步引入模块的，都会被构建进bundle.js 我们可以修改。 删除Router.js顶部的非首页的组件的import代码 (首页同步加载，其他的异步) 然后将Router.js的render里的component用getComponent方法代替1234567891011121314render() &#123; return ( //...之前的省略 &lt;Route path=\"movie\" getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/MovieContainer.js\").default) &#125;, \"movie\") &#125; &#125;&gt; //...之后的省略 )&#125; 这样可以在React中实现路由的异步加载。 完整的React路由异步加载实例如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React, &#123;Component&#125; from 'react'import &#123; Router, Route, IndexRoute,Redirect,browserHistory,hashHistory&#125; from 'react-router'import AppContainer from '../containers/AppContainer.js'import HomeContainer from '../containers/HomeContainer.js'//以上首页需要的都采用同步加载export default class Routers extends Component &#123; render() &#123; return ( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=\"/\" component=&#123;AppContainer&#125;&gt; &lt;IndexRoute component=&#123;HomeContainer&#125; /&gt; &lt;Route path=\"home\" component=&#123;HomeContainer&#125; /&gt; &lt;Route path=\"movie\" // 权限或者日志记录可以用这两个方法 onEnter=&#123;()=&gt;null&#125; onLeave=&#123;()=&gt;null&#125; getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/MovieContainer.js\").default) &#125;, \"movie\") &#125; &#125; &gt; &lt;IndexRoute getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/MovieListContainer.js\").default) &#125;, \"movie\") &#125; &#125; /&gt; &lt;Route path=\"movieList/:movieType\" getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/MovieListContainer.js\").default) &#125;, \"movieList\") &#125; &#125; /&gt; &lt;Route path=\"movieDetail/:id\" getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/MovieDetailContainer.js\").default) &#125;, \"movieDetail\") &#125; &#125; /&gt; &lt;Route path=\"movieSearch/:keyWord\" getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/MovieSearchContainer.js\").default) &#125;, \"movieSearch\") &#125; &#125; /&gt; &lt;/Route&gt; &lt;Route path=\"call\" getComponent=&#123; (nextState, callback)=&gt; &#123; require.ensure([], (require)=&gt; &#123; callback(null, require(\"../containers/CallContainer.js\").default) &#125;, \"call\") &#125; &#125; /&gt; &lt;/Route&gt; &lt;/Router&gt; ) &#125;&#125; 举例： Project1.less随便写的样式。 123button&#123; width: 300px;&#125; Project1.js，引入了Project1.less,暴露出一个Person对象。 1234567891011121314import '../css/Project1.less'class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; sayHi()&#123; alert(`Hi!`) &#125;&#125;export default Person; IndexComponent.js需要导入Project1.js的内容 123456789101112131415161718192021222324 import React,&#123; Component &#125; from 'react' import Person from './Project1.js'class IndexComponent extends Component&#123; constructor(props,context)&#123; super(props,context); &#125; handleClick()&#123; let p = new Person(); p.sayHi(); &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;clickMe&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default IndexComponent; 最终通过ReactDOM，在app.js中render到id为container的idv里。我们构建这段代码。 可以看到，因为我们写的是同步加载其他js文件，所以webpack帮我们把他们都一起打入bundle.js文件中了， 用户需要一口气把bundle.js都请求过来。 然后，我们采用webpack的异步加载策略。使用require.ensure在IndexComponent.js中来导入Project1.js 修改IndexComponent.js代码。1234567891011121314151617181920212223242526import React,&#123; Component &#125; from 'react'class IndexComponent extends Component&#123; constructor(props,context)&#123; super(props,context); &#125; handleClick()&#123; require.ensure([],(require)=&gt;&#123; let Person = require('./Project1.js').default;//因为Project1.js里export的就是default let p = new Person(); p.sayHi(); &#125;,'project1') &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;clickMe&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default IndexComponent; 即删除原先的import Person from &#39;./Project1.js&#39;语句，改为在click方法中来require.ensure Project1.js 再次构建。 可以看出，我们划分出了chunk文件，他会按需加载。 用户第一次请求 点击了按钮后，异步加载chunk代码。 五、常用插件 之前介绍的加载器loader是在构建代码之前进行的预处理操作。那么插件就是在构建代码之后的扫尾操作。 要区分开来。 1. 压缩插件 – UglifyJsPlugin UglifyJsPlugin压缩插件也是webpack自带的，所以先在顶部引入webpack 1var webpack = require('webpack') 然后在plugins里新增他 12345678plugins :[ new webpack.optimize.UglifyJsPlugin(&#123; compress : &#123; //忽略代码中的警告 warnings : false &#125; &#125;)] 再删除原来的dist目录，重新构建 2. 抽取css插件 – extract-text-webpack-plugin 在webpack中编写js文件时，可以通过require的方式引入其他的静态资源，可通过loader对文件自动解析并打包文件。通常会将js 文件打包合并，css文件会在页面的header中嵌入style的方式载入页面。但开发过程中我们并不想将样式打在脚本中，最好可以独立生成css文 件，以外链的形式加载。这时extract-text-webpack-plugin插件可以帮我们达到想要的效果。需要使用npm的方式加载插件，然后 参见下面的配置，就可以将js中的css文件提取，并以指定的文件名来进行加载。 安装该插件入开发依赖 1npm i -D extract-text-webpack-plugin 在webpack.publish.config.js头部引入 1var ExtractTextPlugin = require(\"extract-text-webpack-plugin\") 在plugins里new一下他 12//取的名称new ExtractTextPlugin(\"app.css) 这里给的名称是从js中抽取出来的css的文件名，同样可以写成[name].[hash].css&quot;这样的格式。 修改处理css的loader的配置， 从 1234 &#123; test: /\\.css$/, loader: 'style-loader!css-loader' &#125; 改为1234&#123; test:/\\.css$/, loader:ExtractTextPlugin.extract(&#123;fallback:\"style-loader\",use:\"css-loader\"&#125;)&#125; 这样就可以从各个js文件中抽取出css再合并了。但是如果我们js文件中引用的是less文件，则我们还要把处理less的那个loader改为如下格式： 12345//less&#123; test: /\\.less$/, loader:ExtractTextPlugin.extract(&#123;fallback:\"style-loader\",use:\"css-loader!less-loader\"&#125;)&#125; 这样也可以从各个js中抽取出less文件再合并了 再删除原来的dist目录，重新构建 可以看到各个js中的css或者less都被抽取出来合并成一个css了。 把index.html粘贴到dist目录下， 别忘了在index.html中再引入下该css 1&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"app.css\"/&gt; 3. 创建index.html页面插件 – html-webpack-plugin 之前构建完毕后，还要把src下的index.html文件手动粘贴到dist目录下，再修改下，才能看到效果，这个插件可以自动帮我们创建index.html在dist目录下 安装html-webpack-plugin到开发依赖 1npm i -D html-webpack-plugin 在webpack.publish.config.js头部引入 1var HtmlWebpackPlugin = require(\"html-webpack-plugin\") 在底部plugins里new一下123456789101112131415new HtmlWebpackPlugin(&#123; template: './src/template.html', htmlWebpackPlugin: &#123; \"files\": &#123; \"css\": [\"app.css\"], \"js\": [\"vendors.js\",\"bundle.js\"] &#125; &#125;, // 效果不大，情怀至上 minify: &#123; removeComments: true,//删除注释 collapseWhitespace: true,//删除空格 removeAttributeQuotes: true//删除属性引号 &#125; &#125;) 插件里的属性： template: 选取该路径的html文件作为入口html的模版，只需要有js入口的&lt;div id=&quot;container&quot;&gt;&lt;/div&gt;即可。还可以添加meta:vp视口，meta:keyword之类的作为模版即可。1234567891011 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; htmlWebpackPlugin 该属性里有个”files”属性，里面包含的文件名会自动注入。 删除dist目录，重新npm run publish构建 可以看到新生成了一个index.html文件 4. 自动删除构建目录插件 – clean-webpack-plugin 每次重新构建都需要先删除构建目录dist，很麻烦，这个插件可以自动帮我们在每次构建之前先删除dist目录 tips:记得将他new在所有的插件之前，先删dist目录再构建 先安装该插件进开发依赖 1npm i -D clean-webpack-plugin 在webpack.publish.config.js头部引入 1var CleanPlugin = require(\"clean-webpack-plugin\") 在plugins的首位处，new一下它 1new CleanPlugin([\"dist\"]) 此时不需要手动删除dist目录了，直接npm run publish查看效果 5. 设置生产环境的插件 – DefinePlugin这是webpack自带的插件，因为webpack其实是基于node的，这个插件将node的环境设置为生产环境，会更加优化我们的代码。 在webpack.publish.config.js头部引入webpack 1var webpack = require(\"webpack\") 在plugins里new一下 12345new webpack.DefinePlugin(&#123; \"process.env\":&#123; NODE_ENV:'\"production\"' &#125;&#125;) 6. ProvidePlugin插件自动添加引用插件，全局暴露插件，直接使用 六、其他知识点 webpack和gulp集成 即：在gulp中使用webpack使用如下的gulpfile.js文件即可,最终直接执行gulp即可。123456789101112131415161718192021222324252627282930313233343536373839404142// gulp的任务是控制执行流程，webpack的任务是处理复杂引用的依赖var gulp = require('gulp');// 删除文件和目录var del = require('del');// 按顺序执行var gulpSequence = require('gulp-sequence');// 引入webpack的本地模块var webpack = require(\"webpack\");// 引入wbpack的配置文件var webpackConfig = require(\"./webpack.publish.config.js\");gulp.task('default', ['sequence'], function () &#123; console.log(\"项目构建成功\");&#125;);// 流程控制gulp.task('sequence', gulpSequence('clean', 'webpack'));// 删除文件和文件夹gulp.task('clean', function (cb) &#123; //del('dist);// 如果直接给dist的目录，项目启动的顺序还有清除结果会报错，所以要写的更详细一些 del(['dist/*.js', 'dist/*.css', 'dist/images', 'dist/*.html']).then(function () &#123; cb() &#125;);&#125;);//写一个任务，在gulp中执行webpack的构建// gulp 负责任务流程部分的操作，webpack负责复杂模块系统的引用分离工作gulp.task('webpack', function (cb) &#123; // 执行webpack的构建任务 webpack(webpackConfig, function (err, stats) &#123; if (err) &#123; console.log(\"构建任务失败\"); &#125; else &#123; cb(); &#125; &#125;);&#125;); webpack中的非入口文件（异步加载） 这个是重点要配合chunkname属性，后面的react-router的动态路由会用到点我 基本上都是在require.ensure去加载模块的时候才会出现，chunkFileName，个人理解是cmd和amd异步加载，而且没有给入口文 件时，会生成了no-name的chunk，所以你看到的例子，chunkFileName一般都会是[id].[chunkhash].js,也就是这 种chunk的命名一般都会是0.a5898fnub6.js. Resolve属性 webpack在构建包的时候会按目录的进行文件的查找，resolve属性中的extensions数组中用于配置程序可以自行补全哪些文件后缀：123456789101112131415resolve: &#123; //查找module的话从这里开始查找 root: '/pomy/github/flux-example/src', //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名//注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况. extensions: ['', '.js', '.json', '.scss',’jsx’], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : 'js/stores/AppStores.js',//后续直接 require('AppStore') 即可 ActionType : 'js/actions/ActionType.js', AppAction : 'js/actions/AppAction.js' &#125; &#125; Externals属性 外部依赖不需要打包进bundle，当我们想在项目中require一些其他的类库或者API，而又不想让这些类库的源码被构建到运行时文件中，这在实际开发中很有必要。比如：你在页面里通过script标签引用了jQuery：&lt;script src=&quot;//code.jquery.com/jquery-1.12.0.min.js&quot;&gt;&lt;/script&gt;，所以并不想在其他js里再打包进入一遍，比如你的其他js代码类似：其实就是不是通过require或者import引入的，而是直接写在html中的js地址。 开发环境中使用压缩文件 点我不使用就会把react在处理一遍 noParse属性 多文件入口点我 强制从新加载文件点我 Chunk点我 懒加载 （1）在react中如何使用 （2）在react-router中用到动态加载路由可以实现 在服务器端用webpack Node和webpack集成用到的中间件 node和webpack集成过程中遇到的坑如何解决 热加载组件（了解）","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"ES6语法学习","date":"2017-06-12T08:55:05.000Z","path":"2017/06/12/ES6语法学习/","text":"环境搭建环境可以去我的GitHub使用gulp,babel搭建即时编译es6语法的环境直接使用。 语法学习1.let 和 const在es6以前，js只有function(){}才能定义作用域现在可以使用let和const来定义拥有自己块级作用域的变量和常量。 let用来定义变量，const用来定义常量，const定义的常量无法被重新赋值。 2.解构数组es6中的新语法，意思为分解一个东西的结构。在以前的写法中，如果我们得到了一个数组，希望把数组的值赋值给其他变量，需要一个个得将数组项赋值，如下1234567function breakfast()&#123; return ['cake','hamburger','noodle'];&#125;var temp = breakfast();var food1 = temp[0], food2 = temp[1], food3 = temp[2]; 很麻烦。在es6中，我们可以直接使用解构语法来赋值。1234function breakfast()&#123; return ['cake','hamburger','noodle'];&#125;let [food1,food2,food3] = breakfast(); 这样，三个变量就直接得到返回的数组值了。 3.模版字符串传统的字符串拼接为var str = &#39;今天是&#39;+day+&#39;天气为&#39;+weather，字符串拼接变量。 es6中使用模版字符串，用`来包裹字符串，${}来包裹变量即可。 var str = `今天是${day}天气为${weather}` 4.带标签的模版字符串可以在模版字符串前放置一个标签，然后定义该标签(为一个function) 12345678910let skills = ['Java','nodeJS','React Native']let str = myTag`我会的技能有 $&#123;skills[0]&#125; 和 $&#123;skills[1]&#125; 以及 $&#123;skills[2]&#125;`function myTag(strings,...values)&#123; console.log(strings); console.log(values);&#125; 从打印结果可以看出，strings为模版字符串的所有字符数组，values为模版字符串中的变量数组。 5.判断字符串中是否包含其他字符串es6中新增了字符串的api。 startsWith(str) boolean endsWith(str) boolean includes(str) boolean 记得方法名后都有一个s 6.默认参数对于方法中的形参，可以使用=来给定默认参数，如果该方法不传值，就用默认参数，传值了就用新参数。12345function breakfast(dessert='cake',drink='milk')&#123; return `$&#123;dessert&#125;,$&#123;drink&#125;`;&#125;console.log(breakfast());//cake,milkconsole.log(breakfast('hamburger','juice'));//hamburger,juice 7.展开操作符/剩余操作符使用方法一：展开一个数组12345let fruits = ['apple','banana'];console.log(fruits);//[\"apple\", \"banana\"]console.log(...fruits);//apple banana 使用方法二：将一个数组展开，放入一个新数组，底层实现为数组的concat方法1234let fruits = ['apple','banana'];let foods = ['cake',...fruits];console.log(foods);//[\"cake\", \"apple\", \"banana\"] 使用方法三：作为方法的形参，接收不限数量的参数，存入该形参的数组里。12345function breakfast(dessert,drink,...foods)&#123; console.log(dessert,drink,foods); //cake milk [\"noodle\", \"hamburger\"]&#125;breakfast('cake','milk','noodle','hamburger'); 可以看到，foods接收了更多的参数，存入了以它命名的数组里。 8.解构参数如果方法形参中有对象，可以直接在方法体中结构该对象的参数12345function breakfast(dessert,drink,&#123;location,restaurant&#125;=&#123;&#125;)&#123; console.log(dessert,drink,location,restaurant); //cake milk 南京 圣马丁&#125;breakfast('cake','milk',&#123;location:'南京',restaurant:'圣马丁'&#125;); 9.函数名1234function breakfast()&#123;&#125;console.log(breakfast.name);//breakfast 可以直接获得函数的名字。 如果是123let breakfast = function()&#123;&#125; 这种匿名函数形式，函数名字为该变量名，breakfast。 如果是123let superbreakfast = function breakfast()&#123;&#125; 函数的名字为superbreakfast.因为他的优先级最高 10.对象表达式以前定义对象12345678let dessert = 'cake', drink = 'milk'let food = &#123; dessert:dessert, drink:drink, feeling:function()&#123;console.log('good!~');&#125;&#125; food对象里，第一个dessert指该对象的属性名，第二个dessert指上面定义过的dessert变量，可以赋值给food对象的对象属性。 在es6中引入了对象表达式，如果对象的属性名和引用的变量名一致的话，可以只写一个。同时，如果定义对象的方法时，可以直接用方法名(){}来定义，和Java的写法一样.1234567891011let dessert = 'cake', drink = 'milk'let food = &#123; dessert, drink, feeling()&#123;console.log('good!~');&#125;&#125;console.log(food);//Object &#123;dessert: \"cake\", drink: \"milk\", feeling: function&#125;food.feeling();//good!~ 11.对象属性名以前给对象赋属性名，不允许属性名带空格12345let food = &#123;&#125;;food.dessert = 'cake';food.hot drink = 'coffee';console.log(food);//Object &#123;dessert: \"cake\"&#125; 而使用了[‘’]可以属性名带空格123456let food = &#123;&#125;;food.dessert = 'cake';food['hot drink'] = 'coffee';//记得加''console.log(food);//Object &#123;dessert: \"cake\", hot drink: \"coffee\"&#125; 同时，[]内的也可以不是写死的值，也可以是一个变量，只要结果为字符串即可1234567let food = &#123;&#125;;const drink = 0&gt;1?\"hot drink\":\"cold drink\"food.dessert = 'cake';food[drink] = 'coffee';console.log(food);//Object &#123;dessert: \"cake\", cold drink: \"coffee\"&#125; 12.对象的拷贝使用Object.assign(待拷贝对象，拷贝源)12345let target = &#123;&#125;;let food = &#123;drink:'coffee',feeling()&#123;console.log('good!~')&#125;&#125;;Object.assign(target,food);console.log(target);//Object &#123;drink: \"coffee\", feeling: function&#125;console.log(target === food);//false 说明是新对象 扩展：数组的拷贝使用展开操作符...,即调用concat方法12345let food = [];let dessert = ['cake','coffee']food = [...dessert];console.log(food);//[\"cake\", \"coffee\"]console.log(food === dessert);//false 说明是新数组 13.设置对象的prototype12345678910111213141516let breakfast = &#123; getFood()&#123; return 'bread'; &#125;&#125;let dinner = &#123; getFood()&#123; return 'fried chicken'; &#125;&#125;let today = Object.create(breakfast);console.log(today.getFood());//breadconsole.log(Object.getPrototypeOf(today) === breakfast);//true,说明today对象的prototype为breakfast的 使用Object.setPrototypeOf(目标对象,源对象); 可以将源对象的prototype赋给目标对象 12345 //承接上面代码 Object.setPrototypeOf(today,dinner);console.log(today.getFood());//fried chickenconsole.log(Object.getPrototypeOf(today) === dinner);//true//true,说明today对象的prototype为dinner的 14. proto在es6中，可以使用__proto__来获取对象的prototype，也可以直接给对象赋值prototype123456789101112131415161718192021let breakfast = &#123; getFood()&#123; return 'bread'; &#125;&#125;let dinner = &#123; getFood()&#123; return 'fried chicken'; &#125;&#125;let today = &#123; __proto__:breakfast//使用__proto__直接指定prototype&#125;console.log(today.getFood());//breadconsole.log(Object.getPrototypeOf(today) === breakfast);//truetoday.__proto__ = dinner;console.log(today.getFood());//fried chickenconsole.log(Object.getPrototypeOf(today) === dinner);//true 15. super关键字在上例中，由于在today对象里使用proto属性指定了他的父类，所以在他本身没有getFood方法时，调用getFood方法，会发现本对象没有，然后会顺着原型链去父类中找到getFood方法调用。 在子类中，使用super关键字来指向父类，可以覆写父类方法。12345678910111213141516171819202122let breakfast = &#123; getFood()&#123; return 'bread'; &#125;&#125;let dinner = &#123; getFood()&#123; return 'fried chicken'; &#125;&#125;let today = &#123; __proto__:breakfast, getFood()&#123; return super.getFood() + '和milk'; //覆写了getFood方法 &#125;&#125;console.log(today.getFood());//bread和milkconsole.log(breakfast.getFood());//bread 16. Iterators手工实现迭代器一般迭代器需要有一个next方法，用来返回迭代数组的对象，该对象要求： value:指数组里的下一个对象 done: boolean 指是否迭代完成如果迭代完成了，done应该为true，同时返回的value应该为undefined 由此，根据需求，我们可以手工实现一个迭代器。12345678910111213141516171819let factory = function(cars)&#123; let i = 0; return &#123; next()&#123; let done = (i&gt;=cars.length); //注意done和value的定义顺序 let value = !done ? cars[i++] : undefined; return &#123; value:value, done:done &#125; &#125; &#125;&#125;let cars = factory(['劳斯莱斯','法拉利','保时捷']);console.log(cars.next());//Object &#123;value: \"劳斯莱斯\", done: false&#125;console.log(cars.next());//Object &#123;value: \"法拉利\", done: false&#125;console.log(cars.next());//Object &#123;value: \"保时捷\", done: false&#125;console.log(cars.next());//Object &#123;value: undefined, done: true&#125; 17. Generators手工写迭代器有些麻烦，我们可以利用Generators(生成器)来创建一个迭代器123456789101112131415161718import \"babel-polyfill\";function* factory()&#123; yield '劳斯莱斯'; yield '法拉利'; yield '保时捷';&#125;let cars = factory();console.log(cars.next());//Object &#123;value: \"劳斯莱斯\", done: false&#125;console.log(cars.next());//Object &#123;value: \"法拉利\", done: false&#125;console.log(cars.next());//Object &#123;value: \"保时捷\", done: false&#125;console.log(cars.next());//Object &#123;value: undefined, done: true&#125; 我们可以对这个生成器改造下，使他接收参数来迭代12345678910111213141516function* factory(cars)&#123; for(let i = 0; i &lt; cars.length; i++)&#123; yield cars[i] &#125;&#125; let cars = factory(['劳斯莱斯','法拉利','保时捷']); console.log(cars.next());//Object &#123;value: \"劳斯莱斯\", done: false&#125;console.log(cars.next());//Object &#123;value: \"法拉利\", done: false&#125;console.log(cars.next());//Object &#123;value: \"保时捷\", done: false&#125;console.log(cars.next());//Object &#123;value: undefined, done: true&#125; tips1:在浏览器端使用Generators会报错，regeneratorruntime is not defined 解决问题的前提：使用webpack或者其他构建工具来构建项目，因为我们需要添加ES6的regenerator模块，肯定涉及到import或者require该模块，虽然我们可以通过babel将ES6代码转成ES5的，但是浏览器端依旧不支持import或者require语法。我们得利用webpack之类的工具来构建，使得浏览器也支持模块加载import或者require语法。 解决方法一：引入babel的拓展包(Polyfill) [ 不推荐 ] 1.先在命令行 安装polyfill1npm install --save-dev babel-polyfill 2.在js头部引入 import &quot;babel-polyfill&quot; 但是依然会报错require is not defined,因为我们虽然引入了扩展包Polyfill,babel也帮我们转换成了es5语法，但是浏览器端依旧不认识import或者require这样的AMD规范的语法。想要在浏览器端也引入其他模块，需要利用webpack或者browserify的包装转换。 3.在webpack.config.js中最上面写上var babelpolyfill = require(“babel-polyfill”); 再在需要拓展的js文件的头部引入 import &quot;babel-polyfill&quot; 这样就既引入了扩展包，也让浏览器支持了import、require之类的AMD规范语法，就不会报错了。 解决方法二：使用transform-runtime来扩展 [ 推荐 ] tips2:babel-polyfill是可以的，但是他太大了现在6.0版本的babel改成了插件的形式，现在推荐的是transform-runtime babel-polyfill是一股脑把全部都添加到js文件中，而现在的transform-runtime将会判断你哪些需要加载的，有选择性的进行加载，并且后者也不会污染全局变量。 使用方法：1.安装babel-plugin-transform-runtime1npm i --save-dev babel-plugin-transform-runtime 2.在 .babelrc 文件中添加：123456789\"plugins\": [[ \"transform-runtime\", &#123; \"helpers\": false, \"polyfill\": false, \"regenerator\": true, \"moduleName\": \"babel-runtime\" &#125; ]] 18. class类 es6中可以创建一个类，他的constructor(字段)方法就是他的构造器，可以设置一些字段作为构造器的参数 ，方法直接用方法名(){}来定义，和Java写法差不多 [不过他好像不需要提前声明字段，直接在constructor里用this.字段=形参就行了 ] 123456789101112class Chef&#123; constructor(food)&#123; this.food = food; &#125; cook()&#123; console.log(this.food); &#125;&#125;let xiaoming = new Chef('apple');xiaoming.cook();//apple 19. getter和setter可以通过get和set属性，对一个字段进行操作12345678910111213141516171819class Chef&#123; constructor(food)&#123; this.food = food; this.dish = []; &#125; get menu()&#123; return this.dish; &#125; set menu(dish)&#123; this.dish.push(dish); &#125;&#125;let xiaoming = new Chef();console.log(xiaoming.menu = \"cake\");//cakeconsole.log(xiaoming.menu = \"noodles\");//noodlesconsole.log(xiaoming.menu);//[\"cake\", \"noodles\"] 20. 静态方法静态方法是不需要实例化，直接用类就可以使用的方法。直接在方法名前添加static关键字即可。 1234567class Chef&#123; static sayHi(name)&#123; console.log(`你好啊!$&#123;name&#125;`) &#125; &#125; Chef.sayHi(\"XiangNick\");//你好啊!XiangNick 21.extend 继承es6中终于实现了继承，以后不用再写用原型链或者遍历赋值那么麻烦的继承了123456789101112131415161718class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; sayHi()&#123; console.log('Hello!'); &#125;&#125;class littleBoy extends Person&#123; constructor(name,age)&#123; super(name,age); &#125;&#125;let nick = new littleBoy('nick','1995-12-10');nick.sayHi();//Hello! 子类的constructor需要通过super调用父类的构造器。 22. 集合 SetSet类似于Java中的Set，作为集合来存数据，Set中不允许有重复元素。 常用api add() Set 方法，添加元素,返回该Set has() boolean 方法，判断是否有某元素，返回boolean delete() boolean 方法，删除元素，返回是否删除成功 forEach((item)=&gt;{}) undefined 方法，迭代Set内元素，传回调进去，无返回值 clear() undefined 方法，清空Set，无返回值 size 属性，获得Set的元素个数1234567891011121314151617let foods = new Set();foods.add('noodle');foods.add('noodle');foods.add('apple');foods.add('banana');console.log(foods);//Set(3) &#123;\"noodle\", \"apple\", \"banana\"&#125;console.log(foods.size);//3console.log(foods.has('ice'));//falsefoods.delete('apple');console.log(foods);//Set(2) &#123;\"noodle\", \"banana\"&#125;foods.forEach(food =&gt;&#123; console.log(food); //noodle //banana&#125;);foods.clear();console.log(foods);//Set(0) &#123;&#125; 22. 集合 MapMap是K-V集合，JS中的对象也是K-V对应的，但是JS中的对象有局限性，比如他不能拿对象或者函数作为key，而Map可以。 常用api set() Map 方法，添加元素,返回该Map get() value 方法，根据key返回该value的值 has() boolean 方法，判断是否有某元素，返回boolean delete() boolean 方法，删除元素，返回是否删除成功 forEach((key,value)=&gt;{}) undefined 方法，迭代Map内元素，传回调进去，无返回值 clear() undefined 方法，清空Set，无返回值 size 属性，获得Set的元素个数 1234567891011121314151617181920let foods = new Map();let fruit = &#123;&#125;,cook = function()&#123;&#125;,dessert = \"甜点\"foods.set(fruit,\"apple\");foods.set(fruit,\"banana\");//相同的key，value会覆盖foods.set(cook,\"noddle\");foods.set(dessert,\"cake\");console.log(foods);//Map(3) &#123;Object &#123;&#125; =&gt; \"banana\", function =&gt; \"noddle\", \"甜点\" =&gt; \"cake\"&#125;console.log(foods.get(fruit));//bananafoods.delete(dessert);console.log(foods.size)//2console.log(foods.has(fruit));//truefoods.forEach((key,value)=&gt;&#123; console.log(`$&#123;key&#125;,$&#123;value&#125;`); //banana,[object Object] //noddle,function cook() &#123;&#125;&#125;)foods.clear();console.log(foods);//Map(0) &#123;&#125; 23. Modulees6中建议模块化编程，每一个js文件就是一个模块。可以import其他模块的接口和export接口给其他模块。 chef.js 123456789let dessert = \"cake\"export let fruit = \"banana\"let cook = function()&#123; console.log('I am cooking!~');&#125;let chef = &#123;name:\"xiaoming\",age:18&#125;;export &#123;cook,dessert&#125; ;export default chef; app.js 123456789101112131415161718import * as obj from './chef.js'//用* as 名称 则是把他所有export的包装成一个对象，一起导出import chef from './chef.js'//默认import就是他指定的defaultimport &#123;fruit&#125; from './chef.js'//使用&#123;&#125;内的名称要和他暴露的接口名称一致import &#123;dessert,cook&#125; from './chef.js'//&#123;&#125;内可以写多个接口名同时导出console.log(obj);//Object &#123;fruit: \"banana\", dessert: \"cake\", default: Object, __esModule: true, cook: function&#125;console.log(\"----\");console.log(chef);//Object &#123;name: \"xiaoming\", age: 18&#125;console.log(\"----\");console.log(fruit);//bananaconsole.log(\"----\");console.log(dessert,cook);/*cake function cook() &#123; console.log('I am cooking!~');&#125;*/ 可以直接在变量(可以是函数，对象，字符串等)处export，变量名就是接口名，要导出多少变量就要写多少个export，很麻烦，也不直观 [ 不推荐 ] export.js1export let fruit = \"apple\"; 这样接收方要用他暴露的接口名，使用{接口名}来接收 import.js1import &#123;fruit&#125; from './export.js' 上部写代码，底部使用{}来一口气导出多个接口 [ 推荐 ] export.js123456let fruit = \"apple\";let cook = function()&#123; console.log(\"I am cooking!~\");&#125;export &#123;fruit,cook&#125;;//很直观，能直接看到导出了哪些 接收方写的接口名要和导出方对应 import.js1import &#123;fruit,cook&#125; from './export.js'; 使用default关键字导出 之前的方式，都需要接收方知道导出方的接口名，而导出方使用default关键字来指定一个默认导出，接收方不需要知道该默认导出变量的接口名，可以自己随意命名使用。 export.js 123456789let fruit = \"apple\";let cook = function()&#123; console.log(\"I am cooking!~\");&#125;let chef = &#123;name:\"xiaoming\",age:18&#125;;export default chef; export &#123;fruit,cook&#125;; import.js 12import &#123;fruit,cook&#125; from './export.js'import something from './export.js' 注意： defalut关键字只能指定一个 default相当于给他指定了名字为default，导入方可以随意命名，导出的default接口不会影响其他导出接口，他们是独立的。 一般写react之类的组件化代码，直接给整个组件class类指定default，这样接收方好随意命名 as 关键字 导出方可以使用as关键字来给接口重新命名 export.js12let fruit = \"apple\";export &#123;fruit as something&#125; 这样接口名就更改了。导入方也可以使用as关键字来给接口再次重新命名 import.js1import &#123;something as fruit&#125; from './export.js' 导入导出方都可以使用as关键字来给接口重新命名。 除了export default 变量外，还可以使用as关键字export {变量 as default}来指定默认导出。 接收方还可以使用* as关键字将导出方的所有导出一起打包成一个以别名为变量名的对象1import * as obj from './export.js' 这样export.js里的所有导出的接口，包括default，都被一起打包进了obj对象里。使用： obj.接口名来调用普通导出 obj.default来调用默认导出","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"VSCode提供react-native提示","date":"2017-06-10T11:26:08.000Z","path":"2017/06/10/VSCode提供react-native提示/","text":"工具和插件编辑器： vscode.必装和推荐的插件如下： 代码智能提示对于第三方包，比如react-native： 一般安装了React Native Tools后，重启VSCode，并不会有代码提示，这时候需要安装typings 全局安装typings:1npm install typings -g 到项目的根目录下，利用typings的命令来安装React和react-native的接口说明文件123typings install dt~react --savetypings install dt~react-native --save 等待安装完成后（会取决于包的数目和网络状况），在项目的根目录下会有一个typings目录和typings.json配置文件 完成后重启一下code , 或者使用reload命令，现在react-native和react相关的代码就有提示说明了。","tags":[{"name":"IDE","slug":"IDE","permalink":"http://yoursite.com/tags/IDE/"},{"name":"RN","slug":"RN","permalink":"http://yoursite.com/tags/RN/"}]},{"title":"Java中的高并发(一)","date":"2017-06-09T02:03:46.000Z","path":"2017/06/09/Java中的高并发-一/","text":"一、并发知识基础1.1 临界区表示一种公共资源或者共享数据，可以被多个线程使用。但是每一次只能有一个线程使用他，一旦临界资源被占用，其他线程想要使用这个资源的只能挂起等待。如果有多个线程同时修改临界资源，就会出现线程不安全现象。 1.2 名词概念1.2.1 阻塞(Blocking)、非阻塞(Non-Blocking)用来形容多线程间的相互影响 阻塞一个线程占用了临界区资源，其他需要临界区资源的线程就必须在临界区中挂起等待，这种情况就是阻塞。 非阻塞与阻塞相反，他强调没有一个线程可以妨碍其他线程的执行，所有线程都在尝试不断前向执行。 1.2.2 多线程活跃性问题死锁多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。java 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。 饥饿一个或者多个线程因为种种原因一直无法获取所需要的资源，一直无法执行。 原因： ①优先级：高优先级的总是抢占低优先级的资源 就像小雏鸟总是抢不到食物，而产生饥饿的线程活跃性问题。 ②被阻塞：某线程一直占着关键资源不放，导致其他需要资源的线程无法正常执行。 活锁由于业务逻辑代码的设计，线程主动释放临界资源给别人使用，就会出现资源在多个线程之间切换而不使用，这种“谦让”的行为导致没有一个线程可以正常执行。 1.2.3 并发级别由于临界区的存在，需要对并发进行级别控制，指定控制策略，以下为5种并发级别。 阻塞定义：获取资源的线程会阻塞其他线程。（悲观策略） 实现：synchronized关键字、重入锁 无饥饿线程之间由于有优先级导致资源分配是不公平的，会产生饥饿现象。 无饥饿级别就是严格实行“先来后到”，无优先级。 无障碍定义：线程间不会因为临界区的问题而被挂起，大家都可以大摇大摆地进入临界区。对于临界区共享数据的修改，认为多个线程间不会发生冲突，都无障碍地执行，但是对于单个线程，一旦遇到冲突，就进行回滚。 缺点：当临界区中有严重冲突时，所有线程都可能会不断地回滚自己操作，没有一个线程可以走出临界区,可能会全军覆没。对于这个缺点，引出了下个无锁级别。 特点：一致性标记 实现：通过一致性标记来实现，线程在操作之前，先读取并保存这个标记，操作完成后再次读取，如果是一致的，说明资源访问没有冲突，可以修改。如果不一致，说明资源在操作过程中与其他写线程冲突，需要重试。对于成功修改的线程，一定要再更新修改这个一致性标记来表示自己已经修改过了。（version） 无锁定义：在无障碍的基础上实现的，但是不同的是，无锁的并发保证必然有一个线程能够在有限步内完成操作离开临界区。 特点：无穷循环 缺点：会出现饥饿现象，为了解决无锁的饥饿问题，引出了下个级别无等待。 实现：在无穷循环中，线程会不断尝试修改共享变量，如果没有冲突，修改成功，程序退出，否则继续尝试修改。但是总是能保证有一个线程是可以在有限步内完成，不至于全军覆没 示意代码：123while(!atomicVar.compareAndSet(localVar,localVar+1))&#123; localVar = atomicVar.get();&#125; 无等待定义：在无锁的基础上扩展，无锁等级要求必然有一个线程能够在有限步内完成操作离开临界区,而无等待要求所有的线程都必须在有限步内完成。如果限制这个步数上限，可以分为：有界无等待和线程数无关无等待。 实现：RCU(Read-Copy Update)读-拷贝修改对读无限制，所有读线程都是无等待的，写数据的时候，先取得原始数据副本，修改副本数据，再利用回调机制，在合适时机写回。 缺点：写开销大，延迟数据结构释放，复制被修改数据结构有开销。 1.3 Java内存模型(JMM)定义一种规则，保证多个线程间可以有效地、正确地协同工作。 原子性 指一个操作是不可中断的，在多线程一起执行的时候，一旦该操作开始，就不会被其他线程干扰。比如对静态全局变量 int i , 两个线程同时对它赋值，一个赋值1，一个赋值-1，那么int i的值要么为1，要么-1，是不可分割的。 但是在32位系统中，long型数据的读写不是原子性的 ( 因为long有64位 )，如果想要在32位系统保证long型数据的多线程下的安全性，可以用volatile关键字来修饰，虚拟机就会格外小心地处理该变量，以保证其多线程下的安全性。 可见性 当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。 对于串行程序来说，可见性问题是不存在的，因为在任何一个步骤修改了某个变量，后面的步骤读取的都是修改后的值。 而在多线程中，如果一个线程修改了某个全局变量，其他线程未必可以马上知道这个改动。 什么会引起可见性问题： 缓存优化：由于编译器优化或者硬件优化的缘故，可能会将共享变量缓存在cache或者寄存器里，那么其他线程修改了这个共享变量，当前线程可能使用的仍然是cache或者寄存器里的值。 硬件优化有些内存读写可能不会立即触发，而是会先进入一个硬件等待队列。 指令重排 编辑器优化 这些都有可能导致线程出现可见性问题，即一个线程的修改不会立即被其他线程察觉 有序性 一条指令的执行需要分很多步 ( 取指，译码，取寄存器操作数等… ) ，每一个步骤涉及的硬件也不同 ( PC寄存器，存储器，指令寄存器组等… ) ，多条指令执行间使用了指令流水线技术(多条指令交错地执行，有节拍)提升指令执行性能，但是指令中断(比如某操作要等待某一步的结果，就会阻塞，导致指令中断)会影响后面指令慢节拍，为了减少中断，cpu会采用指令重排( 代码顺序换个个 )，重排后的代码不会影响串行语义的一致，还能减少甚至消除指令中断，以提高性能。 指令重排能减少指令中断，提升cpu性能，对单线程，虽然代码执行顺序改变了，但是不会影响单线程串行语义一致。但是在多线程中，这种指令重排优化使得线程A的指令执行顺序在线程B中是没有保证的。 指令重排后的指令与原指令未必一致，多线程协作完成任务时，程序执行可能会出现乱序，在我们希望多线程拆分一个任务共同完成时可能会因为指令重排而出现有序性问题。 tips： 指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致。 指令重排是有原则的，Happen-Before原则。 Happen-Before原则： 程序顺序原则： 一个线程内保证语义的串行性 volatile规则：volatile变量的写，先发生于读，保证了volatile变量的可见性 锁规则：解锁 ( unlock ) 必然发生在随后的加锁 ( lock ) 前 传递性：A先于B，B先于C，A必然先于C 线程的start()方法先于它的每一个动作 线程的所有操作先于线程的终结 ( Thread.join() ) 线程的中断 ( interrupt() ) 先于被中断线程的代码 对象的构造函数执行、结束先于finalize()方法 二、Java并行程序基础2.1 线程的状态 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public enum State &#123; NEW, //刚刚new创建的线程 RUNNABLE, // 运行的线程 ( 回不去 NEW 状态 ) BLOCKED,// 遇到synchronized同步块，直到等到获得请求的锁 WAITING, // 无限时间的等待，等待结束事件， //通过wait()等待的，等待notify(),通过join()等待的，等待目标线程中止 TIMED_WAITING,//有限时间等待 TERMINATED//终止，( 回不去 runnable 状态 )&#125;``` ## 2.2 初始线程 ### 2.2.1 新建线程 1. 继承Thread类，覆写run()方法，或者直接new Thread的匿名内部类 2. 实现Runnable接口,实现run()方法，丢入Thread &lt;font color=skyblue&gt;[合理]&lt;/font&gt; ### 2.2.2 终止线程 &lt;font color=skyblue&gt;[暴力地停止线程]&lt;/font&gt; 如何手工关闭线程？ stop()方法 &lt;font color=skyblue&gt;[弃用]&lt;/font&gt; 因为stop方法太暴力，强行把执行到一半的线程终止，可能会引起数据不一致的问题。stop()方法在结束线程时，会直接终止线程，并且立即释放这个线程所持有的锁。而这些锁恰恰是用来维持对象一致性的。 &lt;font color=red&gt;不要随便使用stop()方法来终止一个线程( stop()方法已经弃用了 )&lt;/font&gt; 对stop()方法的改进。 可以定义一个flag变量stopme,和将该flag变量置为true的方法stopMe,在线程run()方法中，找一个安全的，不会把对象\"写坏\"的地方，不断判断flag，如果为true，就让线程的run()方法执行完毕，如在while循环中break。这样，我们在外部可以找一个合适的时机调用stopme方法将该线程的stopMe这个flag置为true，温和地让run()方法执行完毕，线程自然停止了。 代码实现: ```java public static class ChangeObjectThread extends Thread&#123; volatile boolean stopme = false; public void stopMe()&#123; stopme = true; &#125; @override public void run()&#123; while(true)&#123; if(stopme)&#123; System.out.println(\"exit by stop me.\"); break; &#125; synchronized(锁)&#123; 同步代码...,比如写对象 &#125; &#125; &#125; &#125; 这样当stopMe()方法被调用，run()方法中就会检测到stopme这个flag的改变，直接break了，run()方法执行完毕，线程终止，不会写坏对象。很温和。 2.2.3 线程中断 [温柔地停止线程]为了完善线程退出的功能，JDK提供了线程中断机制。 严格来说，线程中断并不会使线程立刻退出，而是给线程发送一个通知，告知目标线程，有人希望你退出，结束啦！至于线程接受到通知后如何处理，完全由目标线程自行决定。这点使得线程中断不会出现之前线程终止(stop方法)的数据一致性问题。 与线程中断有关的三个方法：1234public void Thread.interrupt() //--实例方法 中断线程 public boolean Thread.isInterrupted() //--实例方法 判断是否被中断public static boolean Thread.interrupted() //--静态方法 判断是否被中断，并清除当前中断状态 Thread.interrupt()是一个实例方法，通知目标线程中断，即设置中断标志位中断标志位表示当前线程已经被中断了。 Thread.isInterrupted()也是实例方法，判断当前线程是否有被中断 ( 判断中断标志位 ) Thread.interrupted()静态方法也是判断当前线程中断状态，但他还能清除当前线程的中断标志位状态。 在线程中没有预先写好中断处理的逻辑，调用t1.interrupt()方法来中断t1线程是无效的。所以想要t1在被置上中断标志位后能退出，还得自己在合适的地方写上中断处理逻辑代码。 举例：12345678910111213Thread t1 = new Thread()&#123; @Override public void run()&#123; while(true)&#123; if(Thread.currentThread().isInterrupted())&#123; System.out.println('Interrupted!'); break; //如果监测到t1被置上中断标志位，就break掉while循环， //线程执行完毕，中断了。 &#125; &#125; &#125;&#125; 和之前的stopMe示例很像，对吧。这三个方法是官方API实现。 Thread.sleep(long millis)方法。让当前线程休眠若干时间,会抛出InterruptedException,该方法由于中断而抛出异常，sleep方法会清除中断标记，下一次循环时就无法捕获这个中断了，所以在catch处理块中，还要手动设置中断标志位(Thread.currentThread().interrupt()). 2.2.4 等待 ( wait ) 和通知 ( notify )","tags":[{"name":"高并发与多线程","slug":"高并发与多线程","permalink":"http://yoursite.com/tags/高并发与多线程/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Java高并发程序设计","slug":"Java高并发程序设计","permalink":"http://yoursite.com/tags/Java高并发程序设计/"}]},{"title":"React学习","date":"2017-05-31T07:27:49.000Z","path":"2017/05/31/React学习/","text":"一、WebPack快速搭建在我的GitHub上上传了react初始化模版,可以直接clone下来开始撸React了。 二、主要知识内容1 . 视图相关概念 Props（属性，就是element上的attrs，换个名字property，变成复数，即props） State（写过view组件的基本都会知道，按钮有三态，Normal，Highlight，Selected，包括extjs，jquery里的大部分ui框架都是有状态的。） Event（dom事件） 在React中 属性，解决了view的定义问题，即语义描述 状态，是view的有穷状态机，根据状态决定组件ui和行为 事件，是view里元素的行为 2 . 支持的标签和属性 并不是所有的html标签和属性都能在jsx语法中使用 基本上日常开发中能用到的标签的属性，jsx语法都支持 特殊的属性： class -&gt; className (label的for属性)for -&gt; htmlFor 所有的属性都是驼峰命名的，class 属性和 for 属性分别改为 className 和 htmlFor，来符合 DOM API 规范。 3 . 属性扩散 123456let msg = &#123; age : 22, name : 'XiangNick' &#125;&lt;Hello &#123;...msg&#125;/&gt; 即可一次性给Hello组件绑定多个属性 属性也可以被覆盖，写在后面的属性值会覆盖前面的属性。 4 . 注释 JSX 里的注释是沿用 JavaScript 的注释方式，唯一要注意的是在一个组件的子元素位置使用注释要用 {} 包起来。 因为在JSX中遇到&lt;&gt;是按照html解析，遇到{}才会当作js来解析。 1234&lt;Father&gt; &#123;/*我是注释*/&#125; &lt;Son&gt;&lt;/Son&gt;&lt;/Father&gt; 5 . 组件的生命周期[重要] 组件的生命周期又名状态回调 三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 处理函数(生命周期函数)： React 为每个状态都提供了两种处理函数，will函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。12345componentWillMount()componentDidMount()componentWillUpdate(object nextProps, object nextState)componentDidUpdate(object prevProps, object prevState)componentWillUnmount() 此外，React 还提供两种特殊状态的处理函数。12345//已加载组件收到新的参数时调用 componentWillReceiveProps(object nextProps) //组件判断是否重新渲染时调用 shouldComponentUpdate(object nextProps, object nextState) 6 . 函数调用顺序图 上半部的生命周期方法只在组件的生命中执行一次(初始化)，下半部的生命周期方法将不断监听，循环执行 只有在componentDidMount()之后，组件才加载入真实dom 7 . 组件写法 ES5写法12345678910111213141516var Hello = React.createClass(&#123; getInitialState() &#123; return &#123; liked: false &#125;; &#125;, render: function() &#123; console.log(this.state.liked); return( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125;);module.exports=Hello; ES6写法12345678910111213141516export default class Hello extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; count: 'es6'&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1 style=&#123;style&#125;&gt;Hello world&#123;this.state.count&#125;&lt;/h1&gt; &lt;br/&gt; &lt;image/&gt; &lt;/div&gt; ) &#125;&#125; 不错的文章： React的：[译]在 React.js 中使用 ES6+ React Native的：React/React Native 的ES5 ES6写法对照表 8 . Dom操作 方法一：findDOMNode()方法（了解） ReactDOM.render 组件返回的是对组件的引用也就是组件实例（对于无状态状态组件来说返回 null），注意 JSX 返回的不是组件实例，它只是一个 ReactElement 对象。当组件加载到页面上之后（mounted），你都可以通过 react-dom 提供的 findDOMNode() 方法拿到组件对应的 DOM 元素。123456import &#123; findDOMNode &#125; from 'react-dom';// Inside Component classcomponentDidMound() &#123; const el = findDOMNode(this);&#125; findDOMNode() 不能用在无状态组件上。 方法二：refs属性 另外一种方式就是通过在要引用的 DOM 元素上面设置一个 ref 属性指定一个名称，然后通过 this.refs.name 来访问对应的 DOM 元素。如果 ref 是设置在原生 HTML 元素上，它拿到的就是 DOM 元素，如果设置在自定义组件上，它拿到的就是组件实例，这时候就需要通过 findDOMNode 来拿到组件的 DOM 元素。 因为无状态组件没有实例，所以 ref 不能设置在无状态组件上，一般来说这没什么问题，因为无状态组件没有实例方法，不需要 ref 去拿实例调用相关的方法，但是如果想要拿无状态组件的 DOM 元素的时候，就需要用一个状态组件封装一层，然后通过 ref 和 findDOMNode 去获取。12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';export default class MyInputFocus extends Component &#123; constructor(props) &#123; super(props); this.state=&#123; userInput: '' &#125;; &#125; handleChange(e) &#123; console.log(this.refs.theInput.value); this.setState(&#123; userInput: e.target.value &#125;); &#125; clearAndFocusInput() &#123; this.setState(&#123; userInput: '' &#125;, () =&gt; &#123; this.refs.theInput.focus(); &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;div onClick=&#123;this.clearAndFocusInput.bind(this)&#125;&gt; Click to Focus and Reset &lt;/div&gt; &lt;input ref=\"theInput\" value=&#123;this.state.userInput&#125; onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;MyInputFocus.defaultProps=&#123; autoPlay:false, maxLoops:10,&#125;MyInputFocus.propTypes = &#123; autoPlay: React.PropTypes.bool.isRequired, maxLoops: React.PropTypes.number.isRequired,&#125; 注意事项 可以使用 ref 到的组件定义的任何公共方法，比如 this.refs.myTypeahead.reset() Refs 是访问到组件内部 DOM 节点唯一可靠的方法 Refs 会自动销毁对子组件的引用（当子组件删除时） 不要在 render 或者 render 之前访问 refs 不要滥用 refs，比如只是用它来按照传统的方式操作界面 UI：找到 DOM -&gt; 更新 DOM 给 DOM 元素绑定 React 未提供的事件123456789handleResize : (e) =&gt; &#123; this.setState(&#123;windowWidth: window.innerWidth&#125;); &#125;componentDidMount() &#123; window.addEventListener('resize', this.handleResize); &#125; componentWillUnmount() &#123; window.removeEventListener('resize', this.handleResize); &#125; 需要在component的 componentDidMount方法中通过window.addEventListener来添加监听 别忘了在componentWillUnmount中再window.removeEventListener来解除监听 未完待续…","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"React的ES6写法","date":"2017-05-28T08:42:46.000Z","path":"2017/05/28/React的ES6写法/","text":"语法规定 定义模块 class Life extends Component 导出模块 export default 引入模块 import 定义默认porps 1234static defaultProps = &#123;autoPlay: false, maxLoops: 10,&#125;; // 注意这里有分号 衍生：定义class中的静态属性，如：contextTypes，childContextTypes，propTypes，可以采用2种写法 写法一：1234567//直接在class里定义静态变量(对象)class Demo1 extends Component&#123; static propTypes = &#123; autoPlay : PropTypes.bool.isRequired, maxLoop : PropTypes.number.isRequired &#125;&#125; 写法二：12345678//在class外通过.的方式绑定静态变量class Demo2 extends Component&#123;&#125;Demo2.propTypes = &#123; autoPlay : PropTypes.bool.isRequired, maxLoop : PropTypes.number.isRequired&#125; ps： propTypes：给标签的prop属性定义类型校验 eg:&lt;MyVedio autoPlay={true}/&gt; autoPlay就是自己添加的prop contextTypes：自己的context类型校验 childContextTypes：后代的context类型校验 定义默认state 123456789constructor(props)&#123; super(props); console.log(\"构造函数\"); // 初始化了我们的state，这是被推荐的写法，构造函数里可以 //this.state直接=&#123;&#125;，其他的地方修改state需要this.setState(&#123;&#125;) this.state = &#123; props1:\"初始化state\" &#125;;&#125; 定义方法 （1）生命周期的方法 (覆写) 在class里定义，方法间不需要加逗号 格式为 ： 方法名(){方法体} 同Java写法123componentWillMount()&#123; console.log(\"componentWillMount\");&#125; (2)自定义的方法 在class里定义，推荐使用箭头函数(es6里class的this指向需要通过.bind(this)来指定，但是使用箭头函数则不需要手动指定了) 1234567click1=()=&gt;&#123; console.log(\"点击了单击事件\"); this.setState(&#123; props1:\"改变state的值\" &#125;) console.log(\"点击了单击事件结束\");&#125; 然后在render里可以直接&lt;h1 onClick = {this.click1}&gt;来调用12345678render() &#123; console.log(\"render\"); return ( &lt;div&gt; &lt;h1 onClick=&#123;this.click1&#125;&gt;&#123;this.state.props1&#125;&lt;/h1&gt; &lt;/div&gt; ) &#125; 如果需要调用的带参数的方法，需要这种写法123456789101112131415handleClick=(args1,args2,fn,e)=&gt;&#123; console.log(args1); console.log(args2); fn(); console.log(e); &#125;render() &#123; return ( &lt;div&gt; &lt;h1 onClick=&#123;()=&gt;this.handleClick('a','b',()=&gt;&#123;alert('c')&#125;,event)&#125;&gt;Name:&#123;this.props.name&#125;&lt;/h1&gt; &lt;h2&gt;Age:&#123;this.props.age&#125;&lt;/h2&gt; &lt;h3&gt;Hobby:&#123;this.state.hobby&#125;&lt;/h3&gt; &lt;/div&gt; )&#125; 即在标签中，在事件调用，不要用&lt;h1 onClick={this.handleClick(参数)}&gt;,这样还没点击，就随着页面加载自动执行了。 正确方式为：需要使用箭头函数包一下，即&lt;h1 onClick={()=&gt;{this.handleClick(参数)}&gt;意思是点击了再执行该方法 向子代传递数据 父代： (1) 覆写getChildContext方法，返回数据对象12345getChildContext() &#123; return &#123; color: 'skyblue' &#125;&#125; (2) 覆写 childContextTypes 静态属性，给需要给后代传的数据对象 定义类型校验123static childContextTypes = &#123; color : PropTypes.string&#125; 子代： (1) 覆写自己的 contextTypes 静态属性， 以对其从父代传递，自己继承来的context属性进行类型校验123static contextTypes = &#123; color : PropTypes.string&#125; (2) 在子代中可以直接通过 this.context.属性名 获得父代传递的属性 案例：123456789101112131415161718192021222324252627282930313233343536373839404142import React , &#123; Component &#125; from 'react'import PropTypes from 'prop-types'class Son extends Component&#123; // (3) 对自己继承来的context值类型校验 static contextTypes = &#123; color : PropTypes.string &#125; render()&#123; // (4) 直接this.context.属性名获取传递来的值 return ( &lt;button style=&#123;&#123;backgroundColor:this.context.color&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/button&gt; ) //this.props.children可以获取到&lt;Son&gt;之间的文本值&lt;/Son&gt; &#125;&#125;class Father extends Component&#123; //(2) 定义子代Context的类型校验 static childContextTypes = &#123; color : PropTypes.string &#125; //(1) 覆写该方法，返回值是给子代传递的值对象 getChildContext()&#123; return &#123; color : 'skyblue' &#125; &#125; render()&#123; return ( &lt;div&gt; &lt;Son&gt;按钮&lt;/Son&gt; &lt;/div&gt; ) &#125;&#125;//对外暴露Fatherexport default Father;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"全国城市JSON列表","date":"2017-05-23T02:52:22.000Z","path":"2017/05/23/全国城市JSON列表/","text":"省市县三级 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269127012711272127312741275127612771278127912801281128212831284128512861287128812891290129112921293129412951296129712981299130013011302130313041305130613071308130913101311131213131314131513161317131813191320132113221323132413251326132713281329133013311332133313341335133613371338133913401341134213431344134513461347134813491350135113521353135413551356135713581359136013611362136313641365136613671368136913701371137213731374137513761377137813791380138113821383138413851386138713881389139013911392139313941395139613971398139914001401140214031404140514061407140814091410141114121413141414151416141714181419142014211422142314241425142614271428142914301431143214331434143514361437143814391440144114421443144414451446144714481449145014511452145314541455145614571458145914601461146214631464146514661467146814691470147114721473147414751476147714781479148014811482148314841485148614871488148914901491149214931494149514961497149814991500150115021503150415051506150715081509151015111512151315141515151615171518151915201521152215231524152515261527152815291530153115321533153415351536153715381539154015411542154315441545154615471548154915501551155215531554155515561557155815591560156115621563156415651566156715681569157015711572157315741575157615771578157915801581158215831584158515861587158815891590159115921593159415951596159715981599160016011602160316041605160616071608160916101611161216131614161516161617161816191620162116221623162416251626162716281629163016311632163316341635163616371638163916401641164216431644164516461647164816491650165116521653165416551656165716581659166016611662166316641665166616671668166916701671167216731674167516761677167816791680168116821683168416851686168716881689169016911692169316941695169616971698169917001701170217031704170517061707170817091710171117121713171417151716171717181719172017211722172317241725[ &#123; \"name\": \"北京\", \"city\": [&#123; \"name\": \"北京\", \"area\": [\"东城区\", \"西城区\", \"崇文区\", \"宣武区\", \"朝阳区\", \"丰台区\", \"石景山区\", \"海淀区\", \"门头沟区\", \"房山区\", \"通州区\", \"顺义区\", \"昌平区\", \"大兴区\", \"平谷区\", \"怀柔区\", \"密云县\", \"延庆县\"] &#125;] &#125;, &#123; \"name\": \"天津\", \"city\": [&#123; \"name\": \"天津\", \"area\": [\"和平区\", \"河东区\", \"河西区\", \"南开区\", \"河北区\", \"红桥区\", \"塘沽区\", \"汉沽区\", \"大港区\", \"东丽区\", \"西青区\", \"津南区\", \"北辰区\", \"武清区\", \"宝坻区\", \"宁河县\", \"静海县\", \"蓟 县\"] &#125;] &#125;, &#123; \"name\": \"河北\", \"city\": [ &#123; \"name\": \"石家庄\", \"area\": [\"长安区\", \"桥东区\", \"桥西区\", \"新华区\", \"郊 区\", \"井陉矿区\", \"井陉县\", \"正定县\", \"栾城县\", \"行唐县\", \"灵寿县\", \"高邑县\", \"深泽县\", \"赞皇县\", \"无极县\", \"平山县\", \"元氏县\", \"赵 县\", \"辛集市\", \"藁\", \"晋州市\", \"新乐市\", \"鹿泉市\"] &#125;, &#123; \"name\": \"唐山\", \"area\": [\"路南区\", \"路北区\", \"古冶区\", \"开平区\", \"新 区\", \"丰润县\", \"滦 县\", \"滦南县\", \"乐亭县\", \"迁西县\", \"玉田县\", \"唐海县\", \"遵化市\", \"丰南市\", \"迁安市\"] &#125;, &#123; \"name\": \"秦皇岛\", \"area\": [\"海港区\", \"山海关区\", \"北戴河区\", \"青龙满族自治县\", \"昌黎县\", \"抚宁县\", \"卢龙县\"] &#125;, &#123; \"name\": \"邯郸\", \"area\": [\"邯山区\", \"丛台区\", \"复兴区\", \"峰峰矿区\", \"邯郸县\", \"临漳县\", \"成安县\", \"大名县\", \"涉 县\", \"磁 县\", \"肥乡县\", \"永年县\", \"邱 县\", \"鸡泽县\", \"广平县\", \"馆陶县\", \"魏 县\", \"曲周县\", \"武安市\"] &#125;, &#123; \"name\": \"邢台\", \"area\": [\"桥东区\", \"桥西区\", \"邢台县\", \"临城县\", \"内丘县\", \"柏乡县\", \"隆尧县\", \"任 县\", \"南和县\", \"宁晋县\", \"巨鹿县\", \"新河县\", \"广宗县\", \"平乡县\", \"威 县\", \"清河县\", \"临西县\", \"南宫市\", \"沙河市\"] &#125;, &#123; \"name\": \"保定\", \"area\": [\"新市区\", \"北市区\", \"南市区\", \"满城县\", \"清苑县\", \"涞水县\", \"阜平县\", \"徐水县\", \"定兴县\", \"唐 县\", \"高阳县\", \"容城县\", \"涞源县\", \"望都县\", \"安新县\", \"易 县\", \"曲阳县\", \"蠡 县\", \"顺平县\", \"博野\", \"雄县\", \"涿州市\", \"定州市\", \"安国市\", \"高碑店市\"] &#125;, &#123; \"name\": \"张家口\", \"area\": [\"桥东区\", \"桥西区\", \"宣化区\", \"下花园区\", \"宣化县\", \"张北县\", \"康保县\", \"沽源县\", \"尚义县\", \"蔚 县\", \"阳原县\", \"怀安县\", \"万全县\", \"怀来县\", \"涿鹿县\", \"赤城县\", \"崇礼县\"] &#125;, &#123; \"name\": \"承德\", \"area\": [\"双桥区\", \"双滦区\", \"鹰手营子矿区\", \"承德县\", \"兴隆县\", \"平泉县\", \"滦平县\", \"隆化县\", \"丰宁满族自治县\", \"宽城满族自治县\", \"围场满族蒙古族自治县\"] &#125;, &#123; \"name\": \"沧州\", \"area\": [\"新华区\", \"运河区\", \"沧 县\", \"青 县\", \"东光县\", \"海兴县\", \"盐山县\", \"肃宁县\", \"南皮县\", \"吴桥县\", \"献 县\", \"孟村回族自治县\", \"泊头市\", \"任丘市\", \"黄骅市\", \"河间市\"] &#125;, &#123; \"name\": \"廊坊\", \"area\": [\"安次区\", \"固安县\", \"永清县\", \"香河县\", \"大城县\", \"文安县\", \"大厂回族自治县\", \"霸州市\", \"三河市\"] &#125;, &#123; \"name\": \"衡水\", \"area\": [\"桃城区\", \"枣强县\", \"武邑县\", \"武强县\", \"饶阳县\", \"安平县\", \"故城县\", \"景 县\", \"阜城县\", \"冀州市\", \"深州市\"] &#125; ] &#125;, &#123; \"name\": \"山西\", \"city\": [ &#123; \"name\": \"太原\", \"area\": [\"小店区\", \"迎泽区\", \"杏花岭区\", \"尖草坪区\", \"万柏林区\", \"晋源区\", \"清徐县\", \"阳曲县\", \"娄烦县\", \"古交市\"] &#125;, &#123; \"name\": \"大同\", \"area\": [\"城 区\", \"矿 区\", \"南郊区\", \"新荣区\", \"阳高县\", \"天镇县\", \"广灵县\", \"灵丘县\", \"浑源县\", \"左云县\", \"大同县\"] &#125;, &#123; \"name\": \"阳泉\", \"area\": [\"城 区\", \"矿 区\", \"郊 区\", \"平定县\", \"盂 县\"] &#125;, &#123; \"name\": \"长治\", \"area\": [\"城 区\", \"郊 区\", \"长治县\", \"襄垣县\", \"屯留县\", \"平顺县\", \"黎城县\", \"壶关县\", \"长子县\", \"武乡县\", \"沁 县\", \"沁源县\", \"潞城市\"] &#125;, &#123; \"name\": \"晋城\", \"area\": [\"城 区\", \"沁水县\", \"阳城县\", \"陵川县\", \"泽州县\", \"高平市\"] &#125;, &#123; \"name\": \"朔州\", \"area\": [\"朔城区\", \"平鲁区\", \"山阴县\", \"应 县\", \"右玉县\", \"怀仁县\"] &#125;, &#123; \"name\": \"忻州\", \"area\": [\"忻府区\", \"原平市\", \"定襄县\", \"五台县\", \"代 县\", \"繁峙县\", \"宁武县\", \"静乐县\", \"神池县\", \"五寨县\", \"岢岚县\", \"河曲县\", \"保德县\", \"偏关县\"] &#125;, &#123; \"name\": \"吕梁\", \"area\": [\"离石区\", \"孝义市\", \"汾阳市\", \"文水县\", \"交城县\", \"兴 县\", \"临 县\", \"柳林县\", \"石楼县\", \"岚 县\", \"方山县\", \"中阳县\", \"交口县\"] &#125;, &#123; \"name\": \"晋中\", \"area\": [\"榆次市\", \"介休市\", \"榆社县\", \"左权县\", \"和顺县\", \"昔阳县\", \"寿阳县\", \"太谷县\", \"祁 县\", \"平遥县\", \"灵石县\"] &#125;, &#123; \"name\": \"临汾\", \"area\": [\"临汾市\", \"侯马市\", \"霍州市\", \"曲沃县\", \"翼城县\", \"襄汾县\", \"洪洞县\", \"古 县\", \"安泽县\", \"浮山县\", \"吉 县\", \"乡宁县\", \"蒲 县\", \"大宁县\", \"永和县\", \"隰 县\", \"汾西县\"] &#125;, &#123; \"name\": \"运城\", \"area\": [\"运城市\", \"永济市\", \"河津市\", \"芮城县\", \"临猗县\", \"万荣县\", \"新绛县\", \"稷山县\", \"闻喜县\", \"夏 县\", \"绛 县\", \"平陆县\", \"垣曲县\"] &#125; ] &#125;, &#123; \"name\": \"内蒙古\", \"city\": [ &#123; \"name\": \"呼和浩特\", \"area\": [\"新城区\", \"回民区\", \"玉泉区\", \"郊 区\", \"土默特左旗\", \"托克托县\", \"和林格尔县\", \"清水河县\", \"武川县\"] &#125;, &#123; \"name\": \"包头\", \"area\": [\"东河区\", \"昆都伦区\", \"青山区\", \"石拐矿区\", \"白云矿区\", \"郊 区\", \"土默特右旗\", \"固阳县\", \"达尔罕茂明安联合旗\"] &#125;, &#123; \"name\": \"乌海\", \"area\": [\"海勃湾区\", \"海南区\", \"乌达区\"] &#125;, &#123; \"name\": \"赤峰\", \"area\": [\"红山区\", \"元宝山区\", \"松山区\", \"阿鲁科尔沁旗\", \"巴林左旗\", \"巴林右旗\", \"林西县\", \"克什克腾旗\", \"翁牛特旗\", \"喀喇沁旗\", \"宁城县\", \"敖汉旗\"] &#125;, &#123; \"name\": \"呼伦贝尔\", \"area\": [\"海拉尔市\", \"满洲里市\", \"扎兰屯市\", \"牙克石市\", \"根河市\", \"额尔古纳市\", \"阿荣旗\", \"莫力达瓦达斡尔族自治旗\", \"鄂伦春自治旗\", \"鄂温克族自治旗\", \"新巴尔虎右旗\", \"新巴尔虎左旗\", \"陈巴尔虎旗\"] &#125;, &#123; \"name\": \"兴安盟\", \"area\": [\"乌兰浩特市\", \"阿尔山市\", \"科尔沁右翼前旗\", \"科尔沁右翼中旗\", \"扎赉特旗\", \"突泉县\"] &#125;, &#123; \"name\": \"通辽\", \"area\": [\"科尔沁区\", \"霍林郭勒市\", \"科尔沁左翼中旗\", \"科尔沁左翼后旗\", \"开鲁县\", \"库伦旗\", \"奈曼旗\", \"扎鲁特旗\"] &#125;, &#123; \"name\": \"锡林郭勒盟\", \"area\": [\"二连浩特市\", \"锡林浩特市\", \"阿巴嘎旗\", \"苏尼特左旗\", \"苏尼特右旗\", \"东乌珠穆沁旗\", \"西乌珠穆沁旗\", \"太仆寺旗\", \"镶黄旗\", \"正镶白旗\", \"正蓝旗\", \"多伦县\"] &#125;, &#123; \"name\": \"乌兰察布盟\", \"area\": [\"集宁市\", \"丰镇市\", \"卓资县\", \"化德县\", \"商都县\", \"兴和县\", \"凉城县\", \"察哈尔右翼前旗\", \"察哈尔右翼中旗\", \"察哈尔右翼后旗\", \"四子王旗\"] &#125;, &#123; \"name\": \"伊克昭盟\", \"area\": [\"东胜市\", \"达拉特旗\", \"准格尔旗\", \"鄂托克前旗\", \"鄂托克旗\", \"杭锦旗\", \"乌审旗\", \"伊金霍洛旗\"] &#125;, &#123; \"name\": \"巴彦淖尔盟\", \"area\": [\"临河市\", \"五原县\", \"磴口县\", \"乌拉特前旗\", \"乌拉特中旗\", \"乌拉特后旗\", \"杭锦后旗\"] &#125;, &#123; \"name\": \"阿拉善盟\", \"area\": [\"阿拉善左旗\", \"阿拉善右旗\", \"额济纳旗\"] &#125; ] &#125;, &#123; \"name\": \"辽宁\", \"city\": [ &#123; \"name\": \"沈阳\", \"area\": [\"沈河区\", \"皇姑区\", \"和平区\", \"大东区\", \"铁西区\", \"苏家屯区\", \"东陵区\", \"于洪区\", \"新民市\", \"法库县\", \"辽中县\", \"康平县\", \"新城子区\", \"其他\"] &#125;, &#123; \"name\": \"大连\", \"area\": [\"西岗区\", \"中山区\", \"沙河口区\", \"甘井子区\", \"旅顺口区\", \"金州区\", \"瓦房店市\", \"普兰店市\", \"庄河市\", \"长海县\", \"其他\"] &#125;, &#123; \"name\": \"鞍山\", \"area\": [\"铁东区\", \"铁西区\", \"立山区\", \"千山区\", \"海城市\", \"台安县\", \"岫岩满族自治县\", \"其他\"] &#125;, &#123; \"name\": \"抚顺\", \"area\": [\"顺城区\", \"新抚区\", \"东洲区\", \"望花区\", \"抚顺县\", \"清原满族自治县\", \"新宾满族自治县\", \"其他\"] &#125;, &#123; \"name\": \"本溪\", \"area\": [\"平山区\", \"明山区\", \"溪湖区\", \"南芬区\", \"本溪满族自治县\", \"桓仁满族自治县\", \"其他\"] &#125;, &#123; \"name\": \"丹东\", \"area\": [\"振兴区\", \"元宝区\", \"振安区\", \"东港市\", \"凤城市\", \"宽甸满族自治县\", \"其他\"] &#125;, &#123; \"name\": \"锦州\", \"area\": [\"太和区\", \"古塔区\", \"凌河区\", \"凌海市\", \"黑山县\", \"义县\", \"北宁市\", \"其他\"] &#125;, &#123; \"name\": \"营口\", \"area\": [\"站前区\", \"西市区\", \"鲅鱼圈区\", \"老边区\", \"大石桥市\", \"盖州市\", \"其他\"] &#125;, &#123; \"name\": \"阜新\", \"area\": [\"海州区\", \"新邱区\", \"太平区\", \"清河门区\", \"细河区\", \"彰武县\", \"阜新蒙古族自治县\", \"其他\"] &#125;, &#123; \"name\": \"辽阳\", \"area\": [\"白塔区\", \"文圣区\", \"宏伟区\", \"太子河区\", \"弓长岭区\", \"灯塔市\", \"辽阳县\", \"其他\"] &#125;, &#123; \"name\": \"盘锦\", \"area\": [\"双台子区\", \"兴隆台区\", \"盘山县\", \"大洼县\", \"其他\"] &#125;, &#123; \"name\": \"铁岭\", \"area\": [\"银州区\", \"清河区\", \"调兵山市\", \"开原市\", \"铁岭县\", \"昌图县\", \"西丰县\", \"其他\"] &#125;, &#123; \"name\": \"朝阳\", \"area\": [\"双塔区\", \"龙城区\", \"凌源市\", \"北票市\", \"朝阳县\", \"建平县\", \"喀喇沁左翼蒙古族自治县\", \"其他\"] &#125;, &#123; \"name\": \"葫芦岛\", \"area\": [\"龙港区\", \"南票区\", \"连山区\", \"兴城市\", \"绥中县\", \"建昌县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"吉林\", \"city\": [ &#123; \"name\": \"长春\", \"area\": [\"朝阳区\", \"宽城区\", \"二道区\", \"南关区\", \"绿园区\", \"双阳区\", \"九台市\", \"榆树市\", \"德惠市\", \"农安县\", \"其他\"] &#125;, &#123; \"name\": \"吉林\", \"area\": [\"船营区\", \"昌邑区\", \"龙潭区\", \"丰满区\", \"舒兰市\", \"桦甸市\", \"蛟河市\", \"磐石市\", \"永吉县\", \"其他\"] &#125;, &#123; \"name\": \"四平\", \"area\": [\"铁西区\", \"铁东区\", \"公主岭市\", \"双辽市\", \"梨树县\", \"伊通满族自治县\", \"其他\"] &#125;, &#123; \"name\": \"辽源\", \"area\": [\"龙山区\", \"西安区\", \"东辽县\", \"东丰县\", \"其他\"] &#125;, &#123; \"name\": \"通化\", \"area\": [\"东昌区\", \"二道江区\", \"梅河口市\", \"集安市\", \"通化县\", \"辉南县\", \"柳河县\", \"其他\"] &#125;, &#123; \"name\": \"白山\", \"area\": [\"八道江区\", \"江源区\", \"临江市\", \"靖宇县\", \"抚松县\", \"长白朝鲜族自治县\", \"其他\"] &#125;, &#123; \"name\": \"松原\", \"area\": [\"宁江区\", \"乾安县\", \"长岭县\", \"扶余县\", \"前郭尔罗斯蒙古族自治县\", \"其他\"] &#125;, &#123; \"name\": \"白城\", \"area\": [\"洮北区\", \"大安市\", \"洮南市\", \"镇赉县\", \"通榆县\", \"其他\"] &#125;, &#123; \"name\": \"延边朝鲜族自治州\", \"area\": [\"延吉市\", \"图们市\", \"敦化市\", \"龙井市\", \"珲春市\", \"和龙市\", \"安图县\", \"汪清县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"黑龙江\", \"city\": [ &#123; \"name\": \"哈尔滨\", \"area\": [\"松北区\", \"道里区\", \"南岗区\", \"平房区\", \"香坊区\", \"道外区\", \"呼兰区\", \"阿城区\", \"双城市\", \"尚志市\", \"五常市\", \"宾县\", \"方正县\", \"通河县\", \"巴彦县\", \"延寿县\", \"木兰县\", \"依兰县\", \"其他\"] &#125;, &#123; \"name\": \"齐齐哈尔\", \"area\": [\"龙沙区\", \"昂昂溪区\", \"铁锋区\", \"建华区\", \"富拉尔基区\", \"碾子山区\", \"梅里斯达斡尔族区\", \"讷河市\", \"富裕县\", \"拜泉县\", \"甘南县\", \"依安县\", \"克山县\", \"泰来县\", \"克东县\", \"龙江县\", \"其他\"] &#125;, &#123; \"name\": \"鹤岗\", \"area\": [\"兴山区\", \"工农区\", \"南山区\", \"兴安区\", \"向阳区\", \"东山区\", \"萝北县\", \"绥滨县\", \"其他\"] &#125;, &#123; \"name\": \"双鸭山\", \"area\": [\"尖山区\", \"岭东区\", \"四方台区\", \"宝山区\", \"集贤县\", \"宝清县\", \"友谊县\", \"饶河县\", \"其他\"] &#125;, &#123; \"name\": \"鸡西\", \"area\": [\"鸡冠区\", \"恒山区\", \"城子河区\", \"滴道区\", \"梨树区\", \"麻山区\", \"密山市\", \"虎林市\", \"鸡东县\", \"其他\"] &#125;, &#123; \"name\": \"大庆\", \"area\": [\"萨尔图区\", \"红岗区\", \"龙凤区\", \"让胡路区\", \"大同区\", \"林甸县\", \"肇州县\", \"肇源县\", \"杜尔伯特蒙古族自治县\", \"其他\"] &#125;, &#123; \"name\": \"伊春\", \"area\": [\"伊春区\", \"带岭区\", \"南岔区\", \"金山屯区\", \"西林区\", \"美溪区\", \"乌马河区\", \"翠峦区\", \"友好区\", \"上甘岭区\", \"五营区\", \"红星区\", \"新青区\", \"汤旺河区\", \"乌伊岭区\", \"铁力市\", \"嘉荫县\", \"其他\"] &#125;, &#123; \"name\": \"牡丹江\", \"area\": [\"爱民区\", \"东安区\", \"阳明区\", \"西安区\", \"绥芬河市\", \"宁安市\", \"海林市\", \"穆棱市\", \"林口县\", \"东宁县\", \"其他\"] &#125;, &#123; \"name\": \"佳木斯\", \"area\": [\"向阳区\", \"前进区\", \"东风区\", \"郊区\", \"同江市\", \"富锦市\", \"桦川县\", \"抚远县\", \"桦南县\", \"汤原县\", \"其他\"] &#125;, &#123; \"name\": \"七台河\", \"area\": [\"桃山区\", \"新兴区\", \"茄子河区\", \"勃利县\", \"其他\"] &#125;, &#123; \"name\": \"黑河\", \"area\": [\"爱辉区\", \"北安市\", \"五大连池市\", \"逊克县\", \"嫩江县\", \"孙吴县\", \"其他\"] &#125;, &#123; \"name\": \"绥化\", \"area\": [\"北林区\", \"安达市\", \"肇东市\", \"海伦市\", \"绥棱县\", \"兰西县\", \"明水县\", \"青冈县\", \"庆安县\", \"望奎县\", \"其他\"] &#125;, &#123; \"name\": \"大兴安岭地区\", \"area\": [\"呼玛县\", \"塔河县\", \"漠河县\", \"大兴安岭辖区\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"上海\", \"city\": [ &#123; \"name\": \"上海\", \"area\": [\"黄浦区\", \"卢湾区\", \"徐汇区\", \"长宁区\", \"静安区\", \"普陀区\", \"闸北区\", \"虹口区\", \"杨浦区\", \"宝山区\", \"闵行区\", \"嘉定区\", \"松江区\", \"金山区\", \"青浦区\", \"南汇区\", \"奉贤区\", \"浦东新区\", \"崇明县\", \"其他\"] &#125; ] &#125;, &#123; \"name\": \"江苏\", \"city\": [ &#123; \"name\": \"南京\", \"area\": [\"玄武区\", \"白下区\", \"秦淮区\", \"建邺区\", \"鼓楼区\", \"下关区\", \"栖霞区\", \"雨花台区\", \"浦口区\", \"江宁区\", \"六合区\", \"溧水县\", \"高淳县\", \"其他\"] &#125;, &#123; \"name\": \"苏州\", \"area\": [\"金阊区\", \"平江区\", \"沧浪区\", \"虎丘区\", \"吴中区\", \"相城区\", \"常熟市\", \"张家港市\", \"昆山市\", \"吴江市\", \"太仓市\", \"其他\"] &#125;, &#123; \"name\": \"无锡\", \"area\": [\"崇安区\", \"南长区\", \"北塘区\", \"滨湖区\", \"锡山区\", \"惠山区\", \"江阴市\", \"宜兴市\", \"其他\"] &#125;, &#123; \"name\": \"常州\", \"area\": [\"钟楼区\", \"天宁区\", \"戚墅堰区\", \"新北区\", \"武进区\", \"金坛市\", \"溧阳市\", \"其他\"] &#125;, &#123; \"name\": \"镇江\", \"area\": [\"京口区\", \"润州区\", \"丹徒区\", \"丹阳市\", \"扬中市\", \"句容市\", \"其他\"] &#125;, &#123; \"name\": \"南通\", \"area\": [\"崇川区\", \"港闸区\", \"通州市\", \"如皋市\", \"海门市\", \"启东市\", \"海安县\", \"如东县\", \"其他\"] &#125;, &#123; \"name\": \"泰州\", \"area\": [\"海陵区\", \"高港区\", \"姜堰市\", \"泰兴市\", \"靖江市\", \"兴化市\", \"其他\"] &#125;, &#123; \"name\": \"扬州\", \"area\": [\"广陵区\", \"维扬区\", \"邗江区\", \"江都市\", \"仪征市\", \"高邮市\", \"宝应县\", \"其他\"] &#125;, &#123; \"name\": \"盐城\", \"area\": [\"亭湖区\", \"盐都区\", \"大丰市\", \"东台市\", \"建湖县\", \"射阳县\", \"阜宁县\", \"滨海县\", \"响水县\", \"其他\"] &#125;, &#123; \"name\": \"连云港\", \"area\": [\"新浦区\", \"海州区\", \"连云区\", \"东海县\", \"灌云县\", \"赣榆县\", \"灌南县\", \"其他\"] &#125;, &#123; \"name\": \"徐州\", \"area\": [\"云龙区\", \"鼓楼区\", \"九里区\", \"泉山区\", \"贾汪区\", \"邳州市\", \"新沂市\", \"铜山县\", \"睢宁县\", \"沛县\", \"丰县\", \"其他\"] &#125;, &#123; \"name\": \"淮安\", \"area\": [\"清河区\", \"清浦区\", \"楚州区\", \"淮阴区\", \"涟水县\", \"洪泽县\", \"金湖县\", \"盱眙县\", \"其他\"] &#125;, &#123; \"name\": \"宿迁\", \"area\": [\"宿城区\", \"宿豫区\", \"沭阳县\", \"泗阳县\", \"泗洪县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"浙江\", \"city\": [ &#123; \"name\": \"杭州\", \"area\": [\"拱墅区\", \"西湖区\", \"上城区\", \"下城区\", \"江干区\", \"滨江区\", \"余杭区\", \"萧山区\", \"建德市\", \"富阳市\", \"临安市\", \"桐庐县\", \"淳安县\", \"其他\"] &#125;, &#123; \"name\": \"宁波\", \"area\": [\"海曙区\", \"江东区\", \"江北区\", \"镇海区\", \"北仑区\", \"鄞州区\", \"余姚市\", \"慈溪市\", \"奉化市\", \"宁海县\", \"象山县\", \"其他\"] &#125;, &#123; \"name\": \"温州\", \"area\": [\"鹿城区\", \"龙湾区\", \"瓯海区\", \"瑞安市\", \"乐清市\", \"永嘉县\", \"洞头县\", \"平阳县\", \"苍南县\", \"文成县\", \"泰顺县\", \"其他\"] &#125;, &#123; \"name\": \"嘉兴\", \"area\": [\"秀城区\", \"秀洲区\", \"海宁市\", \"平湖市\", \"桐乡市\", \"嘉善县\", \"海盐县\", \"其他\"] &#125;, &#123; \"name\": \"湖州\", \"area\": [\"吴兴区\", \"南浔区\", \"长兴县\", \"德清县\", \"安吉县\", \"其他\"] &#125;, &#123; \"name\": \"绍兴\", \"area\": [\"越城区\", \"诸暨市\", \"上虞市\", \"嵊州市\", \"绍兴县\", \"新昌县\", \"其他\"] &#125;, &#123; \"name\": \"金华\", \"area\": [\"婺城区\", \"金东区\", \"兰溪市\", \"义乌市\", \"东阳市\", \"永康市\", \"武义县\", \"浦江县\", \"磐安县\", \"其他\"] &#125;, &#123; \"name\": \"衢州\", \"area\": [\"柯城区\", \"衢江区\", \"江山市\", \"龙游县\", \"常山县\", \"开化县\", \"其他\"] &#125;, &#123; \"name\": \"舟山\", \"area\": [\"定海区\", \"普陀区\", \"岱山县\", \"嵊泗县\", \"其他\"] &#125;, &#123; \"name\": \"台州\", \"area\": [\"椒江区\", \"黄岩区\", \"路桥区\", \"临海市\", \"温岭市\", \"玉环县\", \"天台县\", \"仙居县\", \"三门县\", \"其他\"] &#125;, &#123; \"name\": \"丽水\", \"area\": [\"莲都区\", \"龙泉市\", \"缙云县\", \"青田县\", \"云和县\", \"遂昌县\", \"松阳县\", \"庆元县\", \"景宁畲族自治县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"安徽\", \"city\": [ &#123; \"name\": \"合肥\", \"area\": [\"庐阳区\", \"瑶海区\", \"蜀山区\", \"包河区\", \"长丰县\", \"肥东县\", \"肥西县\", \"其他\"] &#125;, &#123; \"name\": \"芜湖\", \"area\": [\"镜湖区\", \"弋江区\", \"鸠江区\", \"三山区\", \"芜湖县\", \"南陵县\", \"繁昌县\", \"其他\"] &#125;, &#123; \"name\": \"蚌埠\", \"area\": [\"蚌山区\", \"龙子湖区\", \"禹会区\", \"淮上区\", \"怀远县\", \"固镇县\", \"五河县\", \"其他\"] &#125;, &#123; \"name\": \"淮南\", \"area\": [\"田家庵区\", \"大通区\", \"谢家集区\", \"八公山区\", \"潘集区\", \"凤台县\", \"其他\"] &#125;, &#123; \"name\": \"马鞍山\", \"area\": [\"雨山区\", \"花山区\", \"金家庄区\", \"当涂县\", \"其他\"] &#125;, &#123; \"name\": \"淮北\", \"area\": [\"相山区\", \"杜集区\", \"烈山区\", \"濉溪县\", \"其他\"] &#125;, &#123; \"name\": \"铜陵\", \"area\": [\"铜官山区\", \"狮子山区\", \"郊区\", \"铜陵县\", \"其他\"] &#125;, &#123; \"name\": \"安庆\", \"area\": [\"迎江区\", \"大观区\", \"宜秀区\", \"桐城市\", \"宿松县\", \"枞阳县\", \"太湖县\", \"怀宁县\", \"岳西县\", \"望江县\", \"潜山县\", \"其他\"] &#125;, &#123; \"name\": \"黄山\", \"area\": [\"屯溪区\", \"黄山区\", \"徽州区\", \"休宁县\", \"歙县\", \"祁门县\", \"黟县\", \"其他\"] &#125;, &#123; \"name\": \"滁州\", \"area\": [\"琅琊区\", \"南谯区\", \"天长市\", \"明光市\", \"全椒县\", \"来安县\", \"定远县\", \"凤阳县\", \"其他\"] &#125;, &#123; \"name\": \"阜阳\", \"area\": [\"颍州区\", \"颍东区\", \"颍泉区\", \"界首市\", \"临泉县\", \"颍上县\", \"阜南县\", \"太和县\", \"其他\"] &#125;, &#123; \"name\": \"宿州\", \"area\": [\"埇桥区\", \"萧县\", \"泗县\", \"砀山县\", \"灵璧县\", \"其他\"] &#125;, &#123; \"name\": \"巢湖\", \"area\": [\"居巢区\", \"含山县\", \"无为县\", \"庐江县\", \"和县\", \"其他\"] &#125;, &#123; \"name\": \"六安\", \"area\": [\"金安区\", \"裕安区\", \"寿县\", \"霍山县\", \"霍邱县\", \"舒城县\", \"金寨县\", \"其他\"] &#125;, &#123; \"name\": \"亳州\", \"area\": [\"谯城区\", \"利辛县\", \"涡阳县\", \"蒙城县\", \"其他\"] &#125;, &#123; \"name\": \"池州\", \"area\": [\"贵池区\", \"东至县\", \"石台县\", \"青阳县\", \"其他\"] &#125;, &#123; \"name\": \"宣城\", \"area\": [\"宣州区\", \"宁国市\", \"广德县\", \"郎溪县\", \"泾县\", \"旌德县\", \"绩溪县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"福建\", \"city\": [ &#123; \"name\": \"福州\", \"area\": [\"鼓楼区\", \"台江区\", \"仓山区\", \"马尾区\", \"晋安区\", \"福清市\", \"长乐市\", \"闽侯县\", \"闽清县\", \"永泰县\", \"连江县\", \"罗源县\", \"平潭县\", \"其他\"] &#125;, &#123; \"name\": \"厦门\", \"area\": [\"思明区\", \"海沧区\", \"湖里区\", \"集美区\", \"同安区\", \"翔安区\", \"其他\"] &#125;, &#123; \"name\": \"莆田\", \"area\": [\"城厢区\", \"涵江区\", \"荔城区\", \"秀屿区\", \"仙游县\", \"其他\"] &#125;, &#123; \"name\": \"三明\", \"area\": [\"梅列区\", \"三元区\", \"永安市\", \"明溪县\", \"将乐县\", \"大田县\", \"宁化县\", \"建宁县\", \"沙县\", \"尤溪县\", \"清流县\", \"泰宁县\", \"其他\"] &#125;, &#123; \"name\": \"泉州\", \"area\": [\"鲤城区\", \"丰泽区\", \"洛江区\", \"泉港区\", \"石狮市\", \"晋江市\", \"南安市\", \"惠安县\", \"永春县\", \"安溪县\", \"德化县\", \"金门县\", \"其他\"] &#125;, &#123; \"name\": \"漳州\", \"area\": [\"芗城区\", \"龙文区\", \"龙海市\", \"平和县\", \"南靖县\", \"诏安县\", \"漳浦县\", \"华安县\", \"东山县\", \"长泰县\", \"云霄县\", \"其他\"] &#125;, &#123; \"name\": \"南平\", \"area\": [\"延平区\", \"建瓯市\", \"邵武市\", \"武夷山市\", \"建阳市\", \"松溪县\", \"光泽县\", \"顺昌县\", \"浦城县\", \"政和县\", \"其他\"] &#125;, &#123; \"name\": \"龙岩\", \"area\": [\"新罗区\", \"漳平市\", \"长汀县\", \"武平县\", \"上杭县\", \"永定县\", \"连城县\", \"其他\"] &#125;, &#123; \"name\": \"宁德\", \"area\": [\"蕉城区\", \"福安市\", \"福鼎市\", \"寿宁县\", \"霞浦县\", \"柘荣县\", \"屏南县\", \"古田县\", \"周宁县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"江西\", \"city\": [ &#123; \"name\": \"南昌\", \"area\": [\"东湖区\", \"西湖区\", \"青云谱区\", \"湾里区\", \"青山湖区\", \"新建县\", \"南昌县\", \"进贤县\", \"安义县\", \"其他\"] &#125;, &#123; \"name\": \"景德镇\", \"area\": [\"珠山区\", \"昌江区\", \"乐平市\", \"浮梁县\", \"其他\"] &#125;, &#123; \"name\": \"萍乡\", \"area\": [\"安源区\", \"湘东区\", \"莲花县\", \"上栗县\", \"芦溪县\", \"其他\"] &#125;, &#123; \"name\": \"九江\", \"area\": [\"浔阳区\", \"庐山区\", \"瑞昌市\", \"九江县\", \"星子县\", \"武宁县\", \"彭泽县\", \"永修县\", \"修水县\", \"湖口县\", \"德安县\", \"都昌县\", \"其他\"] &#125;, &#123; \"name\": \"新余\", \"area\": [\"渝水区\", \"分宜县\", \"其他\"] &#125;, &#123; \"name\": \"鹰潭\", \"area\": [\"月湖区\", \"贵溪市\", \"余江县\", \"其他\"] &#125;, &#123; \"name\": \"赣州\", \"area\": [\"章贡区\", \"瑞金市\", \"南康市\", \"石城县\", \"安远县\", \"赣县\", \"宁都县\", \"寻乌县\", \"兴国县\", \"定南县\", \"上犹县\", \"于都县\", \"龙南县\", \"崇义县\", \"信丰县\", \"全南县\", \"大余县\", \"会昌县\", \"其他\"] &#125;, &#123; \"name\": \"吉安\", \"area\": [\"吉州区\", \"青原区\", \"井冈山市\", \"吉安县\", \"永丰县\", \"永新县\", \"新干县\", \"泰和县\", \"峡江县\", \"遂川县\", \"安福县\", \"吉水县\", \"万安县\", \"其他\"] &#125;, &#123; \"name\": \"宜春\", \"area\": [\"袁州区\", \"丰城市\", \"樟树市\", \"高安市\", \"铜鼓县\", \"靖安县\", \"宜丰县\", \"奉新县\", \"万载县\", \"上高县\", \"其他\"] &#125;, &#123; \"name\": \"抚州\", \"area\": [\"临川区\", \"南丰县\", \"乐安县\", \"金溪县\", \"南城县\", \"东乡县\", \"资溪县\", \"宜黄县\", \"广昌县\", \"黎川县\", \"崇仁县\", \"其他\"] &#125;, &#123; \"name\": \"上饶\", \"area\": [\"信州区\", \"德兴市\", \"上饶县\", \"广丰县\", \"鄱阳县\", \"婺源县\", \"铅山县\", \"余干县\", \"横峰县\", \"弋阳县\", \"玉山县\", \"万年县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"山东\", \"city\": [ &#123; \"name\": \"济南\", \"area\": [\"市中区\", \"历下区\", \"天桥区\", \"槐荫区\", \"历城区\", \"长清区\", \"章丘市\", \"平阴县\", \"济阳县\", \"商河县\", \"其他\"] &#125;, &#123; \"name\": \"青岛\", \"area\": [\"市南区\", \"市北区\", \"城阳区\", \"四方区\", \"李沧区\", \"黄岛区\", \"崂山区\", \"胶南市\", \"胶州市\", \"平度市\", \"莱西市\", \"即墨市\", \"其他\"] &#125;, &#123; \"name\": \"淄博\", \"area\": [\"张店区\", \"临淄区\", \"淄川区\", \"博山区\", \"周村区\", \"桓台县\", \"高青县\", \"沂源县\", \"其他\"] &#125;, &#123; \"name\": \"枣庄\", \"area\": [\"市中区\", \"山亭区\", \"峄城区\", \"台儿庄区\", \"薛城区\", \"滕州市\", \"其他\"] &#125;, &#123; \"name\": \"东营\", \"area\": [\"东营区\", \"河口区\", \"垦利县\", \"广饶县\", \"利津县\", \"其他\"] &#125;, &#123; \"name\": \"烟台\", \"area\": [\"芝罘区\", \"福山区\", \"牟平区\", \"莱山区\", \"龙口市\", \"莱阳市\", \"莱州市\", \"招远市\", \"蓬莱市\", \"栖霞市\", \"海阳市\", \"长岛县\", \"其他\"] &#125;, &#123; \"name\": \"潍坊\", \"area\": [\"潍城区\", \"寒亭区\", \"坊子区\", \"奎文区\", \"青州市\", \"诸城市\", \"寿光市\", \"安丘市\", \"高密市\", \"昌邑市\", \"昌乐县\", \"临朐县\", \"其他\"] &#125;, &#123; \"name\": \"济宁\", \"area\": [\"市中区\", \"任城区\", \"曲阜市\", \"兖州市\", \"邹城市\", \"鱼台县\", \"金乡县\", \"嘉祥县\", \"微山县\", \"汶上县\", \"泗水县\", \"梁山县\", \"其他\"] &#125;, &#123; \"name\": \"泰安\", \"area\": [\"泰山区\", \"岱岳区\", \"新泰市\", \"肥城市\", \"宁阳县\", \"东平县\", \"其他\"] &#125;, &#123; \"name\": \"威海\", \"area\": [\"环翠区\", \"乳山市\", \"文登市\", \"荣成市\", \"其他\"] &#125;, &#123; \"name\": \"日照\", \"area\": [\"东港区\", \"岚山区\", \"五莲县\", \"莒县\", \"其他\"] &#125;, &#123; \"name\": \"莱芜\", \"area\": [\"莱城区\", \"钢城区\", \"其他\"] &#125;, &#123; \"name\": \"临沂\", \"area\": [\"兰山区\", \"罗庄区\", \"河东区\", \"沂南县\", \"郯城县\", \"沂水县\", \"苍山县\", \"费县\", \"平邑县\", \"莒南县\", \"蒙阴县\", \"临沭县\", \"其他\"] &#125;, &#123; \"name\": \"德州\", \"area\": [\"德城区\", \"乐陵市\", \"禹城市\", \"陵县\", \"宁津县\", \"齐河县\", \"武城县\", \"庆云县\", \"平原县\", \"夏津县\", \"临邑县\", \"其他\"] &#125;, &#123; \"name\": \"聊城\", \"area\": [\"东昌府区\", \"临清市\", \"高唐县\", \"阳谷县\", \"茌平县\", \"莘县\", \"东阿县\", \"冠县\", \"其他\"] &#125;, &#123; \"name\": \"滨州\", \"area\": [\"滨城区\", \"邹平县\", \"沾化县\", \"惠民县\", \"博兴县\", \"阳信县\", \"无棣县\", \"其他\"] &#125;, &#123; \"name\": \"菏泽\", \"area\": [\"牡丹区\", \"鄄城县\", \"单县\", \"郓城县\", \"曹县\", \"定陶县\", \"巨野县\", \"东明县\", \"成武县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"河南\", \"city\": [ &#123; \"name\": \"郑州\", \"area\": [\"中原区\", \"金水区\", \"二七区\", \"管城回族区\", \"上街区\", \"惠济区\", \"巩义市\", \"新郑市\", \"新密市\", \"登封市\", \"荥阳市\", \"中牟县\", \"其他\"] &#125;, &#123; \"name\": \"开封\", \"area\": [\"鼓楼区\", \"龙亭区\", \"顺河回族区\", \"禹王台区\", \"金明区\", \"开封县\", \"尉氏县\", \"兰考县\", \"杞县\", \"通许县\", \"其他\"] &#125;, &#123; \"name\": \"洛阳\", \"area\": [\"西工区\", \"老城区\", \"涧西区\", \"瀍河回族区\", \"洛龙区\", \"吉利区\", \"偃师市\", \"孟津县\", \"汝阳县\", \"伊川县\", \"洛宁县\", \"嵩县\", \"宜阳县\", \"新安县\", \"栾川县\", \"其他\"] &#125;, &#123; \"name\": \"平顶山\", \"area\": [\"新华区\", \"卫东区\", \"湛河区\", \"石龙区\", \"汝州市\", \"舞钢市\", \"宝丰县\", \"叶县\", \"郏县\", \"鲁山县\", \"其他\"] &#125;, &#123; \"name\": \"安阳\", \"area\": [\"北关区\", \"文峰区\", \"殷都区\", \"龙安区\", \"林州市\", \"安阳县\", \"滑县\", \"内黄县\", \"汤阴县\", \"其他\"] &#125;, &#123; \"name\": \"鹤壁\", \"area\": [\"淇滨区\", \"山城区\", \"鹤山区\", \"浚县\", \"淇县\", \"其他\"] &#125;, &#123; \"name\": \"新乡\", \"area\": [\"卫滨区\", \"红旗区\", \"凤泉区\", \"牧野区\", \"卫辉市\", \"辉县市\", \"新乡县\", \"获嘉县\", \"原阳县\", \"长垣县\", \"封丘县\", \"延津县\", \"其他\"] &#125;, &#123; \"name\": \"焦作\", \"area\": [\"解放区\", \"中站区\", \"马村区\", \"山阳区\", \"沁阳市\", \"孟州市\", \"修武县\", \"温县\", \"武陟县\", \"博爱县\", \"其他\"] &#125;, &#123; \"name\": \"濮阳\", \"area\": [\"华龙区\", \"濮阳县\", \"南乐县\", \"台前县\", \"清丰县\", \"范县\", \"其他\"] &#125;, &#123; \"name\": \"许昌\", \"area\": [\"魏都区\", \"禹州市\", \"长葛市\", \"许昌县\", \"鄢陵县\", \"襄城县\", \"其他\"] &#125;, &#123; \"name\": \"漯河\", \"area\": [\"源汇区\", \"郾城区\", \"召陵区\", \"临颍县\", \"舞阳县\", \"其他\"] &#125;, &#123; \"name\": \"三门峡\", \"area\": [\"湖滨区\", \"义马市\", \"灵宝市\", \"渑池县\", \"卢氏县\", \"陕县\", \"其他\"] &#125;, &#123; \"name\": \"南阳\", \"area\": [\"卧龙区\", \"宛城区\", \"邓州市\", \"桐柏县\", \"方城县\", \"淅川县\", \"镇平县\", \"唐河县\", \"南召县\", \"内乡县\", \"新野县\", \"社旗县\", \"西峡县\", \"其他\"] &#125;, &#123; \"name\": \"商丘\", \"area\": [\"梁园区\", \"睢阳区\", \"永城市\", \"宁陵县\", \"虞城县\", \"民权县\", \"夏邑县\", \"柘城县\", \"睢县\", \"其他\"] &#125;, &#123; \"name\": \"信阳\", \"area\": [\"浉河区\", \"平桥区\", \"潢川县\", \"淮滨县\", \"息县\", \"新县\", \"商城县\", \"固始县\", \"罗山县\", \"光山县\", \"其他\"] &#125;, &#123; \"name\": \"周口\", \"area\": [\"川汇区\", \"项城市\", \"商水县\", \"淮阳县\", \"太康县\", \"鹿邑县\", \"西华县\", \"扶沟县\", \"沈丘县\", \"郸城县\", \"其他\"] &#125;, &#123; \"name\": \"驻马店\", \"area\": [\"驿城区\", \"确山县\", \"新蔡县\", \"上蔡县\", \"西平县\", \"泌阳县\", \"平舆县\", \"汝南县\", \"遂平县\", \"正阳县\", \"其他\"] &#125;, &#123; \"name\": \"焦作\", \"area\": [\"济源市\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"湖北\", \"city\": [ &#123; \"name\": \"武汉\", \"area\": [\"江岸区\", \"武昌区\", \"江汉区\", \"硚口区\", \"汉阳区\", \"青山区\", \"洪山区\", \"东西湖区\", \"汉南区\", \"蔡甸区\", \"江夏区\", \"黄陂区\", \"新洲区\", \"其他\"] &#125;, &#123; \"name\": \"黄石\", \"area\": [\"黄石港区\", \"西塞山区\", \"下陆区\", \"铁山区\", \"大冶市\", \"阳新县\", \"其他\"] &#125;, &#123; \"name\": \"十堰\", \"area\": [\"张湾区\", \"茅箭区\", \"丹江口市\", \"郧县\", \"竹山县\", \"房县\", \"郧西县\", \"竹溪县\", \"其他\"] &#125;, &#123; \"name\": \"荆州\", \"area\": [\"沙市区\", \"荆州区\", \"洪湖市\", \"石首市\", \"松滋市\", \"监利县\", \"公安县\", \"江陵县\", \"其他\"] &#125;, &#123; \"name\": \"宜昌\", \"area\": [\"西陵区\", \"伍家岗区\", \"点军区\", \"猇亭区\", \"夷陵区\", \"宜都市\", \"当阳市\", \"枝江市\", \"秭归县\", \"远安县\", \"兴山县\", \"五峰土家族自治县\", \"长阳土家族自治县\", \"其他\"] &#125;, &#123; \"name\": \"襄樊\", \"area\": [\"襄城区\", \"樊城区\", \"襄阳区\", \"老河口市\", \"枣阳市\", \"宜城市\", \"南漳县\", \"谷城县\", \"保康县\", \"其他\"] &#125;, &#123; \"name\": \"鄂州\", \"area\": [\"鄂城区\", \"华容区\", \"梁子湖区\", \"其他\"] &#125;, &#123; \"name\": \"荆门\", \"area\": [\"东宝区\", \"掇刀区\", \"钟祥市\", \"京山县\", \"沙洋县\", \"其他\"] &#125;, &#123; \"name\": \"孝感\", \"area\": [\"孝南区\", \"应城市\", \"安陆市\", \"汉川市\", \"云梦县\", \"大悟县\", \"孝昌县\", \"其他\"] &#125;, &#123; \"name\": \"黄冈\", \"area\": [\"黄州区\", \"麻城市\", \"武穴市\", \"红安县\", \"罗田县\", \"浠水县\", \"蕲春县\", \"黄梅县\", \"英山县\", \"团风县\", \"其他\"] &#125;, &#123; \"name\": \"咸宁\", \"area\": [\"咸安区\", \"赤壁市\", \"嘉鱼县\", \"通山县\", \"崇阳县\", \"通城县\", \"其他\"] &#125;, &#123; \"name\": \"随州\", \"area\": [\"曾都区\", \"广水市\", \"其他\"] &#125;, &#123; \"name\": \"恩施土家族苗族自治州\", \"area\": [\"恩施市\", \"利川市\", \"建始县\", \"来凤县\", \"巴东县\", \"鹤峰县\", \"宣恩县\", \"咸丰县\", \"其他\"] &#125;, &#123; \"name\": \"仙桃\", \"area\": [\"仙桃\"] &#125;, &#123; \"name\": \"天门\", \"area\": [\"天门\"] &#125;, &#123; \"name\": \"潜江\", \"area\": [\"潜江\"] &#125;, &#123; \"name\": \"神农架林区\", \"area\": [\"神农架林区\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"湖南\", \"city\": [ &#123; \"name\": \"长沙\", \"area\": [\"岳麓区\", \"芙蓉区\", \"天心区\", \"开福区\", \"雨花区\", \"浏阳市\", \"长沙县\", \"望城县\", \"宁乡县\", \"其他\"] &#125;, &#123; \"name\": \"株洲\", \"area\": [\"天元区\", \"荷塘区\", \"芦淞区\", \"石峰区\", \"醴陵市\", \"株洲县\", \"炎陵县\", \"茶陵县\", \"攸县\", \"其他\"] &#125;, &#123; \"name\": \"湘潭\", \"area\": [\"岳塘区\", \"雨湖区\", \"湘乡市\", \"韶山市\", \"湘潭县\", \"其他\"] &#125;, &#123; \"name\": \"衡阳\", \"area\": [\"雁峰区\", \"珠晖区\", \"石鼓区\", \"蒸湘区\", \"南岳区\", \"耒阳市\", \"常宁市\", \"衡阳县\", \"衡东县\", \"衡山县\", \"衡南县\", \"祁东县\", \"其他\"] &#125;, &#123; \"name\": \"邵阳\", \"area\": [\"双清区\", \"大祥区\", \"北塔区\", \"武冈市\", \"邵东县\", \"洞口县\", \"新邵县\", \"绥宁县\", \"新宁县\", \"邵阳县\", \"隆回县\", \"城步苗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"岳阳\", \"area\": [\"岳阳楼区\", \"云溪区\", \"君山区\", \"临湘市\", \"汨罗市\", \"岳阳县\", \"湘阴县\", \"平江县\", \"华容县\", \"其他\"] &#125;, &#123; \"name\": \"常德\", \"area\": [\"武陵区\", \"鼎城区\", \"津市市\", \"澧县\", \"临澧县\", \"桃源县\", \"汉寿县\", \"安乡县\", \"石门县\", \"其他\"] &#125;, &#123; \"name\": \"张家界\", \"area\": [\"永定区\", \"武陵源区\", \"慈利县\", \"桑植县\", \"其他\"] &#125;, &#123; \"name\": \"益阳\", \"area\": [\"赫山区\", \"资阳区\", \"沅江市\", \"桃江县\", \"南县\", \"安化县\", \"其他\"] &#125;, &#123; \"name\": \"郴州\", \"area\": [\"北湖区\", \"苏仙区\", \"资兴市\", \"宜章县\", \"汝城县\", \"安仁县\", \"嘉禾县\", \"临武县\", \"桂东县\", \"永兴县\", \"桂阳县\", \"其他\"] &#125;, &#123; \"name\": \"永州\", \"area\": [\"冷水滩区\", \"零陵区\", \"祁阳县\", \"蓝山县\", \"宁远县\", \"新田县\", \"东安县\", \"江永县\", \"道县\", \"双牌县\", \"江华瑶族自治县\", \"其他\"] &#125;, &#123; \"name\": \"怀化\", \"area\": [\"鹤城区\", \"洪江市\", \"会同县\", \"沅陵县\", \"辰溪县\", \"溆浦县\", \"中方县\", \"新晃侗族自治县\", \"芷江侗族自治县\", \"通道侗族自治县\", \"靖州苗族侗族自治县\", \"麻阳苗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"娄底\", \"area\": [\"娄星区\", \"冷水江市\", \"涟源市\", \"新化县\", \"双峰县\", \"其他\"] &#125;, &#123; \"name\": \"湘西土家族苗族自治州\", \"area\": [\"吉首市\", \"古丈县\", \"龙山县\", \"永顺县\", \"凤凰县\", \"泸溪县\", \"保靖县\", \"花垣县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"广东\", \"city\": [ &#123; \"name\": \"广州\", \"area\": [\"越秀区\", \"荔湾区\", \"海珠区\", \"天河区\", \"白云区\", \"黄埔区\", \"番禺区\", \"花都区\", \"南沙区\", \"萝岗区\", \"增城市\", \"从化市\", \"其他\"] &#125;, &#123; \"name\": \"深圳\", \"area\": [\"福田区\", \"罗湖区\", \"南山区\", \"宝安区\", \"龙岗区\", \"盐田区\", \"其他\"] &#125;, &#123; \"name\": \"东莞\", \"area\": [\"莞城\", \"常平\", \"塘厦\", \"塘厦\", \"塘厦\", \"其他\"] &#125;, &#123; \"name\": \"中山\", \"area\": [\"中山\"] &#125;, &#123; \"name\": \"潮州\", \"area\": [\"湘桥区\", \"潮安县\", \"饶平县\", \"其他\"] &#125;, &#123; \"name\": \"揭阳\", \"area\": [\"榕城区\", \"揭东县\", \"揭西县\", \"惠来县\", \"普宁市\", \"其他\"] &#125;, &#123; \"name\": \"云浮\", \"area\": [\"云城区\", \"新兴县\", \"郁南县\", \"云安县\", \"罗定市\", \"其他\"] &#125;, &#123; \"name\": \"珠海\", \"area\": [\"香洲区\", \"斗门区\", \"金湾区\", \"其他\"] &#125;, &#123; \"name\": \"汕头\", \"area\": [\"金平区\", \"濠江区\", \"龙湖区\", \"潮阳区\", \"潮南区\", \"澄海区\", \"南澳县\", \"其他\"] &#125;, &#123; \"name\": \"韶关\", \"area\": [\"浈江区\", \"武江区\", \"曲江区\", \"乐昌市\", \"南雄市\", \"始兴县\", \"仁化县\", \"翁源县\", \"新丰县\", \"乳源瑶族自治县\", \"其他\"] &#125;, &#123; \"name\": \"佛山\", \"area\": [\"禅城区\", \"南海区\", \"顺德区\", \"三水区\", \"高明区\", \"其他\"] &#125;, &#123; \"name\": \"江门\", \"area\": [\"蓬江区\", \"江海区\", \"新会区\", \"恩平市\", \"台山市\", \"开平市\", \"鹤山市\", \"其他\"] &#125;, &#123; \"name\": \"湛江\", \"area\": [\"赤坎区\", \"霞山区\", \"坡头区\", \"麻章区\", \"吴川市\", \"廉江市\", \"雷州市\", \"遂溪县\", \"徐闻县\", \"其他\"] &#125;, &#123; \"name\": \"茂名\", \"area\": [\"茂南区\", \"茂港区\", \"化州市\", \"信宜市\", \"高州市\", \"电白县\", \"其他\"] &#125;, &#123; \"name\": \"肇庆\", \"area\": [\"端州区\", \"鼎湖区\", \"高要市\", \"四会市\", \"广宁县\", \"怀集县\", \"封开县\", \"德庆县\", \"其他\"] &#125;, &#123; \"name\": \"惠州\", \"area\": [\"惠城区\", \"惠阳区\", \"博罗县\", \"惠东县\", \"龙门县\", \"其他\"] &#125;, &#123; \"name\": \"梅州\", \"area\": [\"梅江区\", \"兴宁市\", \"梅县\", \"大埔县\", \"丰顺县\", \"五华县\", \"平远县\", \"蕉岭县\", \"其他\"] &#125;, &#123; \"name\": \"汕尾\", \"area\": [\"城区\", \"陆丰市\", \"海丰县\", \"陆河县\", \"其他\"] &#125;, &#123; \"name\": \"河源\", \"area\": [\"源城区\", \"紫金县\", \"龙川县\", \"连平县\", \"和平县\", \"东源县\", \"其他\"] &#125;, &#123; \"name\": \"阳江\", \"area\": [\"江城区\", \"阳春市\", \"阳西县\", \"阳东县\", \"其他\"] &#125;, &#123; \"name\": \"清远\", \"area\": [\"清城区\", \"英德市\", \"连州市\", \"佛冈县\", \"阳山县\", \"清新县\", \"连山壮族瑶族自治县\", \"连南瑶族自治县\", \"其他\"] &#125; ] &#125;, &#123; \"name\": \"广西\", \"city\": [ &#123; \"name\": \"南宁\", \"area\": [\"青秀区\", \"兴宁区\", \"西乡塘区\", \"良庆区\", \"江南区\", \"邕宁区\", \"武鸣县\", \"隆安县\", \"马山县\", \"上林县\", \"宾阳县\", \"横县\", \"其他\"] &#125;, &#123; \"name\": \"柳州\", \"area\": [\"城中区\", \"鱼峰区\", \"柳北区\", \"柳南区\", \"柳江县\", \"柳城县\", \"鹿寨县\", \"融安县\", \"融水苗族自治县\", \"三江侗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"桂林\", \"area\": [\"象山区\", \"秀峰区\", \"叠彩区\", \"七星区\", \"雁山区\", \"阳朔县\", \"临桂县\", \"灵川县\", \"全州县\", \"平乐县\", \"兴安县\", \"灌阳县\", \"荔浦县\", \"资源县\", \"永福县\", \"龙胜各族自治县\", \"恭城瑶族自治县\", \"其他\"] &#125;, &#123; \"name\": \"梧州\", \"area\": [\"万秀区\", \"蝶山区\", \"长洲区\", \"岑溪市\", \"苍梧县\", \"藤县\", \"蒙山县\", \"其他\"] &#125;, &#123; \"name\": \"北海\", \"area\": [\"海城区\", \"银海区\", \"铁山港区\", \"合浦县\", \"其他\"] &#125;, &#123; \"name\": \"防城港\", \"area\": [\"港口区\", \"防城区\", \"东兴市\", \"上思县\", \"其他\"] &#125;, &#123; \"name\": \"钦州\", \"area\": [\"钦南区\", \"钦北区\", \"灵山县\", \"浦北县\", \"其他\"] &#125;, &#123; \"name\": \"贵港\", \"area\": [\"港北区\", \"港南区\", \"覃塘区\", \"桂平市\", \"平南县\", \"其他\"] &#125;, &#123; \"name\": \"玉林\", \"area\": [\"玉州区\", \"北流市\", \"容县\", \"陆川县\", \"博白县\", \"兴业县\", \"其他\"] &#125;, &#123; \"name\": \"百色\", \"area\": [\"右江区\", \"凌云县\", \"平果县\", \"西林县\", \"乐业县\", \"德保县\", \"田林县\", \"田阳县\", \"靖西县\", \"田东县\", \"那坡县\", \"隆林各族自治县\", \"其他\"] &#125;, &#123; \"name\": \"贺州\", \"area\": [\"八步区\", \"钟山县\", \"昭平县\", \"富川瑶族自治县\", \"其他\"] &#125;, &#123; \"name\": \"河池\", \"area\": [\"金城江区\", \"宜州市\", \"天峨县\", \"凤山县\", \"南丹县\", \"东兰县\", \"都安瑶族自治县\", \"罗城仫佬族自治县\", \"巴马瑶族自治县\", \"环江毛南族自治县\", \"大化瑶族自治县\", \"其他\"] &#125;, &#123; \"name\": \"来宾\", \"area\": [\"兴宾区\", \"合山市\", \"象州县\", \"武宣县\", \"忻城县\", \"金秀瑶族自治县\", \"其他\"] &#125;, &#123; \"name\": \"崇左\", \"area\": [\"江州区\", \"凭祥市\", \"宁明县\", \"扶绥县\", \"龙州县\", \"大新县\", \"天等县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"海南\", \"city\": [ &#123; \"name\": \"海口\", \"area\": [\"龙华区\", \"秀英区\", \"琼山区\", \"美兰区\", \"其他\"] &#125;, &#123; \"name\": \"三亚\", \"area\": [\"三亚市\", \"其他\"] &#125;, &#123; \"name\": \"五指山\", \"area\": [\"五指山\"] &#125;, &#123; \"name\": \"琼海\", \"area\": [\"琼海\"] &#125;, &#123; \"name\": \"儋州\", \"area\": [\"儋州\"] &#125;, &#123; \"name\": \"文昌\", \"area\": [\"文昌\"] &#125;, &#123; \"name\": \"万宁\", \"area\": [\"万宁\"] &#125;, &#123; \"name\": \"东方\", \"area\": [\"东方\"] &#125;, &#123; \"name\": \"澄迈县\", \"area\": [\"澄迈县\"] &#125;, &#123; \"name\": \"定安县\", \"area\": [\"定安县\"] &#125;, &#123; \"name\": \"屯昌县\", \"area\": [\"屯昌县\"] &#125;, &#123; \"name\": \"临高县\", \"area\": [\"临高县\"] &#125;, &#123; \"name\": \"白沙黎族自治县\", \"area\": [\"白沙黎族自治县\"] &#125;, &#123; \"name\": \"昌江黎族自治县\", \"area\": [\"昌江黎族自治县\"] &#125;, &#123; \"name\": \"乐东黎族自治县\", \"area\": [\"乐东黎族自治县\"] &#125;, &#123; \"name\": \"陵水黎族自治县\", \"area\": [\"陵水黎族自治县\"] &#125;, &#123; \"name\": \"保亭黎族苗族自治县\", \"area\": [\"保亭黎族苗族自治县\"] &#125;, &#123; \"name\": \"琼中黎族苗族自治县\", \"area\": [\"琼中黎族苗族自治县\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"重庆\", \"city\": [ &#123; \"name\": \"重庆\", \"area\": [\"渝中区\", \"大渡口区\", \"江北区\", \"南岸区\", \"北碚区\", \"渝北区\", \"巴南区\", \"长寿区\", \"双桥区\", \"沙坪坝区\", \"万盛区\", \"万州区\", \"涪陵区\", \"黔江区\", \"永川区\", \"合川区\", \"江津区\", \"九龙坡区\", \"南川区\", \"綦江县\", \"潼南县\", \"荣昌县\", \"璧山县\", \"大足县\", \"铜梁县\", \"梁平县\", \"开县\", \"忠县\", \"城口县\", \"垫江县\", \"武隆县\", \"丰都县\", \"奉节县\", \"云阳县\", \"巫溪县\", \"巫山县\", \"石柱土家族自治县\", \"秀山土家族苗族自治县\", \"酉阳土家族苗族自治县\", \"彭水苗族土家族自治县\", \"其他\"] &#125; ] &#125;, &#123; \"name\": \"四川\", \"city\": [ &#123; \"name\": \"成都\", \"area\": [\"青羊区\", \"锦江区\", \"金牛区\", \"武侯区\", \"成华区\", \"龙泉驿区\", \"青白江区\", \"新都区\", \"温江区\", \"都江堰市\", \"彭州市\", \"邛崃市\", \"崇州市\", \"金堂县\", \"郫县\", \"新津县\", \"双流县\", \"蒲江县\", \"大邑县\", \"其他\"] &#125;, &#123; \"name\": \"自贡\", \"area\": [\"大安区\", \"自流井区\", \"贡井区\", \"沿滩区\", \"荣县\", \"富顺县\", \"其他\"] &#125;, &#123; \"name\": \"攀枝花\", \"area\": [\"仁和区\", \"米易县\", \"盐边县\", \"东区\", \"西区\", \"其他\"] &#125;, &#123; \"name\": \"泸州\", \"area\": [\"江阳区\", \"纳溪区\", \"龙马潭区\", \"泸县\", \"合江县\", \"叙永县\", \"古蔺县\", \"其他\"] &#125;, &#123; \"name\": \"德阳\", \"area\": [\"旌阳区\", \"广汉市\", \"什邡市\", \"绵竹市\", \"罗江县\", \"中江县\", \"其他\"] &#125;, &#123; \"name\": \"绵阳\", \"area\": [\"涪城区\", \"游仙区\", \"江油市\", \"盐亭县\", \"三台县\", \"平武县\", \"安县\", \"梓潼县\", \"北川羌族自治县\", \"其他\"] &#125;, &#123; \"name\": \"广元\", \"area\": [\"元坝区\", \"朝天区\", \"青川县\", \"旺苍县\", \"剑阁县\", \"苍溪县\", \"市中区\", \"其他\"] &#125;, &#123; \"name\": \"遂宁\", \"area\": [\"船山区\", \"安居区\", \"射洪县\", \"蓬溪县\", \"大英县\", \"其他\"] &#125;, &#123; \"name\": \"内江\", \"area\": [\"市中区\", \"东兴区\", \"资中县\", \"隆昌县\", \"威远县\", \"其他\"] &#125;, &#123; \"name\": \"乐山\", \"area\": [\"市中区\", \"五通桥区\", \"沙湾区\", \"金口河区\", \"峨眉山市\", \"夹江县\", \"井研县\", \"犍为县\", \"沐川县\", \"马边彝族自治县\", \"峨边彝族自治县\", \"其他\"] &#125;, &#123; \"name\": \"南充\", \"area\": [\"顺庆区\", \"高坪区\", \"嘉陵区\", \"阆中市\", \"营山县\", \"蓬安县\", \"仪陇县\", \"南部县\", \"西充县\", \"其他\"] &#125;, &#123; \"name\": \"眉山\", \"area\": [\"东坡区\", \"仁寿县\", \"彭山县\", \"洪雅县\", \"丹棱县\", \"青神县\", \"其他\"] &#125;, &#123; \"name\": \"宜宾\", \"area\": [\"翠屏区\", \"宜宾县\", \"兴文县\", \"南溪县\", \"珙县\", \"长宁县\", \"高县\", \"江安县\", \"筠连县\", \"屏山县\", \"其他\"] &#125;, &#123; \"name\": \"广安\", \"area\": [\"广安区\", \"华蓥市\", \"岳池县\", \"邻水县\", \"武胜县\", \"其他\"] &#125;, &#123; \"name\": \"达州\", \"area\": [\"通川区\", \"万源市\", \"达县\", \"渠县\", \"宣汉县\", \"开江县\", \"大竹县\", \"其他\"] &#125;, &#123; \"name\": \"雅安\", \"area\": [\"雨城区\", \"芦山县\", \"石棉县\", \"名山县\", \"天全县\", \"荥经县\", \"宝兴县\", \"汉源县\", \"其他\"] &#125;, &#123; \"name\": \"巴中\", \"area\": [\"巴州区\", \"南江县\", \"平昌县\", \"通江县\", \"其他\"] &#125;, &#123; \"name\": \"资阳\", \"area\": [\"雁江区\", \"简阳市\", \"安岳县\", \"乐至县\", \"其他\"] &#125;, &#123; \"name\": \"阿坝藏族羌族自治州\", \"area\": [\"马尔康县\", \"九寨沟县\", \"红原县\", \"汶川县\", \"阿坝县\", \"理县\", \"若尔盖县\", \"小金县\", \"黑水县\", \"金川县\", \"松潘县\", \"壤塘县\", \"茂县\", \"其他\"] &#125;, &#123; \"name\": \"甘孜藏族自治州\", \"area\": [\"康定县\", \"丹巴县\", \"炉霍县\", \"九龙县\", \"甘孜县\", \"雅江县\", \"新龙县\", \"道孚县\", \"白玉县\", \"理塘县\", \"德格县\", \"乡城县\", \"石渠县\", \"稻城县\", \"色达县\", \"巴塘县\", \"泸定县\", \"得荣县\", \"其他\"] &#125;, &#123; \"name\": \"凉山彝族自治州\", \"area\": [\"西昌市\", \"美姑县\", \"昭觉县\", \"金阳县\", \"甘洛县\", \"布拖县\", \"雷波县\", \"普格县\", \"宁南县\", \"喜德县\", \"会东县\", \"越西县\", \"会理县\", \"盐源县\", \"德昌县\", \"冕宁县\", \"木里藏族自治县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"贵州\", \"city\": [ &#123; \"name\": \"贵阳\", \"area\": [\"南明区\", \"云岩区\", \"花溪区\", \"乌当区\", \"白云区\", \"小河区\", \"清镇市\", \"开阳县\", \"修文县\", \"息烽县\", \"其他\"] &#125;, &#123; \"name\": \"六盘水\", \"area\": [\"钟山区\", \"水城县\", \"盘县\", \"六枝特区\", \"其他\"] &#125;, &#123; \"name\": \"遵义\", \"area\": [\"红花岗区\", \"汇川区\", \"赤水市\", \"仁怀市\", \"遵义县\", \"绥阳县\", \"桐梓县\", \"习水县\", \"凤冈县\", \"正安县\", \"余庆县\", \"湄潭县\", \"道真仡佬族苗族自治县\", \"务川仡佬族苗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"安顺\", \"area\": [\"西秀区\", \"普定县\", \"平坝县\", \"镇宁布依族苗族自治县\", \"紫云苗族布依族自治县\", \"关岭布依族苗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"铜仁地区\", \"area\": [\"铜仁市\", \"德江县\", \"江口县\", \"思南县\", \"石阡县\", \"玉屏侗族自治县\", \"松桃苗族自治县\", \"印江土家族苗族自治县\", \"沿河土家族自治县\", \"万山特区\", \"其他\"] &#125;, &#123; \"name\": \"毕节地区\", \"area\": [\"毕节市\", \"黔西县\", \"大方县\", \"织金县\", \"金沙县\", \"赫章县\", \"纳雍县\", \"威宁彝族回族苗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"黔西南布依族苗族自治州\", \"area\": [\"兴义市\", \"望谟县\", \"兴仁县\", \"普安县\", \"册亨县\", \"晴隆县\", \"贞丰县\", \"安龙县\", \"其他\"] &#125;, &#123; \"name\": \"黔东南苗族侗族自治州\", \"area\": [\"凯里市\", \"施秉县\", \"从江县\", \"锦屏县\", \"镇远县\", \"麻江县\", \"台江县\", \"天柱县\", \"黄平县\", \"榕江县\", \"剑河县\", \"三穗县\", \"雷山县\", \"黎平县\", \"岑巩县\", \"丹寨县\", \"其他\"] &#125;, &#123; \"name\": \"黔南布依族苗族自治州\", \"area\": [\"都匀市\", \"福泉市\", \"贵定县\", \"惠水县\", \"罗甸县\", \"瓮安县\", \"荔波县\", \"龙里县\", \"平塘县\", \"长顺县\", \"独山县\", \"三都水族自治县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"云南\", \"city\": [ &#123; \"name\": \"昆明\", \"area\": [\"盘龙区\", \"五华区\", \"官渡区\", \"西山区\", \"东川区\", \"安宁市\", \"呈贡县\", \"晋宁县\", \"富民县\", \"宜良县\", \"嵩明县\", \"石林彝族自治县\", \"禄劝彝族苗族自治县\", \"寻甸回族彝族自治县\", \"其他\"] &#125;, &#123; \"name\": \"曲靖\", \"area\": [\"麒麟区\", \"宣威市\", \"马龙县\", \"沾益县\", \"富源县\", \"罗平县\", \"师宗县\", \"陆良县\", \"会泽县\", \"其他\"] &#125;, &#123; \"name\": \"玉溪\", \"area\": [\"红塔区\", \"江川县\", \"澄江县\", \"通海县\", \"华宁县\", \"易门县\", \"峨山彝族自治县\", \"新平彝族傣族自治县\", \"元江哈尼族彝族傣族自治县\", \"其他\"] &#125;, &#123; \"name\": \"保山\", \"area\": [\"隆阳区\", \"施甸县\", \"腾冲县\", \"龙陵县\", \"昌宁县\", \"其他\"] &#125;, &#123; \"name\": \"昭通\", \"area\": [\"昭阳区\", \"鲁甸县\", \"巧家县\", \"盐津县\", \"大关县\", \"永善县\", \"绥江县\", \"镇雄县\", \"彝良县\", \"威信县\", \"水富县\", \"其他\"] &#125;, &#123; \"name\": \"丽江\", \"area\": [\"古城区\", \"永胜县\", \"华坪县\", \"玉龙纳西族自治县\", \"宁蒗彝族自治县\", \"其他\"] &#125;, &#123; \"name\": \"普洱\", \"area\": [\"思茅区\", \"普洱哈尼族彝族自治县\", \"墨江哈尼族自治县\", \"景东彝族自治县\", \"景谷傣族彝族自治县\", \"镇沅彝族哈尼族拉祜族自治县\", \"江城哈尼族彝族自治县\", \"孟连傣族拉祜族佤族自治县\", \"澜沧拉祜族自治县\", \"西盟佤族自治县\", \"其他\"] &#125;, &#123; \"name\": \"临沧\", \"area\": [\"临翔区\", \"凤庆县\", \"云县\", \"永德县\", \"镇康县\", \"双江拉祜族佤族布朗族傣族自治县\", \"耿马傣族佤族自治县\", \"沧源佤族自治县\", \"其他\"] &#125;, &#123; \"name\": \"德宏傣族景颇族自治州\", \"area\": [\"潞西市\", \"瑞丽市\", \"梁河县\", \"盈江县\", \"陇川县\", \"其他\"] &#125;, &#123; \"name\": \"怒江傈僳族自治州\", \"area\": [\"泸水县\", \"福贡县\", \"贡山独龙族怒族自治县\", \"兰坪白族普米族自治县\", \"其他\"] &#125;, &#123; \"name\": \"迪庆藏族自治州\", \"area\": [\"香格里拉县\", \"德钦县\", \"维西傈僳族自治县\", \"其他\"] &#125;, &#123; \"name\": \"大理白族自治州\", \"area\": [\"大理市\", \"祥云县\", \"宾川县\", \"弥渡县\", \"永平县\", \"云龙县\", \"洱源县\", \"剑川县\", \"鹤庆县\", \"漾濞彝族自治县\", \"南涧彝族自治县\", \"巍山彝族回族自治县\", \"其他\"] &#125;, &#123; \"name\": \"楚雄彝族自治州\", \"area\": [\"楚雄市\", \"双柏县\", \"牟定县\", \"南华县\", \"姚安县\", \"大姚县\", \"永仁县\", \"元谋县\", \"武定县\", \"禄丰县\", \"其他\"] &#125;, &#123; \"name\": \"红河哈尼族彝族自治州\", \"area\": [\"蒙自县\", \"个旧市\", \"开远市\", \"绿春县\", \"建水县\", \"石屏县\", \"弥勒县\", \"泸西县\", \"元阳县\", \"红河县\", \"金平苗族瑶族傣族自治县\", \"河口瑶族自治县\", \"屏边苗族自治县\", \"其他\"] &#125;, &#123; \"name\": \"文山壮族苗族自治州\", \"area\": [\"文山县\", \"砚山县\", \"西畴县\", \"麻栗坡县\", \"马关县\", \"丘北县\", \"广南县\", \"富宁县\", \"其他\"] &#125;, &#123; \"name\": \"西双版纳傣族自治州\", \"area\": [\"景洪市\", \"勐海县\", \"勐腊县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"西藏\", \"city\": [ &#123; \"name\": \"拉萨\", \"area\": [\"城关区\", \"林周县\", \"当雄县\", \"尼木县\", \"曲水县\", \"堆龙德庆县\", \"达孜县\", \"墨竹工卡县\", \"其他\"] &#125;, &#123; \"name\": \"那曲地区\", \"area\": [\"那曲县\", \"嘉黎县\", \"比如县\", \"聂荣县\", \"安多县\", \"申扎县\", \"索县\", \"班戈县\", \"巴青县\", \"尼玛县\", \"其他\"] &#125;, &#123; \"name\": \"昌都地区\", \"area\": [\"昌都县\", \"江达县\", \"贡觉县\", \"类乌齐县\", \"丁青县\", \"察雅县\", \"八宿县\", \"左贡县\", \"芒康县\", \"洛隆县\", \"边坝县\", \"其他\"] &#125;, &#123; \"name\": \"林芝地区\", \"area\": [\"林芝县\", \"工布江达县\", \"米林县\", \"墨脱县\", \"波密县\", \"察隅县\", \"朗县\", \"其他\"] &#125;, &#123; \"name\": \"山南地区\", \"area\": [\"乃东县\", \"扎囊县\", \"贡嘎县\", \"桑日县\", \"琼结县\", \"曲松县\", \"措美县\", \"洛扎县\", \"加查县\", \"隆子县\", \"错那县\", \"浪卡子县\", \"其他\"] &#125;, &#123; \"name\": \"日喀则地区\", \"area\": [\"日喀则市\", \"南木林县\", \"江孜县\", \"定日县\", \"萨迦县\", \"拉孜县\", \"昂仁县\", \"谢通门县\", \"白朗县\", \"仁布县\", \"康马县\", \"定结县\", \"仲巴县\", \"亚东县\", \"吉隆县\", \"聂拉木县\", \"萨嘎县\", \"岗巴县\", \"其他\"] &#125;, &#123; \"name\": \"阿里地区\", \"area\": [\"噶尔县\", \"普兰县\", \"札达县\", \"日土县\", \"革吉县\", \"改则县\", \"措勤县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"陕西\", \"city\": [ &#123; \"name\": \"西安\", \"area\": [\"莲湖区\", \"新城区\", \"碑林区\", \"雁塔区\", \"灞桥区\", \"未央区\", \"阎良区\", \"临潼区\", \"长安区\", \"高陵县\", \"蓝田县\", \"户县\", \"周至县\", \"其他\"] &#125;, &#123; \"name\": \"铜川\", \"area\": [\"耀州区\", \"王益区\", \"印台区\", \"宜君县\", \"其他\"] &#125;, &#123; \"name\": \"宝鸡\", \"area\": [\"渭滨区\", \"金台区\", \"陈仓区\", \"岐山县\", \"凤翔县\", \"陇县\", \"太白县\", \"麟游县\", \"扶风县\", \"千阳县\", \"眉县\", \"凤县\", \"其他\"] &#125;, &#123; \"name\": \"咸阳\", \"area\": [\"秦都区\", \"渭城区\", \"杨陵区\", \"兴平市\", \"礼泉县\", \"泾阳县\", \"永寿县\", \"三原县\", \"彬县\", \"旬邑县\", \"长武县\", \"乾县\", \"武功县\", \"淳化县\", \"其他\"] &#125;, &#123; \"name\": \"渭南\", \"area\": [\"临渭区\", \"韩城市\", \"华阴市\", \"蒲城县\", \"潼关县\", \"白水县\", \"澄城县\", \"华县\", \"合阳县\", \"富平县\", \"大荔县\", \"其他\"] &#125;, &#123; \"name\": \"延安\", \"area\": [\"宝塔区\", \"安塞县\", \"洛川县\", \"子长县\", \"黄陵县\", \"延川县\", \"富县\", \"延长县\", \"甘泉县\", \"宜川县\", \"志丹县\", \"黄龙县\", \"吴起县\", \"其他\"] &#125;, &#123; \"name\": \"汉中\", \"area\": [\"汉台区\", \"留坝县\", \"镇巴县\", \"城固县\", \"南郑县\", \"洋县\", \"宁强县\", \"佛坪县\", \"勉县\", \"西乡县\", \"略阳县\", \"其他\"] &#125;, &#123; \"name\": \"榆林\", \"area\": [\"榆阳区\", \"清涧县\", \"绥德县\", \"神木县\", \"佳县\", \"府谷县\", \"子洲县\", \"靖边县\", \"横山县\", \"米脂县\", \"吴堡县\", \"定边县\", \"其他\"] &#125;, &#123; \"name\": \"安康\", \"area\": [\"汉滨区\", \"紫阳县\", \"岚皋县\", \"旬阳县\", \"镇坪县\", \"平利县\", \"石泉县\", \"宁陕县\", \"白河县\", \"汉阴县\", \"其他\"] &#125;, &#123; \"name\": \"商洛\", \"area\": [\"商州区\", \"镇安县\", \"山阳县\", \"洛南县\", \"商南县\", \"丹凤县\", \"柞水县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"甘肃\", \"city\": [ &#123; \"name\": \"兰州\", \"area\": [\"城关区\", \"七里河区\", \"西固区\", \"安宁区\", \"红古区\", \"永登县\", \"皋兰县\", \"榆中县\", \"其他\"] &#125;, &#123; \"name\": \"嘉峪关\", \"area\": [\"嘉峪关市\", \"其他\"] &#125;, &#123; \"name\": \"金昌\", \"area\": [\"金川区\", \"永昌县\", \"其他\"] &#125;, &#123; \"name\": \"白银\", \"area\": [\"白银区\", \"平川区\", \"靖远县\", \"会宁县\", \"景泰县\", \"其他\"] &#125;, &#123; \"name\": \"天水\", \"area\": [\"清水县\", \"秦安县\", \"甘谷县\", \"武山县\", \"张家川回族自治县\", \"北道区\", \"秦城区\", \"其他\"] &#125;, &#123; \"name\": \"武威\", \"area\": [\"凉州区\", \"民勤县\", \"古浪县\", \"天祝藏族自治县\", \"其他\"] &#125;, &#123; \"name\": \"酒泉\", \"area\": [\"肃州区\", \"玉门市\", \"敦煌市\", \"金塔县\", \"肃北蒙古族自治县\", \"阿克塞哈萨克族自治县\", \"安西县\", \"其他\"] &#125;, &#123; \"name\": \"张掖\", \"area\": [\"甘州区\", \"民乐县\", \"临泽县\", \"高台县\", \"山丹县\", \"肃南裕固族自治县\", \"其他\"] &#125;, &#123; \"name\": \"庆阳\", \"area\": [\"西峰区\", \"庆城县\", \"环县\", \"华池县\", \"合水县\", \"正宁县\", \"宁县\", \"镇原县\", \"其他\"] &#125;, &#123; \"name\": \"平凉\", \"area\": [\"崆峒区\", \"泾川县\", \"灵台县\", \"崇信县\", \"华亭县\", \"庄浪县\", \"静宁县\", \"其他\"] &#125;, &#123; \"name\": \"定西\", \"area\": [\"安定区\", \"通渭县\", \"临洮县\", \"漳县\", \"岷县\", \"渭源县\", \"陇西县\", \"其他\"] &#125;, &#123; \"name\": \"陇南\", \"area\": [\"武都区\", \"成县\", \"宕昌县\", \"康县\", \"文县\", \"西和县\", \"礼县\", \"两当县\", \"徽县\", \"其他\"] &#125;, &#123; \"name\": \"临夏回族自治州\", \"area\": [\"临夏市\", \"临夏县\", \"康乐县\", \"永靖县\", \"广河县\", \"和政县\", \"东乡族自治县\", \"积石山保安族东乡族撒拉族自治县\", \"其他\"] &#125;, &#123; \"name\": \"甘南藏族自治州\", \"area\": [\"合作市\", \"临潭县\", \"卓尼县\", \"舟曲县\", \"迭部县\", \"玛曲县\", \"碌曲县\", \"夏河县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"青海\", \"city\": [ &#123; \"name\": \"西宁\", \"area\": [\"城中区\", \"城东区\", \"城西区\", \"城北区\", \"湟源县\", \"湟中县\", \"大通回族土族自治县\", \"其他\"] &#125;, &#123; \"name\": \"海东地区\", \"area\": [\"平安县\", \"乐都县\", \"民和回族土族自治县\", \"互助土族自治县\", \"化隆回族自治县\", \"循化撒拉族自治县\", \"其他\"] &#125;, &#123; \"name\": \"海北藏族自治州\", \"area\": [\"海晏县\", \"祁连县\", \"刚察县\", \"门源回族自治县\", \"其他\"] &#125;, &#123; \"name\": \"海南藏族自治州\", \"area\": [\"共和县\", \"同德县\", \"贵德县\", \"兴海县\", \"贵南县\", \"其他\"] &#125;, &#123; \"name\": \"黄南藏族自治州\", \"area\": [\"同仁县\", \"尖扎县\", \"泽库县\", \"河南蒙古族自治县\", \"其他\"] &#125;, &#123; \"name\": \"果洛藏族自治州\", \"area\": [\"玛沁县\", \"班玛县\", \"甘德县\", \"达日县\", \"久治县\", \"玛多县\", \"其他\"] &#125;, &#123; \"name\": \"玉树藏族自治州\", \"area\": [\"玉树县\", \"杂多县\", \"称多县\", \"治多县\", \"囊谦县\", \"曲麻莱县\", \"其他\"] &#125;, &#123; \"name\": \"海西蒙古族藏族自治州\", \"area\": [\"德令哈市\", \"格尔木市\", \"乌兰县\", \"都兰县\", \"天峻县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"宁夏\", \"city\": [ &#123; \"name\": \"银川\", \"area\": [\"兴庆区\", \"西夏区\", \"金凤区\", \"灵武市\", \"永宁县\", \"贺兰县\", \"其他\"] &#125;, &#123; \"name\": \"石嘴山\", \"area\": [\"大武口区\", \"惠农区\", \"平罗县\", \"其他\"] &#125;, &#123; \"name\": \"吴忠\", \"area\": [\"利通区\", \"青铜峡市\", \"盐池县\", \"同心县\", \"其他\"] &#125;, &#123; \"name\": \"固原\", \"area\": [\"原州区\", \"西吉县\", \"隆德县\", \"泾源县\", \"彭阳县\", \"其他\"] &#125;, &#123; \"name\": \"中卫\", \"area\": [\"沙坡头区\", \"中宁县\", \"海原县\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"新疆\", \"city\": [ &#123; \"name\": \"乌鲁木齐\", \"area\": [\"天山区\", \"沙依巴克区\", \"新市区\", \"水磨沟区\", \"头屯河区\", \"达坂城区\", \"东山区\", \"乌鲁木齐县\", \"其他\"] &#125;, &#123; \"name\": \"克拉玛依\", \"area\": [\"克拉玛依区\", \"独山子区\", \"白碱滩区\", \"乌尔禾区\", \"其他\"] &#125;, &#123; \"name\": \"吐鲁番地区\", \"area\": [\"吐鲁番市\", \"托克逊县\", \"鄯善县\", \"其他\"] &#125;, &#123; \"name\": \"哈密地区\", \"area\": [\"哈密市\", \"伊吾县\", \"巴里坤哈萨克自治县\", \"其他\"] &#125;, &#123; \"name\": \"和田地区\", \"area\": [\"和田市\", \"和田县\", \"洛浦县\", \"民丰县\", \"皮山县\", \"策勒县\", \"于田县\", \"墨玉县\", \"其他\"] &#125;, &#123; \"name\": \"阿克苏地区\", \"area\": [\"阿克苏市\", \"温宿县\", \"沙雅县\", \"拜城县\", \"阿瓦提县\", \"库车县\", \"柯坪县\", \"新和县\", \"乌什县\", \"其他\"] &#125;, &#123; \"name\": \"喀什地区\", \"area\": [\"喀什市\", \"巴楚县\", \"泽普县\", \"伽师县\", \"叶城县\", \"岳普湖县\", \"疏勒县\", \"麦盖提县\", \"英吉沙县\", \"莎车县\", \"疏附县\", \"塔什库尔干塔吉克自治县\", \"其他\"] &#125;, &#123; \"name\": \"克孜勒苏柯尔克孜自治州\", \"area\": [\"阿图什市\", \"阿合奇县\", \"乌恰县\", \"阿克陶县\", \"其他\"] &#125;, &#123; \"name\": \"巴音郭楞蒙古自治州\", \"area\": [\"库尔勒市\", \"和静县\", \"尉犁县\", \"和硕县\", \"且末县\", \"博湖县\", \"轮台县\", \"若羌县\", \"焉耆回族自治县\", \"其他\"] &#125;, &#123; \"name\": \"昌吉回族自治州\", \"area\": [\"昌吉市\", \"阜康市\", \"奇台县\", \"玛纳斯县\", \"吉木萨尔县\", \"呼图壁县\", \"木垒哈萨克自治县\", \"米泉市\", \"其他\"] &#125;, &#123; \"name\": \"博尔塔拉蒙古自治州\", \"area\": [\"博乐市\", \"精河县\", \"温泉县\", \"其他\"] &#125;, &#123; \"name\": \"石河子\", \"area\": [\"石河子\"] &#125;, &#123; \"name\": \"阿拉尔\", \"area\": [\"阿拉尔\"] &#125;, &#123; \"name\": \"图木舒克\", \"area\": [\"图木舒克\"] &#125;, &#123; \"name\": \"五家渠\", \"area\": [\"五家渠\"] &#125;, &#123; \"name\": \"伊犁哈萨克自治州\", \"area\": [\"伊宁市\", \"奎屯市\", \"伊宁县\", \"特克斯县\", \"尼勒克县\", \"昭苏县\", \"新源县\", \"霍城县\", \"巩留县\", \"察布查尔锡伯自治县\", \"塔城地区\", \"阿勒泰地区\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"台湾\", \"city\": [ &#123; \"name\": \"台湾\", \"area\": [\"台北市\", \"高雄市\", \"台北县\", \"桃园县\", \"新竹县\", \"苗栗县\", \"台中县\", \"彰化县\", \"南投县\", \"云林县\", \"嘉义县\", \"台南县\", \"高雄县\", \"屏东县\", \"宜兰县\", \"花莲县\", \"台东县\", \"澎湖县\", \"基隆市\", \"新竹市\", \"台中市\", \"嘉义市\", \"台南市\", \"其他\"] &#125;, &#123; \"name\": \"其他\", \"area\": [\"其他\"] &#125; ] &#125;, &#123; \"name\": \"澳门\", \"city\": [ &#123; \"name\": \"澳门\", \"area\": [\"花地玛堂区\", \"圣安多尼堂区\", \"大堂区\", \"望德堂区\", \"风顺堂区\", \"嘉模堂区\", \"圣方济各堂区\", \"路凼\", \"其他\"] &#125; ] &#125;, &#123; \"name\": \"香港\", \"city\": [ &#123; \"name\": \"香港\", \"area\": [\"中西区\", \"湾仔区\", \"东区\", \"南区\", \"深水埗区\", \"油尖旺区\", \"九龙城区\", \"黄大仙区\", \"观塘区\", \"北区\", \"大埔区\", \"沙田区\", \"西贡区\", \"元朗区\", \"屯门区\", \"荃湾区\", \"葵青区\", \"离岛区\", \"其他\"] &#125; ] &#125;, &#123; \"name\": \"钓鱼岛\", \"city\": [ &#123; \"name\": \"钓鱼岛\", \"area\": [\"钓鱼岛\"] &#125; ] &#125;] 省市列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582[ &#123; \"title\": \"北京\", \"contents\": [ \"东城区\", \"西城区\", \"崇文区\", \"宣武区\", \"朝阳区\", \"丰台区\", \"石景山区\", \"海淀区\", \"门头沟区\", \"房山区\", \"通州区\", \"顺义区\", \"昌平区\", \"大兴区\", \"平谷区\", \"怀柔区\", \"密云县\", \"延庆县\" ] &#125;, &#123; \"title\": \"天津\", \"contents\": [ \"天津\" ] &#125;, &#123; \"title\": \"河北\", \"contents\": [ \"石家庄\", \"唐山\", \"秦皇岛\", \"邯郸\", \"邢台\", \"保定\", \"张家口\", \"承德\", \"沧州\", \"廊坊\", \"衡水\" ] &#125;, &#123; \"title\": \"山西\", \"contents\": [ \"太原\", \"大同\", \"阳泉\", \"长治\", \"晋城\", \"朔州\", \"忻州\", \"吕梁\", \"晋中\", \"临汾\", \"运城\" ] &#125;, &#123; \"title\": \"内蒙古\", \"contents\": [ \"呼和浩特\", \"包头\", \"乌海\", \"赤峰\", \"呼伦贝尔\", \"兴安盟\", \"通辽\", \"锡林郭勒盟\", \"乌兰察布盟\", \"伊克昭盟\", \"巴彦淖尔盟\", \"阿拉善盟\" ] &#125;, &#123; \"title\": \"辽宁\", \"contents\": [ \"沈阳\", \"大连\", \"鞍山\", \"抚顺\", \"本溪\", \"丹东\", \"锦州\", \"营口\", \"阜新\", \"辽阳\", \"盘锦\", \"铁岭\", \"朝阳\", \"葫芦岛\", \"其他\" ] &#125;, &#123; \"title\": \"吉林\", \"contents\": [ \"长春\", \"吉林\", \"四平\", \"辽源\", \"通化\", \"白山\", \"松原\", \"白城\", \"延边朝鲜族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"黑龙江\", \"contents\": [ \"哈尔滨\", \"齐齐哈尔\", \"鹤岗\", \"双鸭山\", \"鸡西\", \"大庆\", \"伊春\", \"牡丹江\", \"佳木斯\", \"七台河\", \"黑河\", \"绥化\", \"大兴安岭地区\", \"其他\" ] &#125;, &#123; \"title\": \"上海\", \"contents\": [ \"上海\" ] &#125;, &#123; \"title\": \"江苏\", \"contents\": [ \"南京\", \"苏州\", \"无锡\", \"常州\", \"镇江\", \"南通\", \"泰州\", \"扬州\", \"盐城\", \"连云港\", \"徐州\", \"淮安\", \"宿迁\", \"其他\" ] &#125;, &#123; \"title\": \"浙江\", \"contents\": [ \"杭州\", \"宁波\", \"温州\", \"嘉兴\", \"湖州\", \"绍兴\", \"金华\", \"衢州\", \"舟山\", \"台州\", \"丽水\", \"其他\" ] &#125;, &#123; \"title\": \"安徽\", \"contents\": [ \"合肥\", \"芜湖\", \"蚌埠\", \"淮南\", \"马鞍山\", \"淮北\", \"铜陵\", \"安庆\", \"黄山\", \"滁州\", \"阜阳\", \"宿州\", \"巢湖\", \"六安\", \"亳州\", \"池州\", \"宣城\", \"其他\" ] &#125;, &#123; \"title\": \"福建\", \"contents\": [ \"福州\", \"厦门\", \"莆田\", \"三明\", \"泉州\", \"漳州\", \"南平\", \"龙岩\", \"宁德\", \"其他\" ] &#125;, &#123; \"title\": \"江西\", \"contents\": [ \"南昌\", \"景德镇\", \"萍乡\", \"九江\", \"新余\", \"鹰潭\", \"赣州\", \"吉安\", \"宜春\", \"抚州\", \"上饶\", \"其他\" ] &#125;, &#123; \"title\": \"山东\", \"contents\": [ \"济南\", \"青岛\", \"淄博\", \"枣庄\", \"东营\", \"烟台\", \"潍坊\", \"济宁\", \"泰安\", \"威海\", \"日照\", \"莱芜\", \"临沂\", \"德州\", \"聊城\", \"滨州\", \"菏泽\", \"其他\" ] &#125;, &#123; \"title\": \"河南\", \"contents\": [ \"郑州\", \"开封\", \"洛阳\", \"平顶山\", \"安阳\", \"鹤壁\", \"新乡\", \"焦作\", \"濮阳\", \"许昌\", \"漯河\", \"三门峡\", \"南阳\", \"商丘\", \"信阳\", \"周口\", \"驻马店\", \"焦作\", \"其他\" ] &#125;, &#123; \"title\": \"湖北\", \"contents\": [ \"武汉\", \"黄石\", \"十堰\", \"荆州\", \"宜昌\", \"襄樊\", \"鄂州\", \"荆门\", \"孝感\", \"黄冈\", \"咸宁\", \"随州\", \"恩施土家族苗族自治州\", \"仙桃\", \"天门\", \"潜江\", \"神农架林区\", \"其他\" ] &#125;, &#123; \"title\": \"湖南\", \"contents\": [ \"长沙\", \"株洲\", \"湘潭\", \"衡阳\", \"邵阳\", \"岳阳\", \"常德\", \"张家界\", \"益阳\", \"郴州\", \"永州\", \"怀化\", \"娄底\", \"湘西土家族苗族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"广东\", \"contents\": [ \"广州\", \"深圳\", \"东莞\", \"中山\", \"潮州\", \"揭阳\", \"云浮\", \"珠海\", \"汕头\", \"韶关\", \"佛山\", \"江门\", \"湛江\", \"茂名\", \"肇庆\", \"惠州\", \"梅州\", \"汕尾\", \"河源\", \"阳江\", \"清远\" ] &#125;, &#123; \"title\": \"广西\", \"contents\": [ \"南宁\", \"柳州\", \"桂林\", \"梧州\", \"北海\", \"防城港\", \"钦州\", \"贵港\", \"玉林\", \"百色\", \"贺州\", \"河池\", \"来宾\", \"崇左\", \"其他\" ] &#125;, &#123; \"title\": \"海南\", \"contents\": [ \"海口\", \"三亚\", \"五指山\", \"琼海\", \"儋州\", \"文昌\", \"万宁\", \"东方\", \"澄迈县\", \"定安县\", \"屯昌县\", \"临高县\", \"白沙黎族自治县\", \"昌江黎族自治县\", \"乐东黎族自治县\", \"陵水黎族自治县\", \"保亭黎族苗族自治县\", \"琼中黎族苗族自治县\", \"其他\" ] &#125;, &#123; \"title\": \"重庆\", \"contents\": [ \"重庆\" ] &#125;, &#123; \"title\": \"四川\", \"contents\": [ \"成都\", \"自贡\", \"攀枝花\", \"泸州\", \"德阳\", \"绵阳\", \"广元\", \"遂宁\", \"内江\", \"乐山\", \"南充\", \"眉山\", \"宜宾\", \"广安\", \"达州\", \"雅安\", \"巴中\", \"资阳\", \"阿坝藏族羌族自治州\", \"甘孜藏族自治州\", \"凉山彝族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"贵州\", \"contents\": [ \"贵阳\", \"六盘水\", \"遵义\", \"安顺\", \"铜仁地区\", \"毕节地区\", \"黔西南布依族苗族自治州\", \"黔东南苗族侗族自治州\", \"黔南布依族苗族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"云南\", \"contents\": [ \"昆明\", \"曲靖\", \"玉溪\", \"保山\", \"昭通\", \"丽江\", \"普洱\", \"临沧\", \"德宏傣族景颇族自治州\", \"怒江傈僳族自治州\", \"迪庆藏族自治州\", \"大理白族自治州\", \"楚雄彝族自治州\", \"红河哈尼族彝族自治州\", \"文山壮族苗族自治州\", \"西双版纳傣族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"西藏\", \"contents\": [ \"拉萨\", \"那曲地区\", \"昌都地区\", \"林芝地区\", \"山南地区\", \"日喀则地区\", \"阿里地区\", \"其他\" ] &#125;, &#123; \"title\": \"陕西\", \"contents\": [ \"西安\", \"铜川\", \"宝鸡\", \"咸阳\", \"渭南\", \"延安\", \"汉中\", \"榆林\", \"安康\", \"商洛\", \"其他\" ] &#125;, &#123; \"title\": \"甘肃\", \"contents\": [ \"兰州\", \"嘉峪关\", \"金昌\", \"白银\", \"天水\", \"武威\", \"酒泉\", \"张掖\", \"庆阳\", \"平凉\", \"定西\", \"陇南\", \"临夏回族自治州\", \"甘南藏族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"青海\", \"contents\": [ \"西宁\", \"海东地区\", \"海北藏族自治州\", \"海南藏族自治州\", \"黄南藏族自治州\", \"果洛藏族自治州\", \"玉树藏族自治州\", \"海西蒙古族藏族自治州\", \"其他\" ] &#125;, &#123; \"title\": \"宁夏\", \"contents\": [ \"银川\", \"石嘴山\", \"吴忠\", \"固原\", \"中卫\", \"其他\" ] &#125;, &#123; \"title\": \"新疆\", \"contents\": [ \"乌鲁木齐\", \"克拉玛依\", \"吐鲁番地区\", \"哈密地区\", \"和田地区\", \"阿克苏地区\", \"喀什地区\", \"克孜勒苏柯尔克孜自治州\", \"巴音郭楞蒙古自治州\", \"昌吉回族自治州\", \"博尔塔拉蒙古自治州\", \"石河子\", \"阿拉尔\", \"图木舒克\", \"五家渠\", \"伊犁哈萨克自治州\", \"其他\" ] &#125;, &#123; \"title\": \"台湾\", \"contents\": [ \"台湾\", \"其他\" ] &#125;, &#123; \"title\": \"澳门\", \"contents\": [ \"澳门\" ] &#125;, &#123; \"title\": \"香港\", \"contents\": [ \"香港\" ] &#125;, &#123; \"title\": \"钓鱼岛\", \"contents\": [ \"钓鱼岛\" ] &#125;]","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"express常用npm包整理","date":"2017-05-22T02:16:51.000Z","path":"2017/05/22/express常用npm包整理/","text":"art-template 一款js模板引擎，性能不错 async 流程控制工具，以语法糖解决node callback hell，类似还有q等 body-parser express自带http body解析中间件 connect-multiparty一款中间件，可以在express中通过req.files方式获取req中的文件上传参数 cookie-parserexpress自带cookie解析 excel-export 用于导出数据至excel文件 linq c#中用得较多，支持数组数据处理，功能强大 images node图片处理中间件 log4js相当于java的log4j mssql sqlserver数据库连接中间件 node-xlsx 处理excel文件（缺点是excel必须以xlsx结尾） request node端request组件 formidable 文件上传npm包 memcached memcache操作包 gobble-ssi ssi引入支持 ipip ip归属地查询 commander node控制台应用 fs-extra 增强型fs组件 markdown-it markdown文件解析 open 用于控制浏览器直接打开某url rd 文件或目录遍历 swig swig模板 moment js日期处理类库，支持node端与浏览器端 ccap 图形验证码生成库 crypto node加密 node-uuid 生成uuid redis redis客户端连接库 js-jsonrpc nodejs端jsonrpc调用 co Tj大神写的，处理node回调，早期使用偏函数形式解决回调，后来兼容promise模式","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"使用node和commander.js构建命令行工具","date":"2017-05-21T02:04:20.000Z","path":"2017/05/21/使用node和commander-js构建命令行工具/","text":"Commander.js 是 TJ 大神写的一个帮助快速开发Nodejs命令行工具的package。TJ同时也是 Express , mocha , koa , debug 等流行package的作者，是Nodejs社区里非常知名的高产作者。Commander可以： 解析命令行参数方便的定义option(包括option的描述和其回调函数)和子命令。 创建环境12345678$ mkdir command //新建工程文件夹(名称随意)$ cd command$ npm init //新建package.json文件$ npm i -S commander //下载安装commander包并将依赖存入package.json$ mkdir bin //创建bin文件夹，存放命令文件$ cd bin$ touch xiangnick//创建名为xiangnick的脚本文件(也可以命名为xiangnick.js方便ide提示) 此时目录结构如下 编写脚本编写刚才创建在bin目录下的脚本文件(xiangnick)123456789101112131415#!/usr/bin/env node//上方为固定格式var program = require('commander');//引入node_modules里的commanderlet xiangnick = function()&#123; console.log('这是xiangnick -x的执行命令');&#125;program .version('0.0.1') //'参数缩写,参数','提示信息',调用函数名 .option('-x, --xiangnick','Hello I am xiangnick', xiangnick) .option('-p, --peppers', 'Add peppers') .parse(process.argv); 具体的api可以查看tj大神在github上的ReadMe 指定脚本脚本编写完毕，需要在package.json文件中指定该脚本1234567891011121314151617&#123; \"name\": \"command\", \"version\": \"0.0.1\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"bin\":&#123; \"xiangnick\":\"./bin/xiangnick.js\" //\"脚本名\":\"路径\" &#125;, \"author\": \"xiangnick\", \"license\": \"MIT\", \"dependencies\": &#123; \"commander\": \"^2.9.0\" &#125;&#125; 链接全局bin目录下脚本和根目录下package.json指定完毕后，在根目录执行 1$ npm link 此时该命令已经链接到全局了，在任意目录下可以执行该命令其中-h -V是commander.js自动给我们生成好的命令。 解除链接如果不想再使用该命令，可以在工程根目录下执行 1$ npm unlink 即可取消全局链接","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"CentOS下的node.JS环境配置","date":"2017-05-20T12:29:21.000Z","path":"2017/05/20/CentOS下的node-JS环境配置/","text":"三M安装法：nvm nrm npm1.安装nvmNVM（Node version manager），是Node.js的版本管理软件，可以轻松的在node.js各个版本间切换，项目源码在GitHub；在开发环境中，避免不了经常需要更换node版本的情况，nvm只需几行命令即可完成node版本的下载，使用。在非 Windows(如 os x, Linux) 环境下, 可以使用 nvm 来配置 node 开发环境, 保持系统的干净，在Windows 环境下, 可以使用nvm，也可以用 nvmw 来替代 nvm； 1.1 具体步骤获取nvm源码方法一 ：直接从 github 找到最新版本通过wget下载到本地1wget https://github.com/cnpm/nvm/archive/v0.23.0.tar.gz 完毕后需要解压 1tar -zxvf v0.23.0.tar.gz -C 解压目录 方法二 ：直接git clone 克隆项目源码到本地 1Git clone https://github.com/cnpm/nvm.git 安装nvm安装nvm非常简单，只要进入nvm的源码目录然后执行 1./install.sh 然后添加环境变量 1source ~/.bash_profile 如果想终端启动时自动执行 source ~/git/nvm/nvm.sh,需要在 ~/.bashrc, ~/.bash_profile, ~/.profile, 或者 ~/.zshrc 文件添加以下命令:（.profile一般在/etc下） 1source ~/nvm的路径/nvm.sh 这样就会在机器启动时自动执行以上命令了。此时，nvm已经安装完毕。可以通过nvm --version命令来查看是否安装完成。 nvm相关命令 列出所有可安装的版本nvm list-remote 安装某版本 nvm install 版本号 使用某版本 nvm use 版本号 查看本地已经下载过可供切换的版本 nvm ls 2.安装npmnpm通过以上步骤已经随node一同安装完毕，可以直接使用 3.安装nrm通常，npm的包下载路径是从国外下载的，速度很慢，我们可以在命令最后添加--registry=https://registry.npm.taobao.org 来指定镜像，加速下载。如： 1npm install gulp -g --registry=https://registry.npm.taobao.org 我们可以安装nrm来管理npm镜像环境，不需要每次都指定镜像了。 1npm install -g nrm nrm相关命令 列出可选的源nrm ls 切换源 nrm use 名称 增加源 可以增加定制的源，特别适用于添加企业内部的私有源。私有源可以使用cnpmjs架设。nrm add [home] 删除源 nrm del 名称 测试速度nrm test 名称 测试指定源的响应时间nrm test测试全部源的时间，为了取得较准确的结果，可以考虑多次测试取平均值","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"H5的<picture>响应式处理图片","date":"2017-05-19T07:55:38.000Z","path":"2017/05/19/H5的-picture-响应式处理图片/","text":"响应式设计所谓的响应式设计，是指在不同的屏幕分辨率，不同的像素密度比，不同宽度的终端设备中，网页布局可以自适应的调整。响应式设计的本意是使原本PC上的网站兼容移动终端，大部分响应式网页是通过媒体查询，加载不同样式的CSS文件实现的。这样的弹性化布局使网站在不同的设备终端布局都比较合理。虽然响应式设计的好处多多，但是也有诸多缺陷。由于PC端和移动终端访问的是同一个网站，PC端可以不计较流量限制，但是移动端不可能不计较。响应式布局示意图 为适配不同终端机型的屏幕宽度和像素密度，我们一般会使用如下方法设置图片的CSS样式： 123456&lt;style&gt; img&#123; max-width:100%; height:auto; &#125;&lt;/style&gt; 将图片的最大宽度设置为100%，以确保图像不会超出其父级元素的宽度，如果父级元素的宽度发生改变，图片的宽度也随之改变，height：auto 可以确保图片的宽度发生改变时，图片的高度会依据自身的宽高比例进行缩放。这样当我们在移动设备上访问响应式网页里的图片时，只是把图片的分辨率做了缩放，下载的还是PC端的那张大图，这样不仅浪费流量，而且浪费带宽，而且会拖慢网页的打开速度，严重影响用户的使用体验。 新的解决方案：&lt;picture&gt;&lt;picture&gt;是HTML5的一个新元素；如果&lt;picture&gt;元素与当前的&lt;audio&gt;,&lt;video&gt;元素协同合作将增强响应式图像工作的进程，它允许在其内部设置多个&lt;source&gt;标签，以指定不同的图像文件名，根据不同的条件进行加载；&lt;picture&gt;可以根据不同的条件加载不同的图像，这些条件可以是视窗当前的高度（viewport），宽度（width），方向（orientation），像素密度（dpr）等； 举几个栗子1.如下栗子中针对不同屏幕宽度加载不同的图片；当页面宽度 在320px到640px之间时加载minpic.png；当页面宽度大于640px时加载middle.png 12345&lt;picture&gt; &lt;source media=\"(min-width: 320px) and (max-width: 640px)\" srcset=\"img/minpic.png\"&gt; &lt;source media=\"(min-width: 640px)\" srcset=\"img/middle.png\"&gt; &lt;img src=\"img/picture.png\" alt=\"this is a picture\"&gt;&lt;/picture&gt; 2.如下栗子中添加了屏幕的方向作为条件；当屏幕方向为横屏方向时加载_landscape.png结尾的图片；当屏幕方向为竖屏方向时加载 _portrait.png结尾的图片；1234567&lt;picture&gt; &lt;source media=\"(min-width: 320px) and (max-width: 640px) and (orientation: landscape)\" srcset=\"img/minpic_landscape.png\"&gt; &lt;source media=\"(min-width: 320px) and (max-width: 640px) and (orientation: portrait)\" srcset=\"img/minpic_portrait.png\"&gt; &lt;source media=\"(min-width: 640px) and (orientation: landscape)\" srcset=\"img/middlepic_landscape.png\"&gt; &lt;source media=\"(min-width: 640px) and (orientation: portrait)\" srcset=\"img/middlepic_portrait.png\"&gt; &lt;img src=\"img/picture.png\" alt=\"this is a picture\"&gt;&lt;/picture&gt; 3.如下栗子中添加了屏幕像素密度作为条件；当像素密度为2x时加载_retina.png 2x 的图片，当像素密度为1x时加载无retina后缀的图片；12345&lt;picture&gt; &lt;source media=\"(min-width: 320px) and (max-width: 640px)\" srcset=\"img/minpic.png,img/minpic_retina.png 2x\"&gt; &lt;source media=\"(min-width: 640px)\" srcset=\"img/middle.png,img/middle_retina.png 2x\"&gt; &lt;img src=\"img/picture.png,img/picture_retina.png 2x\" alt=\"this is a picture\"&gt;&lt;/picture&gt; 4.如下栗子中添加图片文件格式作为条件,当支持webp格式图片时加载webp格式图片，当不支持时加载png格式图片；1234&lt;picture&gt; &lt;source type=\"image/webp\" srcset=\"img/picture.webp\"&gt; &lt;img src=\"img/picture.png\" alt=\"this is a picture\"&gt;&lt;/picture&gt; 5.如下例子中添加宽度描述；页面会根据当前尺寸选择加载不大于当前宽度的最大的图片；123456&lt;img src=\"picture-160.png\" alt=\"this is a picture\" sizes=\"90vw\" srcset=\"picture-160.png 160w, picture-320.png 320w, picture-640.png 640w, picture-1280.png 1280w\"&gt; 6.如下例子中添加sizes属性；当窗口宽度大于等于800px时加载对应版本的图片；1234567891011&lt;source media=\"(min-width: 800px)\" sizes=\"90vw\" srcset=\"picture-landscape-640.png 640w, picture-landscape-1280.png 1280w, picture-landscape-2560.png 2560w\"&gt;&lt;img src=\"picture-160.png\" alt=\"this is a picture\" sizes=\"90vw\" srcset=\"picture-160.png 160w, picture-320.png 320w, picture-640.png 640w, picture-1280.png 1280w\"&gt; 兼容性：目前只有Chrome ， Firefox ， Opera 对其兼容性较好，具体兼容性如图：兼容性示意图 优点： 加载适当大小的图像文件，使可用带宽得到充分利用； 加载不同剪裁并具有不同横纵比的图像，以适应不同宽度的布局变化； 加载更高的像素密度，显示更高分辨率的图像； 步骤： 创建标签； 在这些标签内创建一个你想用来执行任何一个特性的标签； 添加一个media属性，用来包含你想要的特性，如宽度（max-width，min-width），方向（orientation）等； 添加一个srcset属性，属性值为相应的图像文件名称，进行加载。如果你想提供不同的像素密度，例如Retina显示屏，可以添加额外的文件名到srcset属性中； 添加一个回退的标签；&lt;picture&gt;的工作原理 &lt;picture&gt;语法由上面的示例代码可知，在没有引入js和第三方库，CSS中没有包含media queries的情况下，&lt;picture&gt;元素可以实现只用HTML来声明响应式图片； &lt;source&gt;元素&lt;picture&gt;标签它本身没有属性。神奇的地方是&lt;picture&gt;被用来当做&lt;source&gt;的容器。&lt;source&gt;元素，是用来加载多媒体的比如视频和音频，已经被更新用到图片的加载并且一些新的属性已经被添加： srcset (必需)接受单一的图片文件路径(如：srcset=”img/minpic.png”).或者是逗号分隔的用像素密度描述的图片路径(如：srcset=”img/minpic.png,img/minpic_retina.png 2x”),1x 的描述是默认不使用的。 media (可选)接受任何验证的media query,你可以看到在CSS @media选择器(如：media=”(min-width: 320px)”).在之前的&lt;picture&gt;语法的例子里已经用到了。 sizes（可选）接收单一的宽度描述(如：sizes=”100vw”)或者单一的media query宽度描述(如：sizes=”(min-width: 320px) 100vw”). 或者逗号分隔的media query对宽度的描述(如：sizes=”(min-width: 320px) 100vw, (min-width: 640px) 50vw, calc(33vw - 100px)”) 最后的一个被当做默认的。 type(可选)接受支持的MIME类型(如: type=”image/webp” or type=”image/vnd.ms-photo”) 浏览器会根据这些提示和属性来加载确切的图片资源。根据标签的列表顺序。浏览器会使用第一个合适的&lt;source&gt;元素并忽略掉后面的&lt;source&gt;标签。 添加最后的&lt;img&gt;元素&lt;img&gt;元素在&lt;picture&gt;内部用来当浏览器不支持时或者没有源标签匹配时的显示。在&lt;picture&gt;内使用&lt;img&gt;标签是必须得，如果你忘记了，将不会有图片显示出来。 用&lt;img&gt;来声明默认的图片显示。将&lt;img&gt;标签放到&lt;picture&gt;内的最后，浏览器在找到&lt;img&gt;标签之前会忽略&lt;source&gt;的声明。这个图片标签也需要你写上它的alt属性。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"package.json文件解析","date":"2017-05-15T16:07:34.000Z","path":"2017/05/16/package-json文件解析/","text":"概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。下面是一个最简单的package.json文件，只定义两项元数据：项目名称和项目版本。1234&#123; \"name\" : \"xxx\", \"version\" : \"0.0.0\",&#125; 上面代码说明，package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（遵守“大版本.次要版本.小版本”的格式）。 下面是一个更完整的package.json文件。1234567891011121314151617181920212223242526272829303132333435&#123; \"name\": \"Hello World\", \"version\": \"0.0.1\", \"author\": \"张三\", \"description\": \"第一个node.js程序\", \"keywords\":[\"node.js\",\"javascript\"], \"repository\": &#123; \"type\": \"git\", \"url\": \"https://path/to/url\" &#125;, \"license\":\"MIT\", \"engines\": &#123;\"node\": \"0.10.x\"&#125;, \"bugs\":&#123;\"url\":\"http://path/to/bug\",\"email\":\"bug@example.com\"&#125;, \"contributors\":[&#123;\"name\":\"李四\",\"email\":\"lisi@example.com\"&#125;], \"scripts\": &#123; \"start\": \"node index.js\" &#125;, \"dependencies\": &#123; \"express\": \"latest\", \"mongoose\": \"~3.8.3\", \"handlebars-runtime\": \"~1.0.12\", \"express3-handlebars\": \"~0.5.0\", \"MD5\": \"~1.2.0\" &#125;, \"devDependencies\": &#123; \"bower\": \"~1.2.8\", \"grunt\": \"~0.4.1\", \"grunt-contrib-concat\": \"~0.3.0\", \"grunt-contrib-jshint\": \"~0.7.2\", \"grunt-contrib-uglify\": \"~0.2.7\", \"grunt-contrib-clean\": \"~0.5.0\", \"browserify\": \"2.36.1\", \"grunt-browserify\": \"~1.3.0\", &#125;&#125; 下面详细解释package.json文件的各个字段。 scripts字段scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。 下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。123456\"scripts\": &#123; \"preinstall\": \"echo here it comes!\", \"postinstall\": \"echo there it goes!\", \"start\": \"node index.js\", \"test\": \"tap test/*.js\"&#125; dependencies字段，devDependencies字段dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。123456&#123; \"devDependencies\": &#123; \"browserify\": \"~13.0.0\", \"karma-browserify\": \"~5.0.1\" &#125;&#125; 对应的版本可以加上各种限定，主要有以下几种： 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如ˆ1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 package.json文件可以手工编写，也可以使用npm init命令自动生成。 1$ npm init 这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。1$ npm install 如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。12$ npm install express --save$ npm install express --save-dev 上面代码表示单独安装express模块，--save参数表示将该模块写入dependencies属性，--save-dev表示将该模块写入devDependencies属性。 简写方式：12$ npm i -S express$ npm i -D express 建议用这种方式。–save-dev表示是开发时需要的依赖，比如gulp、test等，而–save是生产环境所需的依赖。针对不同的环境使用-S或-D去package.json存相应的依赖。 peerDependencies有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。 大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。 最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。 peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。 123456&#123; \"name\": \"chai-as-promised\", \"peerDependencies\": &#123; \"chai\": \"1.x\" &#125;&#125; 上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。 注意，从npm 3.0版开始，peerDependencies不再会默认安装了。 bin字段bin项用来指定各个内部命令对应的可执行文件的位置。123\"bin\": &#123; \"someTool\": \"./bin/someTool.js\"&#125; 上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。 因此，像下面这样的写法可以采用简写。1234567scripts: &#123; start: './node_modules/someTool/someTool.js build'&#125;// 简写为scripts: &#123; start: 'someTool build'&#125; 所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。 main字段main字段指定了加载该模块时的入门文件，默认是模块根目录下面的index.js。 config字段config字段用于向环境变量输出值。 下面是一个package.json文件。12345&#123; \"name\" : \"foo\", \"config\" : &#123; \"port\" : \"8080\" &#125;, \"scripts\" : &#123; \"start\" : \"node server.js\" &#125;&#125; 然后，在server.js脚本就可以引用config字段的值。1http.createServer(...).listen(process.env.npm_package_config_port) 用户可以改变这个值。1$ npm config set foo:port 80 其他browser字段browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。123\"browser\": &#123; \"tipso\": \"./node_modules/tipso/src/tipso.js\"&#125;, engines字段engines指明了该项目所需要的node.js版本。 man字段man用来指定当前模块的man文档的位置。1\"man\" :[ \"./doc/calc.1\" ] preferGlobal字段preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。 style字段style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。123\"style\": [ \"./node_modules/tipso/src/tipso.css\"] 整理自阮一峰GitHub","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"移动端web开发技能总结","date":"2017-05-12T14:18:35.000Z","path":"2017/05/12/移动端web开发技能总结/","text":"一、rem布局对于移动设备的适配，传统模式使用宽度设置百分比，高度设置px，利用百分比来完成不同设备的适配，但是布局起来比较麻烦，也有一定的局限性，目前比较完善的是rem布局。 rem布局准备1、em与rem单位 em：为css中度量单位，以当前元素的font-size作为基准，比如当前font-size为18px，2em即为36px。但是em具有局限性，比如我们定义了当前盒子宽高均为为2em，但是又想其字体大小改为16px，那么必然导致盒子宽高也改变。所以一般不采用em为布局单位，而采用灵活的rem。 rem：为css中度量单位，以根元素即html[document.documentElement]为基准，比如html的font-size为18px，盒子宽高均为2rem即为36px，盒子自己的font-size可以随便设置而不会改变盒子本身大小。 2、为了在不同的设备上都有相同百分比的布局，一般根据UI给的设计稿将其均分，比如UI给的设计稿是在640px环境下的，我们就将其均分为20份，那么一份为32px，html的font-size就为32px，接下来通过媒体查询或者js给html根元素设置了font-size之后，剩下的其他的均为(UI图中实际px/UI图中一份的px)rem。 2.1 rem+媒体查询实践 ① rem单位设置假如UI给了这张设计图，其宽度大小为640px，那么我们将其分为20份，得到一份为32px。接着去less中编写媒体查询语句为html根节点赋font-size、一般命名为adapter.less123456789101112131415161718192021222324252627282930313233343536373839404142@media only screen and (width:320px)&#123; html&#123; font-size: 16px; &#125;&#125;@media only screen and (width:360px)&#123; html&#123; font-size: 18px; &#125;&#125;@media only screen and (width:375px)&#123; html&#123; font-size: 18.75px; &#125;&#125;@media only screen and (width:400px)&#123; html&#123; font-size: 20px; &#125;&#125;@media only screen and (width:414px)&#123; html&#123; font-size: 20.7px; &#125;&#125;@media only screen and (width:640px)&#123; html&#123; font-size: 32px; &#125;&#125;&lt;!--宽度大于640的情况--&gt;@media only screen and (min-width:640)&#123; html&#123; font-size: 32px; &#125;&#125; 这样大部分的手机移动设备都设置了rem的1单位的大小。（本例以20份为例） ② index.less中导入adapter.less并布局12@import 'base.less';/*基础样式*/@import 'adapter.less'; 假如我们通过640px的psd图设计稿得出某span其字号为28px那么我们可以这么布局123span&#123; font-size:28 / 32rem;/*rem与数字之间不能有空格*/&#125; （因为该在640px图中为28px，分成20份之后一份为32px，算其在640px中占几份，再乘上rem单位）同理，如果某div宽度为220px(640px设计稿环境下)，那么其宽度为220 / 32rem这样rem+媒体查询的布局就已经完成了。rem布局还可以通过js动态查询clientwidth来进行html根节点的font-size赋值，由于js在老机型上有滞后性，个人比较喜欢通过@media的 媒体查询方式来进行rem布局。 tips:在移动端页面头部引入1&lt;meta name=\"viewport\" content=\"maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0\"/&gt; 后，再引入以下js 12345678910111213(function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 100 * (clientWidth / 640) + 'px'; //这里的640 是根据设计稿的宽度来订的，设计稿宽度如果是750，64就改成750，很简单 &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window); 就无须再担心不同屏幕的适配问题了!~ 二、psd切图方式有很多，个人常用的方式为基于参考线的切片 首先在ps中： 视图-&gt;标尺 勾上 再拖拽标尺，将需要切片的元素选中 选中切片工具，点击上方的基于参考线的切片按钮，这样就会根据我们的参考线生成n个切片。 文件-&gt;存储为web所用格式，格式选择png-24，直接存储到本地。就是我们需要的切图了。 三、svg转图标字体1、让UI协助导出svg图片2、借助第三方软件或工具生成字体图标字体图标网站有很多，比如阿里妈妈，IcoMoon等，个人喜欢IcoMoon. 2.1 进入IcoMoon网站，点选IcoMoon App按钮选择Import Icons，将本地的svg素材上传。这里可以对我们的svg进行选中、删除、移动、修改。选择选中按钮再将所有的svg选中后，点击右下角Generate Font按钮这样svg就转换好了，但是我们可以发现，图标和文字不能对齐，所以我们要设置下，在这里建议将图标名(图标后的文字即为引用图标名)临时改为中文，因为我们还是要和中文对齐的。该为中文后点击Perferences，可以设置整套字体名、是否支持IE系列、和最重要的baseline height，调整到合适的位置(个人喜欢16.25),后别忘了把我们临时改的中文再改回该图标原来的英文图标名，毕竟我们要在页面中引用class的最终点击右下角的download即可下载。 下载完毕后，我们需要的是fonts目录和style.css文件，拷贝到我们的css目录下如果我们用less可以把我们css目录下的style.css文件改名为style.less方便引用(最后再统一less编译)在index.less中导入了style.less文件后就可以愉快地使用字体图标了！1@import 'fonts.less'; IcoMoon为我们生成了一个demo.html 文件，可以在其中查找图标的class类名，直接给dom元素添加class即可（设置大小颜色用font-size和color）","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"移动端web开发常见问题总结","date":"2017-05-11T15:42:03.000Z","path":"2017/05/11/移动端web开发常见问题总结/","text":"常见问题1、移动端如何定义字体font-family三大手机系统的字体： ios 系统默认中文字体是Heiti SC默认英文字体是Helvetica默认数字字体是HelveticaNeue无微软雅黑字体 android 系统默认中文字体是Droidsansfallback默认英文和数字字体是Droid Sans无微软雅黑字体 winphone 系统默认中文字体是Dengxian(方正等线体)默认英文和数字字体是Segoe无微软雅黑字体 各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持 移动端定义字体的代码 1body&#123;font-family:Helvetica;&#125; 2、移动端字体单位font-size选择px还是rem对于只需要适配手机设备，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考：123456789101112131415161718192021222324252627282930313233343536html &#123;font-size:10px&#125;@media screen and (min-width:480px) and (max-width:639px) &#123; html &#123; font-size: 15px &#125;&#125;@media screen and (min-width:640px) and (max-width:719px) &#123; html &#123; font-size: 20px &#125;&#125;@media screen and (min-width:720px) and (max-width:749px) &#123; html &#123; font-size: 22.5px &#125;&#125;@media screen and (min-width:750px) and (max-width:799px) &#123; html &#123; font-size: 23.5px &#125;&#125;@media screen and (min-width:800px) and (max-width:959px) &#123; html &#123; font-size: 25px &#125;&#125;@media screen and (min-width:960px) and (max-width:1079px) &#123; html &#123; font-size: 30px &#125;&#125;@media screen and (min-width:1080px) &#123; html &#123; font-size: 32px &#125;&#125; 3、什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/212//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125; 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 4、viewport模板12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt; sublime里使用meta:vp然后tab即可 5、优先使用最新版本 IE 和 Chrome1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; 6. 添加到主屏后的标题（IOS）1&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; 7. 启用 WebApp 全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）12&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;meta name=\"apple-touch-fullscreen\" content=\"yes\" /&gt; 8. 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：1&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; 9. 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在 “apple-mobile-web-app-capable” content=”yes” 时生效1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; content 参数：default ：状态栏背景是白色。black ：状态栏背景是黑色。black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 10. 移动端手机号码识别（IOS）在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：7位数字，形如：1234567带括号及加号的数字，形如：(+86)123456789双连接线的数字，形如：00-00-0011111位数字，形如：13800138000可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 开启电话功能1&lt;a href=\"tel:123456\"&gt;123456&lt;/a&gt; 开启短信功能：1&lt;a href=\"sms:123456\"&gt;123456&lt;/a&gt; 11. 移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：1&lt;meta content=\"email=no\" name=\"format-detection\" /&gt; 同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：1&lt;a mailto:dooyoe@gmail.com\"&gt;dooyoe@gmail.com&lt;/a&gt; 12、ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩123a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0)&#125; 13、部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0) -webkit-user-modify:read-write-plaintext-only; &#125; -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签 14、winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; 15、webkit表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125; 16、webkit表单输入框placeholder的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 17、webkit表单输入框placeholder的文字能换行么ios可以，android不行~ 18、关闭iOS键盘首字母自动大写在iOS中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样：1&lt;input type=\"text\" autocapitalize=\"off\" /&gt; 19、关闭iOS输入自动修正和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉：1&lt;input type=\"text\" autocorrect=\"off\" /&gt; 20、禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：123html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport。 21、移动端如何清除输入框内阴影在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：12345input,textarea &#123; border: 0; -webkit-appearance: none; &#125; 22、屏幕旋转的事件和样式window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；1234567891011window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125;&#125; 样式12345678//竖屏时使用的样式@media all and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式@media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; 23、audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播123$('html').one('touchstart',function()&#123; audio.play()&#125;) 24、摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 25、手机拍照和上传图片1234567&lt;input type=\"file\"&gt;的accept 属性&lt;!-- 选择照片 --&gt;&lt;input type=file accept=\"image/*\"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept=\"video/*\"&gt; 使用总结：ios 有拍照、录像、选取本地图片功能部分android只有选取本地图片功能winphone不支持input控件默认外观丑陋 26、消除transition闪屏123456.css&#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden;&#125; 开启硬件加速解决页面闪白保证动画流畅123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 设计高性能CSS3动画的几个要素尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位利用translate3D开启GPU加速 27、android 上去掉语音输入按钮123input::-webkit-input-speech-button &#123; display: none&#125; 28、模拟按钮hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;&lt;style type=\"text/css\"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"btn-blue\"&gt;按钮&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;document.addEventListener(\"touchstart\", function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 框架1、移动端基础框架zepto.js 语法与jquery几乎一样，会jquery基本会zepto~iscroll.js 解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~underscore.js 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。fastclick 加快移动端点击响应时间animate.css CSS3动画效果库Normalize.css Normalize.css是一种现代的、CSS reset为HTML5准备的优质替代方案 2、滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果slip.jsiSlider.jsfullpage.jsswiper 3、瀑布流框架masonry 工具推荐caniuse 各浏览器支持html5属性查询paletton 调色搭配","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"前端构建工具总结","date":"2017-05-11T01:43:58.000Z","path":"2017/05/11/前端构建工具总结/","text":"一、bower基于NodeJS的一个静态资源管理工具，由twitter公司开发维护，解决大型网站中静态资源的依赖问题。 准备工作 【依赖NodeJS环境和git工具】 安装node环境： node.js官网 安装npm下载npm源码包git clone --recursive git://github.com/isaacs/npm.gitcd 到 npm的代码文件夹下，使用以下命令安装node cli.js install npm -gf 安装Git，bower需要从远程git仓库获取代码包，所以依赖git环境：Git笔记 安装bower使用npm，打开终端，输入：npm install -g bower其中-g命令表示全局安装 如果未翻墙，可在最后加--registry=https://registry.npm.taobao.org使用淘宝镜像 bower命令 bower search 静态资源名 查找资源信息、版本 bower install 静态资源名[#版本] –save下载资源，通过#号可以指定版本号–save参数是保存配置到bower.json文件中 bower info 静态资源名查看资源信息比如我们想要查找jquery都有哪些个版本，输入如下命令：bower info jquery会看到jquery的bower.json的信息，和可用的版本信息 bower uninstall 静态资源名 卸载（删除）资源 bower init初始化（在windows下只能使用cmd来操作），用来记录资源信息及依赖。使用bash会报错bower init会初始化，同时在该目录生成bower.json文件用来保存该项目的配置 包的更新上面安装的是最新版的高版本jquery，假如想要兼容低版本浏览器的呢？已经查到兼容低版本浏览器的jquery版本为1.11.3，下面直接修改bower.json文件中的jquery版本号如下： 123\"dependencies\": &#123; \"jquery\": \"~1.11.3\"&#125; 然后执行如下命令： bower updatebower就会切换jquery的版本 版本号的一种定义规则叫做Semantic Versioning 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改，次版本号：当你做了向下兼容的功能性新增，修订号：当你做了向下兼容的问题修正。先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸 对于模块版本号管理 *: 任意版本1.1.0: 指定版本，写死的~1.1.0: &gt;=1.1.0 &amp;&amp; &lt; 1.2.0^1.1.0: &gt;=1.1.0 &amp;&amp; &lt; 2.0.0 对与~和^ ~ 前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本。^ 前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会 匹配到 y 和 z 都是最新的版本。特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z 二、Gulp多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的，不同的模块需要不同的处理插件，可以用gulp来进行管理 使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析； 合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能； 这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。 常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack Gulp安装全局安装 npm install -g gulp 【为了在命令行可以使用gulp命令】 Gulp基础 npm init 初始化 会自动生成package.json来记录npm依赖关系 本地安装gulp 【具体的某个任务目录来具体安装】进入项目根目录执行npm install gulp –save-dev（添加–save-dev会在package.json记录依赖关系）。Tips:安装的模块会保存在node_modules文件夹里。如果不小心删除了该文件夹，只要package.json文件在，就可以根据其记录的依赖利用npm install来下载所有package.json文件里记录的module 任务清单在项目根目录中创建gulpfile.js（这是一个配置文件）【名称固定死的】 定义任务在gulpfile.js定义构建任务，如压缩、合并，Gulp自身并不执行任何任务，是通过调用具体插件来完成的。以编译LESS为例，安装npm install gulp-less，如下图定义任务 执行任务输入命令 gulp less 【用全局的gulp命令来执行当前目录下的less任务】这样我们的LESS文件便会编译成CSS了。 Gulp工作原理通过不同的插件实现构建任务，Gulp只是按着配置文件调用执行了这些插件。 Gulp APIGulp是基于NodeJS的，通过require可以引入一个NodeJS的包（模块），其作用类似于浏览器中的script标签引入资源，被引入的包存放在node_modules目录下。 引入gulp包（模块）后返回一个对象，习惯赋值给变量gulp，通过该对象提供的方法（API）完成任务的配置。 gulp.task() 定义各种不同的任务，如下图有两个参数不同任务间存在依赖关系时，可以指定依赖，如下图 gulp.src() 需要构建资源的路径，字符串或数组（可以填正则表达式） gulp.pipe() 管道，将需要构建的资源“输送”给插件。 gulp.dest() 构建任务完成后资源存放的路径（会自动创建） gulp.watch() 常用Gulp插件gulp-less 编译LESS文件gulp-autoprefixer 添加CSS私有前缀gulp-cssmin 压缩CSSgulp-rname重命名gulp-imagemin 图片压缩gulp-uglify 压缩Javascriptgulp-concat 合并gulp-htmlmin 压缩HTMLgulp-rev 添加版本号【把静态文件内容字符串md5加密，文件有改动，md5串就会变化，截取一部分md5串给文件名命名，让修改过后的静态文件不会因为浏览器缓存而读取不了base.css -&gt; base-e972672397.css】gulp-rev-collector 内容替换【因为静态资源名改变了，html里引入的名也得改变】gulp-userefgulp-ifGulp-autoprefix Gulp常见使用实例准备工作 在工作路径新建gulpfile.js 文件用来定义Gulp的任务 使用Gulp的插件需要先在工作路径安装插件npm install gulp-插件名插件会安装在node_modules 文件夹中 在gulpfile.js 文件头部引入下载好的需要使用的gulp插件变量名可以自己定义，后面的gulp.task中填该变量名即可 定义任务 编译less成css并压缩,添加私有化前缀、css文件添加rev版本号并利用gulp-rev-collector来将html中引用的css文件名替换成rev模式 压缩图片 压缩JavaScript 简单合并文件，只能合并，不能修改引用路径 压缩html Css自动加上私有化前缀 合并页面中的Js或者Css文件并修改html中的引用名需要先在html文件中添加注释来注明需要合并和修改html中的引用名的文件以JavaScript为例gulpfile.json Gulp构建任务流程实例开发完毕的工作路径构建目标： 构建完毕的目录在当前的release目录，上线时直接用构建完毕的release目录即可 处理css：less转css、压缩、加私有化前缀、rev缓存名修改、html引用名修改 处理图片：压缩、rev缓存名修改、html引用名修改 处理js：html里引用的多个js合并，减少客户端请求次数、压缩js、rev缓存名修改、html引用名修改 将api、public下的公共静态资源不需要修改的直接gulp-copy到release文件夹中 开始构建 一、创建release分支先git创建release分支，在release分支上进行构建测试git checkout -b release 二、创建Gulp初始环境npm init创建完毕后工作目录会出现package.json，该文件记录所有安装Gulp插件记录及其依赖 三、安装各种需要的Gulp插件 [最好在cmd运行命令，能看到进度条,bash看不了进度条]PS：第一个先安装Gulpnpm install gulp --save-devnpm install gulp-less --save-devnpm install gulp-cssmin --save-devnpm install gulp-autoprefixer --save-devnpm install gulp-rev --save-devnpm install gulp-imagemin --save-devnpm install gulp-useref --save-devnpm install gulp-if --save-devnpm install gulp-uglify --save-devnpm install gulp-rename --save-devnpm install gulp-rev-collector --save-dev安装完毕后，package.json文件中也会记录下这些插件的安装记录及其依赖 四、创建任务清单文件 工作根路径touch gulpfile.js 五、编写任务清单[注：以下提到的rev名即为通过gulp-rev插件后改的md5文件名] 5.1 引入、声明gulp插件 5.2 处理css因为页面引用路径是在less下的，所以我们要注释配置下，改到(合并)css下 5.3 处理图片 5.4 处理js 先对待修改的html页面进行注释配置 在编写task 5.5 其他资源存到release里 5.6 给所有之前rev改名后的文件一起修改其在html中的引用路径名 在这个task任务中，由于依赖了其他模块，即等’css’,’image’,’js’任务完成完毕后再执行改引用名操作，但是由于gulp处理task是异步的，经常会导致依赖的任务还没完成就改名完毕了，这是不合理的，所以在所有他依赖的task任务中，给function 加上返回值，即在他依赖的task任务gulp.src(‘…’)前加上return 5.7 添加默认任务 填写完毕就可以在项目根目录(gulpfile.js文件目录)执行gulp命令了。gulp 任务名由于我们指定了default任务，所以可以直接 gulp 启动任务 激动人心，终于完成了任务的构建 完成了以后，可以直接使用release文件夹里的构建完毕的内容上线 六、 git分支合并、提交 由于使用了gulp和bower安装了大量的类库、插件，同时gulp的配置文件也不需要上传，所以需要编写.gitignore文件后再完成git分支合并、提交。 touch .gitignore 填写完毕后 进行git分支合并、提交 在我们进行release开发的release分支下 git status git add -A git commit -m &#39;完成了项目构建&#39; git checkout developer git merge release git branch -d release git push origin developer","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Content-Type决定服务端数据提取方式","date":"2017-05-07T03:16:40.000Z","path":"2017/05/07/Content-Type决定服务端数据提取方式/","text":"HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。协议规定 POST 提交的数据必须放在消息主体（entity-body）中,而消息主体的格式可以自行定义。而服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。 1. application/x-www-form-urlencoded【formData】传递的数据是’key=val&amp;key=val’形式，这种形式叫formData这是最常见的 POST 提交数据的方式。浏览器的原生 form 表单，如果不设置 enctype 属性，默认以 application/x-www-form-urlencoded 方式提交数据。请求类似于123POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。 jQuery的Ajax，Content-Type默认值是application/x-www-form-urlencoded;charset=utf-8 2. multipart/form-data使用表单上传文件时，必须设定form的enctype为该值 123456789101112131415POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA--content-ty 生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 3. application/json【Request Payload】现在该请求头越来越流行，直接传json对象，该请求头用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数。 Json 格式支持比键值对复杂得多的结构化数据，当然也可以把数据先 JSON 序列化之后，然后再将序列化后的字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。这样传输的文本节省流量，服务器接收了可以后台解析。 在AngularJS 中的$http服务，默认提交的数据格式就是 JSON 字符串。 最终发送的请求是： POST http://localhost:8000/exmple.php HTTP/1.1Content-Type: application/json;charset=utf-8 这种方案，可以方便的提交复杂的结构化数据，很适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但是这种方式有些服务器语言接收不是很方便，比如Java需要request.getReader();得到BufferedReader，然后再读取流存入String，利用jackson、json-lib等进行解析成jsonObject对象读取数据。php 也无法通过 $_POST对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。 解决方式：服务端接收的是一个Json对象的字符串而不是直接的Json对象，可以在传输数据时选择JSON.stringify(jsonData);先将json对象转成字符串，指定dataType:”json”,contentType:”application/json” ,如果是springmvc后台可以直接 public void saveUser(@RequestBody List&lt;User&gt; users) { userService.batchSave(users); } 来绑定对象或者List 当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。 ###注意：json一般更多用来返回数据而不是在提交数据的时候使用，通常Restful服务都会支持json/xml格式的返回数据。 对于application/x-www-form-urlencoded和application/json;charset=utf-8的选择 如果数据是简单、平面的key-value数值对，那么使用www-form-urlencoded简单实用，后台直接根据key取值，不需要额外的编解码； 如果数据是复杂的嵌套关系，有多层数据，那么使用json会简化数据的处理，从而更高效。 总结： 一般发送数据给服务端用application/x-www-form-urlencoded,方便服务端读取接收，但是如果是结构复杂或者数组对象，那就选择application/json,再传JSON.stringify后的json对象字符串，类似于springmvc后台对json有很好支持的可以直接@RequestBody绑定对象或者List，如果后台对Json数据读取支持不好，可以选择用application/x-www-form-urlencoded，再将stringify后的json字符串对象作为val存入键值对，后台可以很方便的根据key得到json字符串再解析。不建议直接传未序列化过的json对象，这样后台还得从request里去获取原始输入流，转成String后再转成JsonObject对象再读取，效率太低。 服务端返回数据使用application/json ，便于前台解析展示。 误区解释： 之前JQuery发送Ajax的application/x-www-form-urlencoded请求，用的都是data:json格式来传递数据，其实这是JQuery的一个封装，为了我们书写方便阅读性强。虽然我们给的是json格式，可是他底层将其遍历解析转换成了key=val&amp;key=val的格式来传递 4. text/plain数据以纯文本形式进行编码，其中不含任何控件或格式字符。一般通过request.InputStream或者request.getReader，从流中提取出数据 5. text/xml它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。不过个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 和键值对会更灵活方便。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"AngularJS学习","date":"2017-05-07T03:16:02.000Z","path":"2017/05/07/AngularJS学习/","text":"一、特点&emsp;&emsp;AngularJS与jQuery是有一定的区别的，jQuery更准确来说只一个类库（类库指的是一系列函数的集合）以DOM做为驱动（核心），而AngularJS则一个框架（诸多类库的集合）以数据和逻辑做为驱动（核心）。框架对开发的流程和模式做了约束，开发者遵照约束进行开发，更注重的实际的业务逻辑。AngularJS有着诸多特性，最为核心的是：模块化、双向数据绑定、语义化标签、依赖注入等。与之类似的框架还有BackBone、KnockoutJS、Vue、React等。 二、模块化 控制器、模型 页面视图 三、指令&emsp;&emsp;传统的HTML书写页面(应用)存在诸多不足之处，比如没有循环、if判断、switch等结构，之前一般会使用JSP的jstl标签库或者导入页面模版js来强化html结构。AngularJS也可以通过扩展一系列的HTML属性或标签来弥补这些缺陷，所谓指令就是AngularJS自定义的HTML属性或标签，这些指令都是以ng-做为前缀的，例如ng-app、ng-controller、ng-repeat等。 3.1 内置指令为AngularJS定义好的指令，可以直接使用，这里整理了部分常用内置指令 ng-app 指定应用根元素，至少有一个元素指定了此属性。 ng-controller 指定控制器 ng-show控制元素是否显示，true显示、false不显示 ng-hide控制元素是否隐藏，true隐藏、false不隐藏 ng-if控制元素是否“存在”，true存在、false不存在 ng-src增强图片路径 防止加载dom结构时未加载到Angular不识别&#123;&#123;&#125;&#125;导致不好看 ng-href增强地址 同上 ng-class控制类名 ‘{类名 : true / false}’ 来控制该class样式是否使用 ng-include引入模板 就是相当于 jsp:include标签，直接引用一个页面 ng-disabled ‘true/false’ 表单禁用 ng-readonly ‘true/false’ 表单只读 ng-checked ‘true/false’ 单/复选框表单选中 ng-selected ‘true/false’ 下拉框表单选中 注意：① ng-src、ng-href 等都是对该原标签的加强。因为先加载dom结构，此时AngularJS还未加载，不识别&#123;&#123;&#125;&#125;里的元素，导致src和href之类无法加载，图片会出现未加载的样式，很丑。所以使用ng-src等，在加载dom结构时因为不识别ng-src和ng-href之类，就不会去服务器加载该路径文件，等到AngularJS加载完毕后，他底层会把ng-src里的内容解析成真正的内容同时给该标签添加一个html识别的src属性填充进去，然后再次渲染。 ② ng-include 直接浏览器运行会报错，因为js不能加载本地文件！只有后端语言才可以读取本地文件1XMLHttpRequest cannot load file:///C:/Users/Administrator/Desktop/SublimeWorkSpace/AngularJS/header.html. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https 但是放在服务器环境运行，可以完成导入页面。因为ng-include的原理就是ajax异步请求页面资源，服务器返回html文件，再拼装 要和iframe区分开，iframe独立成页，单独执行；而ng-include是服务器将两个页面合并成一个页面解释后发送到客户端,对于浏览器来说他见到的就是一个页面而已，所以类include指令都要加载本地文件! ③ ng-class还可以写表达式，如ng-class=”{active:type===’M’}”，当model的type为M的时候为true，active的样式就显示 3.2 自定义指令AngularJS允许根据实际业务需要自定义指令，通过angular全局对象下的directive方法实现。 四、数据绑定&emsp;&emsp;AngularJS是以数据做为驱动的MVC框架，所有模型（Model）里的数据经由控制器（Controller）展示到视图（View）中。所谓数据绑定指的就是将模型（Model）中的数据与相应的视图（View）进行关联，分为单向绑定和双向绑定两种方式。 4.1 单向绑定&emsp;&emsp;单向数据绑定是指将模型（Model）数据，按着写好的视图（View）模板生成HTML标签，然后追加到DOM中显示，如之前所学的artTemplate 模板引擎和JSP页面的工作方式，只能模型（Model）数据向视图（View）传递。 4.2 双向绑定&emsp;&emsp;双向绑定则可以实现模型（Model）数据和视图（View）模板的双向传递，模型数据的改变会使视图的数据也改变，视图数据的改变也会让模型数据改变。 4.3 相关指令1.数据绑定指令 模型（Model）数据向视图模板（View）的绑定&#123;&#123; &#125;&#125;ng-bind指令 模型数据通过一个内置服务$scope来提供，这个$scope是一个空对象，通过为这个对象添加属性或者方法便可以在相应的视图（View）模板里被访问。 注：“&#123;&#123;&#125;&#125;”是ng-bind的简写形式，其区别在于通过“&#123;&#123;&#125;&#125;”绑定数据时会有“闪烁”现象，添加ng-cloak也可以解决“闪烁”现象，通过ng-bind-template可以绑定多个数据。 表单元素添加ng-model指令视图（View）模板向模型（Model）数据的绑定。 1&lt;input type=\"text\" ng-model=\"name\"&gt; ng-init 为控制器初始化一个模型,注意格式为key=val;key=val2.事件绑定指令对于js中大部分事件进行了增强，只需要再前部加上ng-即可，这些事件也可以传参，如 1ng-click=\"check('M')\" 3.ng-repeat、ng-switch 理解：与传统的switch when比较12345switch () -这里是ng-switch on case '': -这里是when ... case '': ... 五、作用域5.1 根作用域ng-app指令的标签内就是根作用域，ng-app上的模型全局都能访问到 5.2 子作用域通过ng-controller指令可以创建一个子作用域，新建的作用域可以访问其父作用域的数据访问规则同JavaScript等，父作用域不能访问子作用域内容，子作用域可以访问父作用域内容，如果子作用域有数据优先使用自己的，没有就去父级查找 六、过滤器AngularJS中使用过滤器格式化展示数据，在“&#123;&#123;&#125;&#125;”中使用“|”来调用过滤器，使用“:”传递参数。 6.1 内置过滤器 1、currency将数值格式化为货币格式 ： ￥ 2、date日期格式化，年（y）、月（M）、日（d）、星期（EEEE/EEE）、时（H/h）、分（m）、秒（s）、毫秒（.sss），也可以组合到一起使用。 3、filter在给定数组中选择满足条件的一个子集，并返回一个新数组，其条件可以是一个字符串、对象、函数,如果是对象要和最后的｝加一个空格间隔 4、json将Javascrip对象转成JSON字符串。 5、limitTo取出字符串或数组的前（正数）几位或后（负数）几位 : 位数 6、lowercase将文本转换成小写格式 7、uppercase将文本转换成大写格式 8、number数字格式化，可控制小位位数 : 位数 9、orderBy对数组进行排序 ： 排序字段 true/false 6.2 自定义过滤器除了使用AngularJS内建过滤器外，还可以根据业务需要自定义过滤器，通过模块对象实例提供的filter方法自定义过滤器。 七、依赖注入依赖注入是指在运行时自动查找依赖关系，然后将查找到依赖传递给使用者的一种机制。常见的AngularJS内置服务有$http、$location、$timeout、$rootScope等 7.1 推断式注入没有明确声明依赖，AngularJS会将函数参数名称当成是依赖的名称。这种方式会带来一个问题，当代码经过压缩后函数的参数被压缩，这样便会造成依赖无法找到。 7.2 行内注入以数组形式明确声明依赖，数组元素都是包含依赖名称的字符串，数组最后一个元素是依赖注入的目标函数。 推荐使用这种方式声明依赖 八、服务服务是一个对象或函数，对外提供特定的功能。 8.1 内置服务1、$location是对原生Javascript中location对象属性和方法的封装。2、$timeout&amp;$interval对原生Javascript中的setTimeout和setInterval进行了封装。3、$filter格式化数据。4、$log打印调试信息5、$http用于向服务端发起异步请求。 AngularJS不设置的话默认Content-Type为application/json;charset=utf-8，为了方便的提交复杂的结构化数据，特别适合 RESTful 的接口 get方式请求post方式请求 注意：1.get方式用params传递数据,post方式用data传递数据。 2.post方式需要声明headers的content-type为application/x-www-form-urlencoded，即经过编码为key=val&amp;key=val的格式 3.application/x-www-form-urlencoded即告诉服务器，传递数据格式为key=val&amp;key=val，所以在AngularJS中post传递数据用的data值不能为json对象格式，而应该为key=val的字符串 4.为什么post时data值需要用字符串呢？因为get请求默认content-type就是application/x-www-form-urlencoded，他将key=val&amp;key=val拼接在了url后 而post请求默认是text/plain格式，如果需要传数据要手动转成application/x-www-form-urlencoded，他将key=val&amp;key=val拼接在了请求体里即Form data里 在这里有一个误区，之前JQuery发送Ajax的application/x-www-form-urlencoded请求，用的都是data:json格式来传递数据，其实这是JQuery的一个封装，为了我们书写方便阅读性强。虽然我们给的是json格式，可是他底层将其遍历解析转换成了key=val&amp;key=val的格式来传递，而AngularJS默认传json数据，不提供这种转换，他会直接把json数据当成key，val值为空传递，导致服务端报错，所以我们还是直接写key=val字符串直接传，省去转换的麻烦了吧 $http服务同时还支持多种快捷方式如$http.get()、$http.post()、$http.jsonp 6、$http的jsonp传输 需要指定method为jsonp，同时，在params里定义{ callback: ‘JSON_CALLBACK’ }。对于callback的定义可以在params里，也可以在请求的url后callback可以任意命名，但是后面的JSON_CALLBACK不可以改变。这个名称在AngularJS发出请求时，会自动将JSON_CALLBACK替换成一个唯一的函数名，比如：“callback=angular.callbacks._0”，这个可以通过浏览器debug模式查看. 返回数据必须放在JSON_CALLBACK (json数据)里面。注意：JSON_CALLBACK 必须是angularjs把你的JSON_CALLBACK 替换后的值，如：angular.callbacks._0，假设你请求到后台，你可以先获取到callback这个参数的值，然后把组装你要返回的json数据。eg: 假设是SpringMVCString callback = request.getParameter(“callback”);JSONObject json =new JSONObject();json.put(“id”, “123456”);json.put(“username”, “hhaip”);json.put(“age”, 25);json.put(“sex”, “男”);return callback+”(“+json+”)”; 8.1 自定义服务通过上面例子得知，所谓服务是将一些通用性的功能逻辑进行封装方便使用，AngularJS允许将自定义服务,有factory、service、value方法来自定义服务。 factory方法举例：使用： service方法举例：（ng-app省略了） value方法定义常量 服务本质就是一个对象或函数，所以自定义服务就是要返回一个对象或函数以供使用。 九、模块加载AngularJS模块可以在被加载和执行之前对其自身进行配置。我们可以在应用的加载阶段配置不同的逻辑。 9.1 配置块通过config方法实现对模块的配置，AngularJS中的服务大部分都对应一个“provider”，用来执行与对应服务相同的功能或对其进行配置。比如$log、$http、$location都是内置服务，相对应的“provider”分别是$logProvider、$httpProvider、$locationPorvider。下图以$log为例进行演示，通过其$logProvider修改了$log服务的配置下图以$ngRoute为例进行演示，通过其$routeProvider对路由进行了配置 9.1 运行块服务也是模块形式存在的对且对外提供特定功能，前面学习中都是将服务做为依赖注入进去的，然后再进行调用，除了这种方式外我们也可以直接运行相应的服务模块，AngularJS提供了run方法来实现。【就像eclipse中的run application】 【不但如此，run方法还是最先执行的，利用这个特点我们可以将一些需要优先执行的功能通过run方法来运行，比如验证用户是否登录，未登录则不允许进行任何其它操作。】运行块App.run多运用在AngularJS构建的应用中的加载机制，由于是最先执行的，相当于程序的入口，在该方法中进行一些http请求和$rootScope 等的初始化。 十、路由一个应用是由若个视图组合而成的，根据不同的业务逻辑展示给用户不同的视图，路由则是实现这一功能的关键。 10.1 SPASPA（Single Page Application）指的是通单一页面展示所有功能，通过Ajax动态获取数据然后进行实时渲染，结合CSS3动画模仿原生App交互，然后再进行打包（使用工具把Web应用包一个壳，这个壳本质上是浏览器）变成一个“原生”应用。在PC端也有广泛的应用，通常情况下使用Ajax异步请求数据，然后实现内容局部刷新，局部刷新的本质是动态生成DOM，新生成的DOM元素并没有真实存在于文档中，所以当再次刷新页面时新添加的DOM元素会“丢失”，通过单页面应可以很好的解决这个问题。 10.2 路由在后端开发中通过URL地址可以实现对用户请求的处理，导致页面（视图）的切换，但是AngularJS是一个纯前端MVC框架，在开发单页面应用时，所有功能都在同一页面完成，所以无需切换URL地址（即不允许产生跳转），但Web应用中又经常通过链接（a标签）来更新页面（视图），当点击链接时还要阻止其向服务器发起请求，通过锚点（页内跳转）可以实现这一点。实现单页面应用需要具备：a、只有一页面b、链接使用锚点页面：(a链接使用锚点)JavaScript：通过上面的例子发现在单一页面中可以能过hashchange事件监听到锚点的变化，进而可以实现为不同的锚点准不同的视图，单页面应用就是基于这一原理实现的。AngularJS对这一实现原理进行了封装，将锚点的变化封装成路由（Route）,这是与后端路由的根本区别。在1.2版前路由功能是包含在AngularJS核心代码当中，之后的版本将路由功能独立成一个模块，需要下载导入angular-route.js 10.2.1 使用1、引入angular-route.js2、实例化模块（App）时，当成依赖传进去（模块名称叫ngRoute）。3、配置路由模块4、布局模板通过ng-view指令布局模板，路由匹配的视图会被加载渲染到些区域。 10.2.1 路由参数 提供两个方法匹配路由，分别是when和otherwise，when方法需要两个参数，otherwise方法做为when方法的补充只需要一个参数，其中when方法可以被多次调用。设置:id和:type来匹配url里的路由参数路由里可以传参数$routeParams 服务可以获取路由参数，$routeParams存的就是json对象，可以直接使用他效果展示： 十一、jQuery Lite11.1. 介绍AngularJS强化了前端的MVC逻辑，却弱化了Jquery的Dom操作能力。好在Angular自身也考虑到这个问题，所以它自身内置了jqLite来弥补这方面的不足。 为了项目的精简性，使用了ng有时候不想再引入jq，在没有引入jQuery的前提下AngularJS实现了简版的jQuery Lite，通过angular.element不能选择元素，但可以将一个DOM元素转成jQuery对象，如果引提前引入了jQuery则angular.element则完全等于jQuery。 一般使用angular.element将原生dom对象转成jq对象，可以调用AngularJS实现的部分jq方法。 11.2. 使用 angular.element() 参数要求是HTML string or DOMElement, angular.element 虽然很接近 jQuery，但是直接通过 HTML tag 去获取元素还是不行的，最简单的办法是这样：12var $p = angular.element(document.querySelectorAll('p'));var $box = angular.element(document.querySelector('.box')); 注：querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果需要返回所有的元素，可以使用 querySelectorAll() 方法。 11.2.3 jqlite只实现了以下的jQuery方法 addClass() after() append() attr() - 不支持函数作为参数 bind() - 不支持命名空间，选择器或事件数据 children() - 不支持选择器 clone() contents() css() -只有将内联样式，不叫getcomputedstyle() data() detach() empty() eq() find() - 通过标签名称限定查找 hasClass() html() next() - 不支持选择器 on() - 不支持命名空间，选择器或事件数据 off() - 不支持命名空间或选择器 one() - 不支持命名空间或选择器 parent() - 不支持选择器 prepend() prop() ready() remove() removeAttr() removeClass() removeData() replaceWith() text() toggleClass() triggerHandler() - 通过一个虚拟事件对象来处理。 unbind() - 不支持命名空间 val() wrap()","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/tags/AngularJS/"}]},{"title":"Git笔记","date":"2017-05-02T16:17:43.000Z","path":"2017/05/03/Git笔记/","text":"零、Git命令汇总 git config配置本地仓库 常用git config –global user.name、git config –global user.email git config –list查看配置详情 git init 初始一个仓库，添加–bare可以初始化一个共享（裸）仓库 git status 可以查看当前仓库的状态 git add“文件” 将工作区中的文件添加到暂存区中，其中file可是一个单独的文件，也可以是一个目录、“*”、-A git commit -m ‘备注信息’ 将暂存区的文件，提交到本地仓库 git log 可以查看本地仓库的提交历史 git branch查看分支 git branch“分支名称” 创建一个新的分支 git checkout“分支名称” 切换分支 git checkout -b deeveloper 创建并切到developer分支(加了-b就先创建再切换) git merge“分支名称” 合并分支 git branch -d “分支名称” 删除分支 git clone “仓库地址”获取已有仓库的副本 git push origin “本地分支名称:远程分支名称”将本地分支推送至远程仓库， git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix git push origin hotfix:newfeature 本地仓库分支名称和远程仓库分支名称一样的情况下可以简写成一个，即git push “仓库地址” “分支名称”，如果远程仓库没有对应分支，将会自动创建 git remote add “主机名称” “远程仓库地址”添加远程主机，即给远程主机起个别名，方便使用 git remote 可以查看已添加的远程主机 git remote show “主机名称”可以查看远程主机的信息 一、Bash常见指令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory) 切换目录，如 cd /etc ls (List) 查看当前目录下内容，如 ls -al mkdir (Make Directory) 创建目录，如 mkdir blog touch 创建文件，如 touch index.html cat 查看文件全部内容，如 cat index.html more/less 查看文件，如more /etc/passwd、less /etc/passwd rm (remove) 删除文件，如 rm index.html、rm -rf blog rmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用 mv (move) 移动文件或重命名，如 mv index.html ./demo/index.html cp (copy) 复制文件，cp index.html ./demo/index.html head 查看文件前几行，如 head -5 index.html tail 查看文件后几行 –n –f，如 tail index.html、tail -f -n 5 index.html tab 自动补全，连按两次会将所有匹配内容显示出来 history 查看操作历史 “&gt;” 和 “&gt;&gt;” 重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加 wget 下载，如wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz tar 压缩命令，x:解压 c:创建压缩包 z: gzip j：bzip2 v:view f:file后接文件名 -C:指定路径 eg:tar -czvf 文件名.tar.gz 目录 //创建一个文件在该目录 tar -czvf code.tar.gz ./ tar -xzvf 文件名.tar.gz -C 路径 //解压到那个路径 tar -xzvf code.tar.gz -C ./code curl 网络请求，如curl http://www.baidu.com whoami 查看当前用户 | 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。 grep 匹配内容，一般结合管道符使用 二、SSHSSH是一种网络协议，用于计算机之间的加密登录。 12格式：ssh user@host user 代表真实存在的用户host代表要登录的远程计算机ip地址 常见有两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者(非对称性加密)。 对称加密算法在加密和解密时使用的是同一个密钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。 工作原理公钥和私钥是成对出现，可以通过ssh-keygen -t rsa -C ‘your@mail.com’来创建，既可以通过密钥来加密数据，也可以通过私钥来加密数据，如果是以公钥进行的数据加密，只能与之相对应的私钥才可以解密，相反如果以私钥进行的数据加密，则只能与之对应的公钥才可以将数据进行解密，这样就可以提高信息传递的安全性。 免密码登录我们可以将本地机器上的公钥保存到特定的远程计算机上，这样当我们再次登录访问这台远程计算机时就可以实现免密码登录了。 1、ssh-keygen -t rsa会创建公钥和密钥（默认在用户目录/.ssh目录下） 2、ssh-copy-id user@host添加到对应远程主机的用户目录/.ssh目录下 3、也可以登录远程主机，进入到用户目录/.ssh目录下手动创建authorized_keys文件，并将自已的公钥粘入该文件。 GitHub、GitLab多个SSH key共存1. 新建GitHub的SSH key：12345678$ cd ~/.ssh # 切换到C:\\Users\\Administrator\\.sshssh-keygen -t rsa -C \"your@email.com\" # 新建工作的SSH key# 设置名称为id_rsa_github(这一步是给rsa文件命名的)Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_github 2. 新建GitLab的SSH key：12345678$ cd ~/.ssh # 切换到C:\\Users\\Administrator\\.ssh ssh-keygen -t rsa -C \"your@email.com\" # 新建工作的SSH key # 设置名称为id_rsa_gitlab(这一步是给rsa文件命名的) Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_gitlab 这样在C:\\Users\\Administrator\\.ssh目录下就有github和gitlab的公钥私钥了 但是这样github和gitlab是不能识别的，进行ssh登录都会报错，需要新建一个config文件来配置(直接touch config)不需要后缀名 1234567891011121314151617181920# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 这样就可以区分各自的SSHkey了。 接下来就是去github和gitlab的settings里将自己的公钥(id_rsa_gitXX.pub)添加即可 [pub结尾的是公钥，没有pub结尾的是私钥，配置只需要粘贴公钥即可] 三、Git1. 文件管理Git管理我们文件的3种状态 已提交（committed）—- Git仓库 已修改（modified）—- 工作目录 已暂存（staged）—- 暂存区域 这些都是在我们本地电脑的 2. Git基础2.1 配置用户12345678git config --global user.name \"自已的名字\"git config --global user.email \"自已的邮箱地址\"--global 配置当前用户所有仓库--system 配置当前计算机上所有用户的所有仓库 注：配置用户只需要执行1次 2.2 初始化仓库 注：后面提到的”路径”，均为 用户名@ip地址:该电脑上仓库路径 a) git init 初始化仓库后，会有.git的隐藏文件夹，windows需要开启显示隐藏文件才可以看到，bash命令行需要ls -a才可以看到。 b) git clone 路径 保存目录 (如果不写保存目录，默认以项目名为目录保存项目) 假如公司已有项目用了Git，那我们就利用克隆 Tips: git clone 命令相当于 git init + git push 路径 master + git remote add origin 路径 即先在本地初始化一个仓库有，再将远程的master分支push下来，再添加一个远程的简称origin，方便操作 2.3 查看文件状态 git status 初始化仓库后可以通过git status可以检测当前仓库文件的状态 【Untracked files】为未’跟踪’的文件，即未git add添加到暂存区的文件 2.4 添加文件到暂存区 git add 文件名/ 文件路径 “*”或-A代表所有 只有先添加进暂存区才能commit 2.5 撤销更改 git checkout 文件名 【modified】为被修改文件，并被标记了红色 如果发现某个文件有Bug，想要回到之前状态，可以使用git checkout 文件名。 12git checkout index.html 注：从暂存区还原原到工作区 2.6 提交文件 git commit -m ‘备注信息’ \u0003 2.7 查看提交历史 git log \u0006红框部分为该次提交的id，为SHA值，唯一，可通过该id唯一标识一次提交记录，同时可以通过该id来回滚 2.8 返回某次提交状态 git reset –hard 172f147d3 （可以只粘贴部分SHA值） 三、Git分支所有的提交（commit）实际上都是在分支（branch）的基础上进行的。 当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个master的分支，并且有指针（HEAD）指到了末端。 (箭头由新记录指向老记录) 指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。 我们也可以创建自已的分支 3.1 创建分支 git branch hotfix 新的分支会在当前分支原有历史版本的结点上进行创建，为子分支,新建的子分支会继承父分支的所有提交历史。 3.2 切换分支 git checkout hotfix HEAD现在又指向了hotfix的末端 3.3 再次提交 会在hotfix分支进行提交，这次的提交历史版本就会记录在hotfix这个分支上了，并且HEAD伴随hotfix在移动 3.4 切换回master分支 当我们切换回master后，HEAD指向了master分支的末端。hotfix的修改是与master隔离的(不会影响到父分支) 3.5 master继续开发原先内容再次提交 会发现master分支又有了新的提交记录，与hotfix无关 总结：1. 当我们git checkout branchname时，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。 子分支会继承父分支之前的所有提交历史 分支之间相互隔离 3.6 合并分支 git merge 欲合并分支名 这时master会有两个父结点了，master便包含了hotfix里的修复了 3.7 删除分支 git branch -d hotfix 这时用来修复BUG创建的hotfix分支已经没有用处了，我们可以将它删除。 删除分支时，如果那条分支没有合并记录，会有丢失代码的危险，所以git一般不会允许我们删除未merge的分支，会报错，可以先merge该分支再删除，也可以直接git branch -D 分支名 强行删除 四、Git远程（共享）仓库由于git是分布式的版本控制软件，可以有一个远程仓库来进行仓库共享 如何创建一个远程共享仓库呢 4.1 在远程计算机创建裸仓库裸仓库要求， 以.git结尾的目录 仓库是一个空的仓库，并且不允在这个仓库中进行任何修改 123456mkdir repo.git 创建以.git结尾目录cd repo.git 进入这个目录git init --bare 初始化一个共享仓库，也叫裸仓库 注意选项--bare 注意！文件夹名字就是xxx.git,要有.git结尾 4.2 向共享仓库共享（同步）内容将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。 1234cd xxx.git //进入该目录git push 路径 分支名 4.3 向共享仓库取内容 git pull 路径 分支名 4.4 远程相关指令 git remote ：显示所有远程名 git remote 远程名 ：显示该远程名所指向的路径 git remote -v ：显示所有远程名及其路径 git remote add 远程名 远程路径 ： 添加一个远程 五、Git高级5.1 gitignore忽略文件在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里，如项目的配置文件、node_modules等 5.2 比较差异当内容被修改，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 git difftool 比较的是工作区和暂存的差异 git difftool “SHA”比较与特定提交的差异 git difftool “SHA”“SHA”比较某两次提交的差异 git difftool 分支名称 比较与某个分支的差异 5.3 回滚（撤销）操作HEAD 默认指向当前分支的“末端”，即最后的一次提交，但是我们通过git reset 可以改变HEAD的指向。 1、git reset –hard 工作区会变、历史(HEAD)会变， 暂存区也变 –soft 只会变历史(HEAD) –mixed（默认是这个选项）历史(HEAD)会变、暂存区也变，工作区不变 2、git checkout git checkout SHA – “某个文件”，代表只是从SHA这个版中取出特定的文件， 和git reset 是有区别的，reset 重写了历史，checkout 则没有。 5.4 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch 命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch “远程主机”或者 git fetch “远程主机” “分支名称” 我们要注意的是，利用git fetch 获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。如下 git pull origin 某个分支， 上操作相当于下面两步 git fetch、 git merge origin/某个分支 5.5 规范管理1、不要有太多的树杈（子分支） 2、要有一个“稳定分支”，即master分支不要轻意被修改 3、要有一个开发分支（developer），保证master分支的稳定性 4、所有的功能分支（feature）从developer创建 5、所有功能开发完成后新建发布分支（release）","tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"}]},{"title":"JQuery源码阅读（二）","date":"2017-04-24T12:37:33.000Z","path":"2017/04/24/jQuery源码阅读（二）/","text":"一、jQ原型上的核心方法和属性 1、jQuery 获取版本号 2、selector 代表所有实例默认的选择器，也代表实例是一个jQuery类型的对象 3、length 代表所有实例默认的长度 4、toArray 把实例转换为数组返回 5、get 获取指定下标的元素，获取的是原生DOM 6、each 遍历实例，把遍历到的数据分别传给回调使用 7、map 遍历实例，把遍历到的数据分别传给回调使用，然后把回调的返回值收集起来组成一个数组返回 8、slice 截取实例的部分元素，构成一个新的jQuery实例返回。 9、first 获取实例中的第一个元素，是jQuery类型的实例对象。 10、last 获取实例中的最后一个元素，是jQuery类型的实例对象。 11、eq 获取指定下标的元素，获取的是jQuery类型的实例对象。 12、push 给实例添加新元素 13、sort 对实例中的元素进行排序 14、splice 按照指定下标指定数量删除元素，也可以替换删除的元素。 二、结构抽取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function(w)&#123; var version = \"1.0.0\"; //对外暴露的工厂函数 function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, jQuery:version, selector:'', length:0, toArray:function()&#123;&#125;, get:function(num)&#123;&#125;, each:function(fn)&#123;&#125;, map:function(fn)&#123;&#125;, slice:function()&#123; eq:function(i)&#123;&#125;, first:function()&#123;&#125;, last:function()&#123;&#125;, push:[].push, pop:[].pop, shift:[].shift, unshift:[].unshift, sort:[].sort, splice:[].splice &#125;; jQuery.extend = jQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125; &#125;; jQuery.extend(&#123; each:function(obj,fn)&#123;&#125;, map:function(obj,fn)&#123;&#125;, trim : function(str)&#123;&#125;, isString : function(str)&#123;&#125;, isHTML : function(html)&#123;&#125;, isFunction : function(fn)&#123;&#125;, isWindow : function(w)&#123;&#125;, isObject : function(obj)&#123;&#125;, isLikeArray : function(arr)&#123;&#125;, ready:function(fn)&#123;&#125; &#125;); // init是真正的构造函数 var init = jQuery.fn.init = function(selector)&#123; //入口函数 &#125;; //把init函数的原型设置为JQ工厂函数的原型 init.prototype = jQuery.fn; w.$ = w.jQuery = jQuery;&#125;)(window); 可以看到，使用情景不同，大部分方法是在jQuery的原型上定义的(实例自己调用)，也就是实例方法，其他方法在jQuery工厂函数静态方法中也有定义(作为工具方法给外部调用)，each和map方法是实例和静态方法中均有。 但是，在静态方法中的each/map接收的参数是需要遍历的对象/数组/伪数组(obj)和回调函数(fn) 因为是静态方法，直接”类名”.来调用，所以遍历对象需要作为形参传入。 而在原型中定义的实例方法中的each/map,接收的参数只有fn，因为实例方法是实例调用的(eg:$(‘.item’).each(function(k,v){});)，属于”方法调用模式”,已经知道调用对象是谁，直接可以用this获取。 实例不能调用静态方法(类方法)，所以通常会在定义好类方法的同时，在原型上也添加一个同名的实例方法，直接在同名的实例方法内调用类方法即可。 三、具体实现方法中以_开头的代表该方法的简便写法,eg:get方法和_get方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258(function(w)&#123; var version = \"1.0.0\"; function jQuery(str)&#123; return new jQuery.fn.init(str); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, jQuery:version, selector:'', length:0, // toArray,get,_get,each,map,slice,_slice,eq,_eq,first,last,push,sort,splice toArray:function()&#123; return [].slice.call(this); &#125;, //得到的是原生dom get:function(num)&#123; //如果不传，即num为null、undefined，默认返回数组 if(num == null) return this.toArray(); else if(num&lt;0)&#123; return this[this.length + i]; &#125;else&#123; return this[num]; &#125; &#125;, _get:function(num)&#123; return num==null?this.toArray():(num&gt;=0?this[i]:this[this.length + i]); &#125;, each:function(fn)&#123; return jQuery.each(this,fn); &#125;, map:function(fn)&#123; return jQuery.map(this,fn); &#125;, slice:function()&#123; /* * 1、通过数组的slice截取部分元素(slice返回的是数组)， * 2、把截取到的元素转换为实例对象返回。 * */ // 因为slice的参数会有变化，所以需要是arguments， // 我们要把arguments中的每一项传给数组的slice，所以需要借用apply平铺传递过去， // 最后把slice返回数组，通过jQuery工厂保证成实例返回。\\ var nodes =[].slice.apply(this,arguments); return jQuery(nodes); &#125;, _slice:function()&#123; return jQuery([].slice.apply(this,arguments)); &#125;, eq:function(i)&#123; //返回包装对象 if(i==null)&#123; //null和undefined返回空的包装对象 return jQuery(); &#125; else if(i&gt;=0)&#123; return jQuery(this[i]); &#125;else&#123; return jQuery(this[this.length + i]); &#125; &#125;, _eq:function(i)&#123; // return i==null?jQuery():(i&lt;0?jQuery[this.length + i]:jQuery(this[i])); return i == null?jQuery():jQuery(this.get(i)); &#125;, first:function()&#123; return this.eq(0); &#125;, last:function()&#123; return this.eq(-1); &#125;, push:[].push, pop:[].pop, shift:[].shift, unshift:[].unshift, sort:[].sort, splice:[].splice &#125;; jQuery.extend = jQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125; &#125;; jQuery.extend(&#123; each:function(obj,fn)&#123; var i,len = obj.length,key; if(jQuery.isLikeArray(obj))&#123; for(i = 0,len = obj.length;i &lt; len; i++)&#123; if(fn.call(obj[i],i,obj[i]) === false) break; &#125; &#125;else&#123; for(key in obj)&#123; if(fn.call(obj[key],key,obj[key]) === false) break; &#125; &#125; return obj; &#125;, map:function(obj,fn)&#123; var i,len,key,result = []; if(jQuery.isLikeArray(obj))&#123; for(i = 0,len = obj.length; i&lt;len; i++)&#123; result.push(fn.call(obj[i],i,obj[i])); &#125; &#125;else&#123; for(key in obj)&#123; result.push(fn.call(obj[key],key,obj[key])); &#125; &#125; return result; &#125;, trim : function(str)&#123; if(typeof str !== 'string')&#123; return str; &#125; if( str.trim)&#123; return str.trim(); &#125; return str.replace(/^\\s+|\\s+$/,''); &#125;, isString : function(str)&#123; if(!str)&#123; return false; &#125; else if(typeof str === 'string')&#123; return true; &#125; return false; &#125;, //function&#123;isHTML&#125;判断字符串是否是html片段 //param &#123;html&#125; 字符串 //return &#123;boolean&#125; isHTML : function(html)&#123; if(!html)&#123; return false; &#125; if(html.charAt(0) === \"&lt;\" &amp;&amp; html.charAt(html.length - 1) === \"&gt;\" &amp;&amp; html.length&gt;3)&#123; return true; &#125; return false; &#125;, isFunction : function(fn)&#123; if(typeof fn === \"function\")&#123; return true; &#125; return false; &#125;, isWindow : function(w)&#123; if( w.window === w)&#123; return true; &#125; return false; &#125;, isObject : function(obj)&#123; //防止对null的误判，null属于object，但我们这不符合我们的isObject过滤需求 if(obj === null)&#123; return false; &#125; else if(typeof obj === 'object' || typeof obj === 'function')&#123; return true; &#125; return false; &#125;, //function&#123;isLikeArray&#125; 判断是不是数组(伪数组和真数组都算) //param &#123;arr&#125; object //return &#123;boolean&#125; isLikeArray : function(arr)&#123; //把函数、window对象和非object的排除 if(jQuery.isFunction(arr) || jQuery.isWindow(arr) || !jQuery.isObject(arr))&#123; return false; &#125; //判断是不是真数组 if((&#123;&#125;).toString.call(this,arr) === '[object Array]')&#123; return true; &#125; //判断是不是伪数组 // arr必须有length，在这个基础上，要么length为0，要么有length - 1这个属性值 if(('length' in arr) &amp;&amp; ((arr.length === 0) || (arr.length - 1 in arr)))&#123; return true; &#125; return false; &#125;, ready:function(fn)&#123; if(document.readyState === 'complete')&#123; //dom结构如果都加载完成了就直接执行传入的该函数，不需要下面的判断了 fn(); &#125; //是否支持addEventListener绑定事件方式 else if(document.addEventListener)&#123; //直接把fn添加给DOMContentLoaded事件监听 //DOMContentLoaded,H5新增事件，IE9以上支持,比window.onload快很多 document.addEventListener(\"DOMContentLoaded\",fn); &#125; else&#123; //IE8 document.attachEvent(\"onreadystatechange\",function()&#123; if(document.readyState === 'complete')&#123; fn(); &#125; &#125;); &#125; &#125; &#125;); var init = jQuery.fn.init = function( selector )&#123; //入口函数 if(!selector)&#123; //null,0,undefined,NaN,'' return this;//直接返回一个由init new出来的空实例 &#125; if(jQuery.isFunction(selector))&#123; jQuery.ready(selector); &#125; else if(jQuery.isString(selector))&#123; //字符串先trim下 selector = jQuery.trim(selector); //判断是html片段还是选择器 if( jQuery.isHTML(selector))&#123; var tempDiv = document.createElement(\"div\"); tempDiv.innerHTML = selector; [].push.apply(this,tempDiv.childNodes); return this; &#125; //选择器 else&#123; try&#123; var nodes = document.querySelectorAll(selector); [].push.apply(this,nodes); return this; &#125;catch(e)&#123; this.length = 0; return this; &#125; &#125; &#125; else if(jQuery.isLikeArray(selector))&#123; //数组或伪数组 [].push.apply(this,selector); return this; &#125; else&#123; this[0] = selector; this.length = 1; return this; &#125; &#125;; init.prototype = jQuery.fn; w.$ = w.jQuery = jQuery;&#125;)(window);","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"jQuery源码阅读（一）","date":"2017-04-23T15:40:33.000Z","path":"2017/04/23/jQuery源码阅读（一）/","text":"本次初步阅读的是jQuery的1.7的经典版本。 1. 大体结构 123456789101112131415161718192021222324(function( w ) &#123; // 对外暴露的工厂函数 function jQuery(selector) &#123; return new jQuery.fn.init(selector); &#125; // 给原型提供一个简写方式 jQuery.fn = jQuery.prototype = &#123; constructor:JQuery, //原型核心方法和属性,jquery,selector,length,toArray,each,slice,splice等 //后面会详细解释 &#125;; // init是jQuery中真正的构造函数 var init = jQuery.fn.init = function(selector) &#123; // &#125;; // 替换构造函数的原型 为 jQuery工厂的原型 init.prototype = jQuery.fn;//这步很重要 // 把工厂通过两个变量暴露出去 w.jQuery = w.$ = jQuery; &#125;( window )); 1) 在上述结构中，通过一个立即调用函数，把jQuery代码封装起来，不污染全局，function jQuery(selector){}是jQuery的工厂函数，也是对外界暴露的 2)jQuery.fn就是给jQuery.prototype取了个简短的名字，便于书写，同时把jQuery工厂函数的原型替换 3)jQuery.fn.init是给jQuery的原型添加一个init方法，因为jQuery.fn也是指向jQuery.prototype的地址的，所以修改jQuery.fn就是修改jQuery工厂函数的原型。而在jQuery工厂函数中，返回的就是new jQuery.fn.init(selector)，所以可以说，init方法就是jQuery这个类库的真正的构造函数 2. jQuery插件实现机制在提及jQuery的插件实现机制之前，先看下jQuery类库中给jQuery工厂函数和jQuery.fn这个工厂函数的原型添加的混入方法extend 12345JQuery.extend = JQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125;&#125; 这一段给工厂函数和原型一起添加了一个extend的混入继承方法，这个方法可以方便的一次性拓展多个方法 在《JQuery插件开发》书中提到，JQuery插件开发有2种大方式 1)类级别 通过添加全局函数(给jQuery这个function构造函数添加的类级别的静态方法) 123jQuery.foo = function()&#123; ...&#125; 或者通过混入的方式给jQuery构造函数添加静态方法12345678jQuery.extend(&#123; fn1:function()&#123; ... &#125;, fn2:function()&#123; ... &#125;&#125;); 2)对象级别 给jQuery的原型添加实例方法 混入法12345678(function($)&#123; $.fn.extend(&#123; pluginName:function()&#123; &#125; &#125;);&#125;)(jQuery); 或者直接添加法 12345678(function($)&#123; $.fn.pluginName = function()&#123; &#125;;&#125;)(jQuery); 3.jQuery入口函数对jQuery的入口函数进行了抽取，大致实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179(function(w)&#123; function JQuery(str)&#123; return new JQuery.fn.init(str); &#125; JQuery.fn = JQuery.prototype = &#123; constructor:JQuery &#125;; JQuery.extend = JQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125; &#125;; JQuery.extend(&#123; trim : function(str)&#123; if(typeof str !== 'string')&#123; return str; &#125; if( str.trim)&#123; //优先使用原生的trim方法 return str.trim(); &#125; //^\\s+代表开头的大于等于1的空格 \\s+$代表结尾的大于等于1空格 return str.replace(/^\\s+|\\s+$/,''); &#125;, isString : function(str)&#123; if(!str)&#123; return false; &#125; else if(typeof str === 'string')&#123; return true; &#125; return false; &#125;, //function&#123;isHTML&#125;判断字符串是否是html片段 //param &#123;html&#125; 字符串 //return &#123;boolean&#125; isHTML : function(html)&#123; if(!html)&#123; return false; &#125; if(html.charAt(0) === \"&lt;\" &amp;&amp; html.charAt(html.length - 1) === \"&gt;\" &amp;&amp; html.length&gt;3)&#123; return true; &#125; return false; &#125;, isFunction : function(fn)&#123; if(typeof fn === \"function\")&#123; return true; &#125; return false; &#125;, //如何判断是否是window对象？ //window对象有个属性叫window，仍然指向window isWindow : function(w)&#123; if( w.window === w)&#123; return true; &#125; return false; &#125;, isObject : function(obj)&#123; //防止对null的误判，null属于object，但我们这不符合我们的isObject过滤需求 //所以提前先手动判断 if(obj === null)&#123; return false; &#125; else if(typeof obj === 'object' || typeof obj === 'function')&#123; return true; &#125; return false; &#125;, //function&#123;isLikeArray&#125; 判断是不是数组(伪数组和真数组都算) //param &#123;arr&#125; object //return &#123;boolean&#125; isLikeArray : function(arr)&#123; //把函数、window对象和非object的排除 if(JQuery.isFunction(arr) || JQuery.isWindow(arr) || !JQuery.isObject(arr))&#123; return false; &#125; //判断是不是真数组 if((&#123;&#125;).toString.call(this,arr) === '[object Array]')&#123; return true; &#125; //判断是不是伪数组 // arr必须有length，在这个基础上，要么length为0，要么有length - 1这个属性值 if(('length' in arr) &amp;&amp; ((arr.length === 0) || (arr.length - 1 in arr)))&#123; return true; &#125; return false; &#125;, ready:function(fn)&#123; if(document.readyState === 'complete')&#123; //dom结构如果都加载完成了就直接执行传入的该函数，不需要下面的判断了 fn(); &#125; //是否支持addEventListener绑定事件方式 else if(document.addEventListener)&#123; //直接把fn添加给DOMContentLoaded事件监听 //DOMContentLoaded,H5新增事件，IE9以上支持,比window.onload快很多 document.addEventListener(\"DOMContentLoaded\",fn); &#125; else&#123; //IE8 document.attachEvent(\"onreadystatechange\",function()&#123; if(document.readyState === 'complete')&#123; fn(); &#125; &#125;); &#125; &#125; &#125;); var init = JQuery.fn.init = function( selector )&#123; //入口函数 if(!selector)&#123; //null,0,undefined,NaN,'' return this;//直接返回一个由init new出来的空实例 &#125; //如果传的是函数，直接放入ready方法，在dom加载完毕后执行 if(JQuery.isFunction(selector))&#123; JQuery.ready(selector); &#125; //字符串，html||选择器 else if(JQuery.isString(selector))&#123; //字符串先trim下 selector = JQuery.trim(selector); if( JQuery.isHTML(selector))&#123; var tempDiv = document.createElement(\"div\"); tempDiv.innerHTML = selector; [].push.apply(this,tempDiv.childNodes); return this; &#125; //选择器 else&#123; try&#123; var nodes = document.querySelectorAll(selector); [].push.apply(this,nodes); return this; &#125;catch(e)&#123; this.length = 0; return this; &#125; &#125; &#125; //数组或伪数组 else if(JQuery.isLikeArray(selector))&#123; [].push.apply(this,selector); return this; &#125; else&#123; this[0] = selector; this.length = 1; return this; &#125; &#125;; init.prototype = JQuery.fn; w.$ = w.JQuery = JQuery;&#125;)(window); tips： 上述代码实现大部分使用了上下文调用模式，也就是call/apply方法 apply方法可以该改变this指向，同时可以把数组或伪数组平铺传入给函数， 但是IE8，apply只能平铺真数组或者内置的伪数组，我们自定义的伪数组会报错。 所以需要兼容性写法 1234// 借用数组的slice方法，通过一个伪数组得到一个真数组// [].slice.call( obj ) ;可以将obj伪数组返回真数组[].push.apply( this, [].slice.call( selector ) );//可将上述入口函数//代码的apply替换为该兼容性写法 数组的slice方法是按照指定下标指定数量删除元素，也可以替换删除的元素，返回的是一个新【数组】，如果不传参数，就直接返回完整的新【数组】","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"JSNotes（四）JS中的沙箱、函数调用模式","date":"2017-04-11T01:53:06.000Z","path":"2017/04/11/JSNotes（四）JS中的沙箱、函数调用模式/","text":"沙箱与外界隔绝的一个环境，外界无法修改该环境内任何信息，沙箱内的东西单独属于一个世界 JS中的沙箱模式格式： 123456(function()&#123; var a = 123;&#125;)(); 沙箱采用立即执行函数表达式（IIFE） 因为IIFE不会在外界暴露任何的全局变量，但是又可以形成一个封闭的空间 1.在沙箱中将所有变量的定义放在最上方 2.中间就放一些逻辑代码 3.最后，如果需要，就给外界暴露一些成员（通过window作为参数传入自调用函数） 如： 12345678910111213141516(function(win)&#123; var xiangnick = &#123; getEle:function () &#123; console.log(\"我是getEle方法\"); &#125; &#125; win.XiangNick = win.$ = xiangnick;//这样就绑定在了win形参上了 &#125;)(window) 调用 1234getEle();//Uncaught ReferenceError: getEle is not defined,说明沙箱很好的隔离了全局$.getEle();//我是沙箱内的方法 沙箱是隔离的区域，内部很安全，同时也不会污染全局变量，但是如果需要和外界交互，可以把window作为实参传入，对于沙箱内部来说，操作的只是形参，外界是影响不到沙箱的。 1.如果需要在外界暴露一些属性或者方法，就可以将这些属性和方法,加到window全局对象上去,但是这window全局对象不可以直接引用，因为直接引用会破坏沙箱原则 2.所以我们选择使用传参的形式将 window对象 传入沙箱内,此时沙箱内使用window对象的时候，不会再去全局搜索window对象,而使用的就是沙箱内部定义的形参 沙箱模式的运用场景1.沙箱模式一般应用在书写第三方框架 2.或者为第三方框架书写插件 3.或者书写功能独立的一些组件 沙箱模式的优势 1.沙箱模式使用的是IIFE，不会再外界暴露任何的全局变量，也就不会造成全局变量污染 2.沙箱中的所有数据，都是和外界完全隔离的，外界无法对其进行修改，也就保证了代码的安全性 js中沙箱模式的实现原理 函数可以构建作用域！上级作用域不能直接访问下级作用域中的数据 函数调用模式其实就是this的指向不同A. 函数模式 this—&gt;window B. 方法模式 this—-&gt;调用方法的对象 C. 构造函数模式 C.1 123456789101112131415161718function Person(name,age)&#123; this.name = name; this.age = age; this.sayHi = function()&#123; console.log(\"我是\"+name+\"今年我\"+age+\"岁\"); &#125;&#125;var p = new Person('macal',23);p.sayHi(); this—–&gt;new出来的实例 拓展：由于构造函数new对象时，不写返回值默认返回new的实例，返回值写常量仍然返回new的实例，但是写引用类型，则会返回该引用类型，因此，对于构造函数模式，有了以下的变种【了解即可，与本主题无关】 C.2 工厂模式 123456789101112131415161718function Person(name,age) &#123; var o = &#123; name: name, age: age &#125; return o;&#125;var p = Person('jack',20);console.log(p);//P是一个Object对象,和构造函数Person()无关 C.3 寄生模式 123456789101112131415161718function Fun(name, age) &#123;var o = &#123;name: name,age: age&#125;return o;&#125;var obj = new Fun('jack', 20);//new出来的是Object对象,和构造函数无关 D. 上下文模式 this—–&gt;指定的是谁就是谁 call 函数.call(对象,arg1,arg2,arg3,…argn) apply 函数.apply(对象,数组) 都可以用来改变this的指向为参数的第一个值 call是使用单独的每一个参数来传参 apply是使用数组进行传参的，这个数组在调用的时候，会被意义拆解，当做函数的每一个采参数 call在函数的形参个数确定的情况下使用 apply在函数的形参个数不确定的情况下使用 12345678910111213141516function test() &#123;console.log(this);&#125;test.apply(1);//Numbertest.apply(\"abc\");//Stringtest.apply(true)//Booleantest.apply(null)//Windowtest.apply(undefined)//Window 当用call和apply传入的第一个参数为值类型的时候,会将值类型转换成对应的对象（引用类型） 然后赋值给this 当传入的第一个参数为 null或者undefined的时候，会把this赋值为 window 上下文模式小应用 求数组最大值。 123456var arr = [12,312,53,34,23,12,111]; var max = Math.max.apply(null,arr); console.log(max); 由于Math.max()方法只接收一个个的参数，不接收数组，所以我们用apply的特性，他会把apply方法中第二个参数，也就是数组，拆为一个个单个参数传入，来求最大值。 把传入函数的参数连接成字符串，中间以分隔符相连 123456789101112var result = foo(1, 3, \"abc\", \"ffff\", 99);function foo()&#123;var str = Array.prototype.join.call(arguments,\"-\");//A句return str;&#125;console.log(result); 这里用了数组的join方法。 题外话： 对于A句，我们可以修改为 var str = [].join.call(arguments,”-“); 熟悉原型链的可以知道,[]就相当于new了一个Array的实例，本身没有join方法(因为是Array的公共方法，放在原型里)，就去调用原型里的join方法来满足。 这句虽然写着简便，很短。但其实执行效率没有A句那么好，因为有个实例去原型搜索的过程。 详细介绍函数模式特征:就是一个简单的函数调用，函数名前面没有任何的引导内容 12345678910function foo()&#123;&#125;var func = function()&#123;&#125;foo();func();(function()&#123;&#125;)(); this在函数模式中的含义： this在函数中表示全局对象，在浏览器中是window对象 方法模式特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法. 123456789101112function f() &#123; this.method = function () &#123;&#125;;&#125;var o = &#123; method: function () &#123;&#125;&#125; this在方法模式调用中的含义:表示函数所依附的这个对象 构造器调用模式由于构造函数只是给 this 添加成员. 没有做其他事情. 而方法也可以完成这个操作, 就 this 而言, 构造函数与方法没有本质区别. 特征:使用 new 关键字, 来引导构造函数. 1234567891011121314function Person()&#123; this.name = \"zhangsan\"; this.age = 19; this.sayHello = function()&#123; &#125;;&#125;var p = new Person(); 构造函数中发this与方法中一样, 表示对象, 但是构造函数中的对象是刚刚创建出来的对象 关于构造函数中return关键字的补充说明 构造函数中不需要return, 就会默认的return this 如果手动的添加return, 就相当于 return this 如果手动的添加return 基本类型; 无效, 还是保留原来 返回this 如果手动添加return null; 或return undefiend, 无效 如果手动添加return 对象类型; 那么原来创建的this就会被丢掉, 返回的是 return后面的对象 创建对象的模式工厂方法123456789101112131415161718// 工厂就是用来生产的, 因此如果函数创建对象并返回, 就称该函数为工厂函数function createPerson( name, age, gender ) &#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;// document.createElement()原理 构造方法123456789101112function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;var p = new Person(\"zhangsan\", 19, \"男\"); 寄生式创建对象12345678910111213141516function Person(name, age, gender)&#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;var p = new Person(\"Jack\", 18, \"male\"); 混合式创建混合式继承就是讲所有的属性放在构造方法里面，然后讲所有的方法放在原型里面，使用构造方法和原型配合起来创建对象。 上下文调用模式上下文(Context)，就是函数调用所处的环境。 上下文调用，也就是自定义设置this的含义。 在其他三种调用模式中，函数/方法在调用的时候，this的值都是指定好了的，我们没办法自己进行设置，如果尝试去给this赋值，会报错。 上下文调用的语法12345678910//第一种， apply函数名.apply(对象, [参数]);//第二种， call函数名.call(对象, 参数);//上面两种方式的功能一模一样，只是在传递参数的时候有差异。 功能描述： 语法中的函数名表示的就是函数本身，使用函数调用模式的时候，this默认是全局对象 语法中的函数名也可以是方法(如:obj.method)，在使用方法模式调用的时候，this默认是指当前对象 在使用apply和call的时候，默认的this都会失效，this的值由apply和call的第一个参数决定 补充说明 如果函数或方法中没有this的操作, 那么无论什么调用其实都一样. 如果是函数调用foo(), 那么有点像foo.apply( window ). 如果是方法调用o.method(), 那么有点像o.method.apply( o ). 参数问题call和apply在没有后面的参数的情况下(函数无参数, 方法无参数) 是完全一样的. 如下： 12345678910function foo() &#123; console.log( this );&#125;foo.apply( obj );foo.call( obj ); 第一个参数的使用规则: 如果传入的是一个对象, 那么就相当于设置该函数中的 this 为参数 如果不传入参数, 或传入 null. undefiend 等, 那么相当于 this 默认为 window 12345678foo();foo.apply();foo.apply( null );foo.call( undefined ); 如果传入的是基本类型, 那么 this 就是基本类型对应的包装类型的引用 number -&gt; Number boolean -&gt; Boolean string -&gt; String 第二个参数的使用规则 在使用上下文调用的时候, 原函数(方法)可能会带有参数, 那么这个参数在上下文调用中使用第二个( 第 n 个 )参数来表示 123456789101112function foo( num ) &#123; console.log( num );&#125;foo.apply( null, [ 123 ] );// 等价于foo( 123 ); 上下文调用模式的应用上下文调用只是能修改this, 但是使用的最多的地方上是函数借用. 1. 将伪数组转换为数组传统的做法： 1234567891011121314151617181920var a = &#123;&#125;;a[ 0 ] = 'a';a[ 1 ] = 'b';a.length = 2;// 使用数组自带的方法 concat// 如果参数中有数组会把参数数组展开// 语法: arr.concat( 1, 2, 3, [ 4, [ 5 ] ] );// 特点：不修改原数组var arr = [];var newArr = arr.concat( a ); 由于a是伪数组, 只是长得像数组. 所以上面的代码不能成功，不能使用concat方法。 但是apply方法有一个特性, 可以将数组或伪数组作为参数。（IE8不支持伪数组操作） 12foo.apply( obj, 伪数组 ); // IE8 不支持 利用apply方法，可以写出以下 1234//将伪数组 a 作为 apply 的第二个参数var newArr = Array.prototype.concat.apply( [], a ) 处理数组转换, 实际上就是将元素一个一个的取出来构成一个新数组, 凡是涉及到该操作的方法理论上都可以。 push方法123456789101112131415161718192021222324//用法:arr.push( 1 ); //将这个元素加到数组中, 并返回所加元素的个数arr.push( 1, 2, 3 ); //将这三个元素依次加到数组中, 返回所加个数var a = &#123; length: 0 &#125;; // 伪数组a[ a.length++ ] = 'abc'; // a[ 0 ] = 'abc'; a.length++;a[ a.length++ ] = 'def';// 使用一个空数组, 将元素一个个放到数组中即可var arr = [];arr.push( a ); // 此时不会将元素展开, 而是将这个伪数组作为一个元素加到数组中// 再次利用 apply 可以展开伪数组的特征arr.push.apply( arr, a );// 利用 apply 可以展开伪数组的特性, 这里就相当于 arr.push( a[0], a[1] ) 2. 求数组中的最大值传统的做法 123456789101112var max = arr[ 0 ];for ( var i = 1; i &lt; arr.length; i++ ) &#123; if ( arr[ i ] &gt; max ) &#123; ... &#125;&#125; 在 js 中的Math对象中提供了很多数学函数Math.max( 1,2,3 ) 还是利用 apply 可以展开数组的特性 1234var arr = [ 123456,12345,1234,345345,234,5 ];Math.max.apply( null, arr ); 3.借用构造函数继承12345678910111213141516171819202122function Person ( name, age, gender ) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 需要提供一个 Student 的构造函数创建学生对象// 学生也应该有 name, age, gender, 同时还需要有 course 课程function Student ( name, age, gender, course ) &#123; Person.call( this, name, age, gender ); this.course = course;&#125; 面试题12345678910111213141516171819202122//1 var age = 38; var obj = &#123; age: 18, getAge: function() &#123; console.log(this.age); &#125; &#125;;// var a = obj.getAge(); //18 var getAge = obj.getAge; getAge();//38 var a = obj.getAge(); 因为是obj点的，是方法模式，this指向obj，所以打印18 var getAge = obj.getAge; getAge(); 就是函数模式调用，自然this指向全局，打印38 1234567891011121314151617181920212223242526//2var age = 38;var obj = &#123; age: 18, getAge: function() &#123; console.log(this.age);//A处 18 function foo() &#123; console.log(this.age); //B处 38 &#125; foo(); &#125;&#125;;obj.getAge(); A处：obj.getAge()是obj调用的，所以A处为方法模式，this指向obj，自然打印出obj内部的age:18 B处：getAge内部还执行了一个foo()函数，看他调用的方式，前面没有对象来点，直接的调用一个函数，就是函数模式，指向window，打印38 1234567891011121314151617181920212223242526//3 var length = 10; function fn()&#123; console.log(this.length); &#125; var obj = &#123; length: 5, method: function (fn) &#123; fn(); //A处 10 arguments[0](); //B处 4 &#125; &#125;; obj.method(fn, 123, 456, 789); method虽然是obj调用的，为方法模式，但是其内部执行了fn()，为函数模式，this指向window，所以A处打印10 然后B处的arguments[0] ();因为arguments是一个对象，内部有着参数，对象[索引]的形式其实就是对象.索引。所以为方法模式，即arguments来调用传入参数内的fn()函数，即打印arguments的长度，为4 总结函数调用模式其实很简单，就看其调用形式 如果是 obj.fn() 就是方法模式，this指向调用者obj 如果是 fn() 就是函数模式，this指向全局window 如果是var obj = new Person(); obj.fn(); 就是构造函数模式，this指向new出来的obj实例 还有一个最特殊的上下文模式 函数.call(对象,arg1,arg2,arg3,...argn) 函数.apply(对象,数组) 都可以用来改变this的指向为参数的第一个值","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（三）JS的闭包","date":"2017-04-09T09:39:19.000Z","path":"2017/04/09/JSNotes（三）JS的闭包/","text":"闭包闭包的概念闭包从字面意思理解就是闭合, 包起来. 简单的来说闭包就是,一个具有封闭的对外不公开的, 包裹结构, 或空间.在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包. 闭包要解决什么问题？ 闭包内的数据不允许外界访问 要解决的问题就是间接访问该数据 函数就可以构成闭包, 要解决的问题就是访问到函数内部的数据 我们观察下面的函数foo，在foo内部有一个变量num，能否在函数外部访问到这个变量num呢？ 123456789101112function foo () &#123; var num = 123; return num;&#125;var res = foo();console.log( res ); // =&gt; 123 分析： 在上面的代码中，确实可以访问到num这个函数内部的变量。但是能不能多次访问呢？ 不能，因为每次访问都得重新调用一次foo函数，每次调用都会重新创建一个num = 123，然后返回。 解决思路函数内的数据不能直接在函数外被访问，是因为作用域的关系，上级作用域不能直接访问下级作用域中的数据。 但是如果反过来，下级作用域可以直接访问上级作用域中的数据。那么如果在函数foo内定义一个函数，那么在这个内部函数中是可以直接访问foo中的num的。 12345678910111213141516171819202122function foo() &#123; var num = Math.random(); function func() &#123; return num; &#125; return func;&#125;var f = foo();// f可以直接访问num，而且多次访问，访问的也是同一个，并不会返回新的numvar res1 = f();var res2 = f(); 如何获得超过一个数据函数的返回值只能有一个，那按照上面的方法，我们只能对函数内部的一个数据进行操作。怎么操作函数内的多个数据呢？ 可以使用对象，代码如下： 1234567891011121314151617181920212223242526function foo () &#123; var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return &#123; num1: function () &#123; return num1; &#125;, num2: function () &#123; return num2; &#125; &#125;&#125; 如何完成读取一个数据和修改这个数据前面讲的都是如何去获取函数内部的数据，接下来我们考虑如何修改函数内部的数据。 同样，也是使用内部的函数进行操作。 12345678910111213141516171819202122232425262728function foo() &#123; var num = Math.random(); //分别定义get和set函数，使用对象进行返回 return &#123; //get_num负责获取数据 get_num: function() &#123; return num; &#125;, //set_num负责设置数据 set_num: function(value) &#123; num = value; &#125; &#125;&#125; 我们还可以模仿JQ的方法思路，fun()是获取数据,fun(val)是修改数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function foo()&#123; var fname = \"nick\"; var fage = 23; return &#123; name:function(value)&#123; if(value === undefined)&#123; &#125;else&#123; fname = value; &#125; return fname; &#125;, age:function(value)&#123; if(value === undefined)&#123; &#125;else&#123; fage = value; &#125; return fage; &#125; &#125;; &#125; var obj = foo(); console.log(obj.name()); console.log(obj.age()); console.log(obj.age(24)); 总结闭包的作用：根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. Js中函数可以产生作用域，因此说函数可以构成闭包。 1.可以读取函数内部的变量 2.让这些变量的值始终保持在内存中。 好处：闭包更像是面向对象语言中的封装，函数内部的数据被封装起来私有化，外部无法直接修改，只能依靠我们提供的方法来修改和获取我们私有化的内部数据，Java中的get、set方法。同时，由于是我们提供方法给外部访问我们内部私有化的数据，所以： 1.在函数外部想要修改数据，只能通过函数内部的方法 2.我们可以在函数内部定义的这个方法里设置安全措施，校验之类的操作不合法可以throw异常 3.可以保证系统的安全性和稳定性 坏处:上面说到，闭包的作用之一还有一个将函数内部的私有变量始终保存在内存中，这既是好处(操作的一直是同一个数据)，也有坏处（由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除） 如何理解呢？ 下面摘自偶像阮一峰大神博客的一段内容： 123456789101112131415161718192021222324function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 阮大神在博客结尾留下了两个闭包的思考题： 题一： 1234567891011121314151617181920var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//The Window 题二： 12345678910111213141516171819202122var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//My Object 解析：对于题一： 12object.getNameFunc()() 也就是 12345678(function()&#123; return function()&#123; return this.name; &#125;)(); 是不是就是在全局调用这个函数,这是闭包没闭上 由于this是动态的，在调用语句的那一刻来获取上下文，这两题中就看在什么时候才能逐句解释运行到this关键字，来动态获取上下文。 在题一中，在最后调用时this才开始获取上下文，是window ，于是在全局找到了var name = “The Window”; 弹出The Window 对于题二： 由于用了var that = this;这时候，this就是开始获取上下文了！发现是在object内，所以this指向object并赋值给了that，所以这时候that就指向object了！自然弹出作用域里的My Object! 这是包上了，在外部来操作内部变量。 小应用利用闭包+缓存解决递归求解斐波那契数列性能问题对于一般的递归斐波那契数列写法，为： 123456789101112function Fibonacci(n)&#123; if(n &lt;= 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 我们可以在函数内部加上count计数器来计算其递归运算了多少次，以简单的测试其性能 123456789101112131415161718192021222324252627282930var count = 0;function Fibonacci(n)&#123; count++; if(n &lt;= 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;console.log(\"计算5的返回值: \"+Fibonacci(5)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算6的返回值: \"+Fibonacci(6)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算20的返回值: \"+Fibonacci(20)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算21的返回值: \"+Fibonacci(21)+\" ，运算了 【 \"+count+\" 】次\"); 结果： 可以看出，计算20的返回值就要递归上万次，性能可想而知。由于斐波那契数列的特殊性，后者的值需要加上前两项的值，我们采用缓存来存储之前算过的值。同时采用闭包将缓存封装起来，提供我们自己定义的方法来安全操作缓存，提高其安全性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//定义缓存，闭包封装好，返回指定方法来操作缓存function cacheFactory(length)&#123; var cache = &#123;&#125;; var keys = []; if(length === undefined)&#123; throw &#123; \"errCode\":4, \"errMsg\":\"请定义缓存容量!\" &#125; &#125; return function(key,value)&#123; if(keys.length &gt; length)&#123; //清第一个也就是最旧的数据 var tempKey = keys.shift(); delete cache[tempKey]; &#125; if(value !== undefined)&#123; //设置值 cache[key] = value; keys.push(key);//把key存入数组 return cache[key]; &#125;else&#123; //取值 return cache[key]; &#125; &#125; &#125;//开始计算 var count = 0;function FiboByCache()&#123; var cache = cacheFactory(50); function fibo(n)&#123; count++; if(cache(n) !== undefined)&#123; //缓存有值，直接返回 return cache(n); &#125; //没有，就计算，并加入缓存 if(n &lt;= 2)&#123; cache(n,1); return 1; &#125; var temp = fibo(n -1) + fibo(n -2); cache(n,temp); return temp; &#125; return fibo;&#125;var fib = FiboByCache();console.log(\"计算5的返回值: \"+fib(5)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算6的返回值: \"+fib(6)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算20的返回值: \"+fib(20)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算21的返回值: \"+fib(21)+\" ，运算了 【 \"+count+\" 】次\"); 结果为： 可见，性能有了很好的提升. = = 最后的最后，通过阅读JQuery源码中对于缓存的写法，在此将上述的缓存代码修改，更加简洁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function cacheFactory(capacity) &#123; var keys = []; //存储键的数组 if (capacity === undefined) &#123; throw &#123; \"errCode\": 4, \"errMsg\": \"请定义缓存容量!\" &#125; &#125; function cache(key, value) &#123; if (keys.push( key + \" \") &gt; capacity ) &#123; delete(cache[keys.shift()]); &#125; return (cache[key + \" \"] = value); &#125; return cache;&#125; //使用方法 var cache = cacheFactory(3); //存值,存值用\"方法\"传入key和value cache(\"key1\",\"valueA\"); cache(\"key2\",\"valueB\"); cache(\"key3\",\"valueC\"); cache(\"key4\",\"valueD\"); //取值，取值用\"属性\"获取的方式[]，而不是再方法传参了 console.log(cache[\"key1 \"]);//undefined 大于容量会被清除缓存 1.因为函数也是对象，直接把闭包返回的函数作为“缓存的对象”，不需要额外定义一个cache{}对象了 2.直接将key存入键数组，返回值为该数组的新长度，如果他的长度大于容量，直接弹出第一个最旧的key，并且从这个函数“缓存对象中”delete 3.这里存key和取key都需要加上空格” “,因为我们是把这个函数对象来缓存数据的，也就是给他加上静态成员变量。为了避免覆盖函数对象原来定义好的内部原生成员变量，所以所有key都加上空格” “ 比如，如果我们存入的缓存值的key为toString，则会覆盖function cache(key,value){}对象的toString方法，所以取值和设值，key都要加上空格.存值并且返回(存值也就是给function对象加上静态属性) 我们可以这么使用他 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var count = 0;function FiboByCache() &#123; var cache = cacheFactory(50); function fibo(n) &#123; count++; if (cache[n+\" \"] !== undefined) &#123; //缓存有值，直接返回 return cache[n +\" \"]; &#125; //没有，就计算，并加入缓存 if (n &lt;= 2) &#123; cache(n, 1); return 1; &#125; var temp = fibo(n - 1) + fibo(n - 2); cache(n, temp); return temp; &#125; return fibo;&#125;var fib = FiboByCache();console.log(\"计算5的返回值: \" + fib(5) + \" ，运算了 【 \" + count + \" 】次\");count = 0;console.log(\"计算6的返回值: \" + fib(6) + \" ，运算了 【 \" + count + \" 】次\");count = 0;console.log(\"计算20的返回值: \" + fib(20) + \" ，运算了 【 \" + count + \" 】次\");count = 0;console.log(\"计算21的返回值: \" + fib(21) + \" ，运算了 【 \" + count + \" 】次\");","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（二）JS的变量声明提升","date":"2017-04-09T09:38:22.000Z","path":"2017/04/09/JSNotes（二）JS的变量声明提升/","text":"JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。我们来看下面这个例子： 12345func();function func()&#123; alert(\"Funciton has been called\");&#125; 在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来Function has been called。 所以，可以得出结论，JavaScript并非仅在运行时简简单单的逐句解析执行！ JavaScript 预解析JavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块提前进行处理。 关键问题是怎么处理呢? 当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。 函数预解析1.普通函数形式12345func();function func()&#123; alert(\"Funciton has been called\");&#125; 由于JavaScript的预解析机制，上面的代码就等效于： 12345function func()&#123; alert(\"Funciton has been called\");&#125;func(); 2.函数表达式形式1234567func(); var func = function()&#123; console.log(1); &#125; 预解析后：123456789var func; func(); func = function()&#123; console.log(1); &#125; 总结：函数的预解析，普通的function func(){}函数会全体提升，而函数表达式var func = function(){}只会提升var func;声明，函数体不提升。看完函数声明的提升，再来看一个变量声明提升的例子： 123alert(a);var a = 1; 由于JavaScript的预解析机制，上面这段代码，alert出来的值是undefined，如果没有预解析，代码应该会直接报错a is not defined，而不是输出值。 Wait a minute, 不是说要提前的吗？那不是应该alert出来1，为什么是undefined? 那么在这里有必要说一下声明、定义、初始化的区别。其实这几个概念是C系语言的人应该都比较了解的。 行为 说明 声明 告诉编译器/解析器有这个变量存在,这个行为是不分配内存空间的,在JavaScript中，声明一个变量的操作为：var a; 定义 为变量分配内存空间，在C语言中，一般声明就包含了定义，比如：int a;,但是在JavaScript中，var a;这种形式就只是声明了。 初始化 在定义变量之后，系统为变量分配的空间内存储的值是不确定的，所以需要对这个空间进行初始化，以确保程序的安全性和确定性 赋值 赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作（修改存储空间内的数据) 所以我们说的提升，是声明的提升。 那么再回过头看，上面的代码就等效于： 12345var a; //这里是声明alert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefineda = 1; 复杂点的情况分析通过上一小节的内容，我们对变量、函数声明提升已经有了一个最基本的理解。那么接下来，我们就来分析一些略复杂的情况。 函数同名观察下面这段代码: 1234567891011func1();function func1()&#123; console.log('This is func1');&#125;func1();function func1()&#123; console.log('This is last func1');&#125; 输出结果为： 123This is last func1This is last func1 原因分析：由于预解析机制，func1的声明会被提升，提升之后的代码为： 1234567891011function func1()&#123; console.log('This is func1');&#125;function func1()&#123; console.log('This is last func1');&#125;func1();func1(); 同名的函数，后面的会覆盖前面的，所以两次输出结果都是This is last func1。 变量和函数同名12345alert(foo);function foo()&#123;&#125;var foo = 2; 当出现变量声明和函数同名的时候，其实变量声明和函数都会提升，但是函数提升的更高，在变量声明的上方，所以上面的代码的输出结果为 1function foo()&#123;&#125;//这是一段字符串,因为是alert里的 我们还是来吧预解析之后的代码展现出来: 1234567function foo()&#123;&#125;;var foo;//没什么影响,可以忽略这句alert(foo);foo = 2; 再来看一种 1234567var num = 1;function num () &#123; alert( num );&#125;num(); 代码执行结果为： 1Uncaught TypeError: num is not a function 直接上预解析后的代码： 1234567function num()&#123; alert(num);&#125;var num; //没什么影响,可以忽略这句num = 1; //把num的地址由函数体改为1了num(); //Uncaught TypeError: num is not a function 总结：123456//a)console.log(num);//function num()&#123;&#125; var num = 123; function num()&#123;&#125;; 和1234//b) var num = 123; function num()&#123;&#125;;console.log(num);//123 为啥会有这样的区别？ 预解析后的代码: 12345//a)function num()&#123;&#125;;var num;//没什么影响,可以忽略这句console.log(num);//function num()&#123;&#125;num = 123; 和12345678//b)function num()&#123;&#125;;var num;//没什么影响,可以忽略这句num = 123;console.log(num);//123 看出来了吗？ ❤当函数和变量同名时，其实函数和变量声明都会提升，但是函数比变量声明提升的还要多，在该作用域顶部。123456 var num = 123; function num()&#123;&#125;;console.log(num);//123 预解析后就是1234567 function num()&#123;&#125;; var num;//没什么影响,可以忽略这句num = 123;console.log(num);//123 a)与b)的区别就是一开始cosole.log(num);的顺序不同导致第二个num = 123在console.log(num);之前。num = 123这句话就是把上面的num函数的地址引用指向了123导致结果与a)不同的 预解析是分作用域的声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。 123456function showMsg()&#123; var msg = 'This is message';&#125;alert(msg); // msg未定义 还是直接把预解析之后的代码写出来： 1234567function showMsg()&#123; var msg; msg = 'This is message';&#125;alert(msg); // msg未定义 预解析是分段的分段，其实就分script标签的 123456789101112131415161718192021&lt;script&gt;func(); // 输出 AA2;function func()&#123; console.log('AA1');&#125;function func()&#123; console.log('AA2');&#125;&lt;/script&gt;&lt;script&gt;function func()&#123; console.log('AA3');&#125;&lt;/script&gt; 在上面代码中，第一个script标签中的两个func进行了提升，第二个func覆盖了第一个func，但是第二个script标签中的func并没有覆盖上面的第二个func。所以说预解析是分段的。 tip:但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。 函数表达式并不会被提升12345func();var func = function()&#123; alert(\"我被提升了\");&#125;; 这里会直接报错，func is not a function，原因就是函数表达式，并不会被提升。只是简单地当做变量声明进行了处理，如下： 1234567var func;func();func = function()&#123; alert(\"我被提升了\");&#125; 条件式函数声明123456789console.log(typeof func);if(true)&#123; function()&#123; return 1; &#125;&#125;console.log(typeof func); 上面这段代码，就是所谓的条件式函数声明，这段代码在Gecko引擎中打印&quot;undefined&quot;、&quot;function&quot;；而在其他浏览器中则打印&quot;function&quot;、&quot;function&quot;。 原因在于Gecko加入了ECMAScript以外的一个feature：条件式函数声明。 Conditionally created functions Functions can be conditionally declared, that is, a function declaration can be nested within an if statement. &gt; Note: Although this kind of function looks like a function declaration, it is actually an expression (or statement), since it is nested within another statement. See differences between function declarations and function expressions. Note中的文字说明，条件式函数声明的处理和函数表达式的处理方式一样，所以条件式函数声明没有声明提升的特性。 最重要的小练习来了！ 例一1234567891011function foo() &#123; var num = 123; console.log(num); //? &#125; foo(); console.log(num); //? 预解析(声明提升)后的代码 123456789101112131415//预解析function foo() &#123;var num;num = 123;console.log(num); //?123&#125;foo();console.log(num); //?报错，num is not defined Tips: ① is not defined 没有定义 是报错 ② undefined 定义了没有赋值 –打印undefined 例二12345678910111213var scope = \"global\"; foo(); function foo() &#123; console.log(scope); //？undefined var scope = \"local\"; console.log(scope); //？ local &#125; 预解析(声明提升)后的代码12345678910111213141516171819//预解析var scope;function foo()&#123;var scope;console.log(scope); //？undefinedscope = \"local\";console.log(scope); //？ local&#125;scope = \"global\";foo(); 例三1234567891011121314151617181920212223function f1()&#123;var a;if(\"a\" in window)&#123;var a = 10;&#125;alert(a); // ?&#125;f1();if(!\"a\" in window)&#123;var a = 10;&#125;alert(a); // ? 预解析(声明提升)后的代码123456789101112131415161718192021222324252627//预解析function f1()&#123;var a;if(\"a\" in window)&#123;a = 10;&#125;alert(a); //10&#125;f1();var a;if(!\"a\" in window)&#123;a = 10;&#125;alert(a); // ? undefined Tips:in 关键字1.用法一 遍历对象 for(var key in 对象名){} 2.用法二 判断属性(数值就是索引值)是否存在对象中,返回boolean if( a in obj){…} 3.用法三 判断数组是否存在某个键 注意!关键字判断数组的时候是判断索引是否存在,而不是值 if(1 in arr){..} 是判断arr数组有没有1索引，感觉挺鸡肋是吧？那么怎么判断数组中是否有指定值呢？ 如何判断数组中是否存在指定的值 arr.indexOf 找到返回指定元素的索引值, 没有找到返回-1 例四123456789101112131415var foo = 1;function bar() &#123;if(!foo) &#123;var foo = 10;&#125;alert(foo); //??10&#125;bar(); 预解析(声明提升)后的代码 123456789101112131415161718192021//预解析var foo;function bar()&#123;var foo;if(!foo) &#123; foo = 10;&#125;alert(foo); //??10&#125;foo = 1;bar(); Tips:foo是undefined，undefined和null作为boolean判断都为false，null参与数值运算是0，undefined参与数值运算是NaN例五 （大题）123456789101112131415161718192021222324252627282930 function Foo() &#123;getName = function()&#123; alert(1); &#125;;return this;&#125;Foo.getName = function() &#123; alert(2); &#125;; //AFoo.prototype.getName = function()&#123; alert(3); &#125;; //Bvar getName = function() &#123; alert(4); &#125;; //Cfunction getName()&#123; alert(5); &#125; //DFoo.getName(); // ?getName(); // ?Foo().getName(); // ?getName(); // ? new Foo.getName(); // ?new Foo().getName(); // ?new new Foo().getName(); // ? 预解析(声明提升)后的代码 123456789101112131415161718192021222324252627282930313233343536//预解析之后 function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this; &#125; var getName; function getName()&#123; alert(5); &#125; //D Foo.getName = function() &#123; alert(2); &#125;; //A Foo.prototype.getName = function()&#123; alert(3); &#125;; //B getName = function() &#123; alert(4); &#125;; //C Foo.getName(); // ? getName(); // ? Foo().getName(); // ? getName(); // ? 4 // new Foo.getName(); // ? new Foo().getName(); // ? new new Foo().getName(); // ? 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1) Foo.getName(); // ? 由于B句是给Foo构造函数添加静态方法 因为已经添加过了，所以此处可以直接调用Foo的静态方法 结果：alert(2) // 2) getName(); // ? 这里去全局找getName()方法，但是看到D和C句都是全局的getName方法，由于C句经过预解析后在下方，所以层叠掉了预解析后的上方的④句，所以调用的是C句这个全局getName方法 结果：alert(4) // 3) Foo().getName(); // ? 这里是调用Foo()方法[注意：Foo()既可以当作构造函数，也可以直接调用执行] 调用Foo()方法的过程中，第一行getName = function()&#123; alert(1); &#125;;，先在Foo()函数创造的作用域内寻找getName，发现没有，就去全局找，找到了C句，所以将其修改为function()&#123; alert(1); &#125;;，所以记住，此时全局的C句的getName方法改为alert(1)了，然后第二行return this;因为是普通的全局调用函数，所以this指向window，即window.getName(); 也就是在全局调用getName方法，此时的全局的C句getName方法已经被修改为alert(1)了，而且预解析后，C句把D句层叠了，所以此处为调用修改后的C句 结果：alert(1) // 4) getName(); // ? 这里就是全局调用getName方法,C句把D句层叠了，而且C句也被修改成alert(1)了 结果: alert(1) // 5) new Foo.getName(); // ? 这里的new Foo.getName()，是先执行后面的Foo.getName()，再执行new,由第一题可知，之前A句就给Foo构造函数添加了静态方法getName,所以可以直接执行Foo构造函数的静态getName方法,为alert(2),由于alert语句执行结束返回值为undefined,new undefined没效果，就不管了 结果：alert(2) // 6) (new Foo).getName(); 这题和上一题不同的是给new Foo加了括号，优先执行。 注意：如果构造函数没有参数的话，可以不写()来new实例对象，所以这个等效于(new Foo()).getName(); function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this; &#125; 这是Foo()构造函数，他内部并没有属性和方法[this.xxx = xxx,this.xxx = function()&#123;xxx&#125;才叫他的成员属性/方法，能给实例对象的] 所以new Foo()出来的实例对象没有成员属性/方法,只有一个__proto__ 既然内部没有，就去原型里找，由B句可知，给Foo的原型绑定了一个getName方法，所以可以通过new Foo()出来的实例仅有的__proto__来调用他原型的getName方法 结果：alert(3) // new Foo().getName(); // ? 同上 结果：alert(3) // new new Foo().getName(); // ? 先new Foo()，再调用getName()，同第6)题，实例对象没，就去原型找，然后执行完毕alert(3)后返回undefined，new undefined 没意义。 结果: alert(3)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（一）JS的作用域","date":"2017-04-09T09:36:29.000Z","path":"2017/04/09/JSNotes（一）JS的作用域/","text":"作用域 作用：起作用 域：范围 变量起作用的范围就是变量的作用域 1.块级作用域 JavaScript中没有块级作用域 如果有块级作用域下面的代码的显示结果为 undefined undefined 1234567for(var i=0; i&lt;10;i++)&#123; var num = i;&#125;console.log(i);console.log(num); 但是Js没有块级作用域，所以结果为:10 9 2.词法作用域什么是词法作用域？ 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域. 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 例子1：123456789101112var a = 123; function f1()&#123; console.log(a); &#125; function f2()&#123; var a = 456; f1(); &#125; f2(); //123 词法作用域就是在代码写好的那一刻，变量的作用域就确定了。所以调用f2(),f2内部再调用f1时，f1()打印的a就是f1()函数写好时确定的a，也就是全局的var a=123 例子2：12345if ( false ) &#123; var num = 123;&#125;console.log( num ); // undefiend 这里的if(){}块不具备作用域，所以num声明可以提升出来为：123456789var num;if ( false ) &#123; num = 123;&#125;console.log( num ); // undefiend 例子3：1234567891011121314var num = 123;function foo() &#123; var num = 456; function func() &#123; console.log( num ); &#125; func();&#125;foo(); 3.函数级作用域在JavaScript中唯一能产生作用域的东西是 函数！ 也就是在function(){}内才能有他的作用域，访问权限，o(︶︿︶)o 唉~ 这点要牢记，JavaScript中只有函数和全局作用域！除去默认的全局作用域，也就只有函数能产生作用域了！！ 12345678var a = 1;function test()&#123; var b = 10;&#125; 这里就有着函数的作用域，导致变量提升只能在作用域内，为123456var a;a = 1;function test()&#123; var b; b = 10;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"AtomicInteger：支持原子性操作，基于CAS实现了乐观锁","date":"2017-03-29T09:28:42.000Z","path":"2017/03/29/AtomicInteger：支持原子性操作，基于CAS实现了乐观锁/","text":"AtomicInteger,一个提供原子操作的Integer的类。在java.util.concurrent.atomic包中。 一、使用场景在多线程环境中，AtomicInteger的使用场景就是提供一些原子性的数值改变，不会出现多个线程下的数据不一致问题。例如：仓库总量的增减，ID的顺序获取等。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。对于并发情况下，我们加锁的方式通常有两种：悲观锁和乐观锁。 二、悲观锁和乐观锁 悲观锁 在并发情况下，它假设最坏的情况，在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。这种方式将需要事务管理的代码块一律加上同步synchronized，这种独占锁会将其他线程挂起阻塞住，直到该事务结束后才将资源放出。线程的挂起和恢复过程，开销是很大的，当线程被挂起等待时，无法做任何事，而notify()或notifyAll()重新唤醒后又将开始新的资源争用，如果某个线程”人品很差”，一直被阻塞，争用不到资源，事务的执行会等待很久，效率很低。 在计算机组成原理这本书中提到，cpu是时分复用的，cpu的时间片，分配给不同的thread、process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。 小栗子：线程的挂起和恢复执行过程中存在着很大的开销。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。 乐观锁：每次不加锁，假设没有冲突而去完成操作。他的思路是：每次不加锁，认为大家都很自觉，不会发生数据冲突，万一发生冲突就自我重试，重新再去获取新值再来一遍，不影响其他线程，直到成功为止，就不像悲观锁那么自私霸道。对于数据库的增删改查，只有在最后提交的时候才会去检查，通常我们采用一个版本号version字段来检查该线程此时获取的数据是否被修改了，“是否还是往日的她”。每次comit时会检查该线程持有的版本号是否和实际版本号一致，如果不一致说明该数据已经被修改了，此时提交是不安全的，无法保证数据一致性，对于这种冲突，发生就无限循环重试，重新获取新的值和版本号，再在cpu争用中等到调度自己时再去尝试比对提交，直到成功为止。在上面的例子中，某个线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。三、什么是CASCAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 JDK1.5中引入了底层的支持，在int、long和对象的引用等类型上都公开了CAS的操作，并且JVM把它们编译为底层硬件提供的最有效的方法，在运行CAS的平台上，运行时把它们编译为相应的机器指令。在java.util.concurrent.atomic包下面的所有的原子变量类型中，比如AtomicInteger，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作。 四、 AtomicInteger实现CASAtomicInteger 是一个支持原子操作的 Integer 类，就是保证对AtomicInteger类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。 通过两个简单的例子来看一下 AtomicInteger 的优势在哪:普通线程同步: 1234567891011class Test2 &#123; private volatile int count = 0; public synchronized void increment() &#123; count++; //若要线程安全执行执行count++，需要加锁 &#125; public int getCount() &#123; return count; &#125;&#125; 使用AtomicInteger: 1234567891011class Test2 &#123; private AtomicInteger count = new AtomicInteger(); public void increment() &#123; count.incrementAndGet(); &#125; //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。 public int getCount() &#123; return count.get(); &#125;&#125; 从上面的例子中我们可以看出：使用AtomicInteger是非常的安全的.而且因为AtomicInteger由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。 五、 AtomicInteger源码查看接下来通过源码来看AtomicInteger具体是如何由硬件来实现原子操作的。 AtomicInteger继承了Number类并且实现了Serializable接口，支持序列化 1public class AtomicInteger extends Number implements java.io.Serializable &#123;...&#125; 构造函数 1234567891011121314 private volatile int value;/** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */ public AtomicInteger() &#123;&#125; 可以看出，AtomicInteger提供了空构造函数和赋值构造，对与空构造函数(AtomicInteger count = new AtomicInteger();)，其默认值为0。而赋值构造，其value值是被volatile修饰的int值 volatile 变量可以被看作是一种 “程度较轻的 synchronized” 锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。① 互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。② 可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。 Volatile变量具有 synchronized 的可见性特性，但是不具备原子特性。也就是说线程能够自动发现 volatile 变量的最新值。 下面是他的一些方法12345678910111213141516171819//获取当前的值public final int get();//取当前的值，并设置新的值 public final int getAndSet(int newValue);//获取当前的值，并自增 public final int getAndIncrement();//获取当前的值，并自减public final int getAndDecrement();//获取当前的值，并加上预期的值public final int getAndAdd(int delta); 同理，还有一些与之相反的incrementAndGet、decrementAndGet、addAndGet等，从名称可知， 分别是自增后返回新值，自减后返回新值，加上预期值后返回新值。他们的实现大致一样，只是返回值前者为return current;而后者为return next; 来看看incrementAndGet() 方法，下面是具体的代码。 12345678910111213/** * Atomically increments by one the current value. * * @return the updated value */ public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; 通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面，compareAndSet()方法的代码如下： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; 我们继续跟踪到compareAndSet()方法调用的compareAndSwapInt()方法，他是一个native方法。 1publicfinal native boolean compareAndSwapInt(Object var1, long var2, int var4, intvar5); compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet所做的为调用 sun.misc.Unsafe的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。 类似的，还有decrementAndGet()方法。它和incrementAndGet()的区别是将 value 减 1，赋值给next 变量。","tags":[{"name":"高并发与多线程","slug":"高并发与多线程","permalink":"http://yoursite.com/tags/高并发与多线程/"}]},{"title":"JQuery插件总结","date":"2017-03-19T14:46:23.000Z","path":"2017/03/19/JQuery插件总结/","text":"一、Jquery Full Page 全屏滚动","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"CSS3入坑记（二）","date":"2017-03-14T05:38:34.000Z","path":"2017/03/14/CSS3入坑记（二）/","text":"一、边框 边框圆角 border-radiusa)border-top-left-radius：水平半径 垂直半径b)border-radius：顺时针四个方向的切圆水平半径/顺时针四个方向的切圆垂直半径 c)单位：百分比(相对于自身宽高)和像素d)最好使用%e)img 也可以使用圆角，但是效果通常不怎么样 边框图片a)路径border-image-sourceb)裁剪border-image-slicec)平铺border-image-repeat:可选value值如下i.repeat平铺（无优化，就是普通的平铺，在四角交界处可能会有误差）ii.round：平铺（优化过的repeat,很完美哦）iii.stretch：拉伸(默认值，宽和高谁长就拉伸谁，不平铺)d)边框宽度：border-image-width:通常设置和裁剪slice一个数值，但是slice没单位，width单位为px eg:先选择一张边框素材图： 由fireworks测量得知一个小方块大小27px，所以border-image-slice值为27，同时，border-image-width值为27px;CSS: 12345678910111213div&#123; width: 500px; height: 400px; border: 1px solid transparent; /*新版chrome浏览器需要先写border，在把border-image属性设置在 border之后才能显示图片边框*/ border-image-source: url(\"images/border.png\"); border-image-slice: 27; border-image-width: 27px; border-image-repeat: round; margin: 100px auto; padding: 2em; box-sizing: border-box;/*内减模式*/&#125; html: 123&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 效果： 二、背景一）backgrounf-size：背景大小，其可选value值如下： 1.背景尺寸：数值，百分比，和普通的图片设置一样 2.cover覆盖：图片等比例放大，保证完全覆盖混盒子，不保证完全显示。会超出，但是这个值使得背景图片，有一定的自适应效果【背景绝对会完全铺满，不留空白，但是有可能会超出部分不显示】 3.contain包含 : 最大化的等比例显示在盒子中。不会铺满盒子，有一定的自适应效果【可能会背景铺不满，有空白】 4.cover,contain都会自适应盒子尺寸,个人偏爱cover一点，因为他不会留白啊 二） background-origin ： 背景原点 a) 默认背景从padding-box开始平铺 b) background-origin 可选value值： border-box、padding-box(默认)、 content-box 效果图： padding-box(默认值) border-box： content-box： 三）background-clip ： 背景裁剪 ,可选属性值如下： a) border-box b) padding-box c) content-box d) 设置谁，超出谁的就裁减掉 e) clip属性值要是比原点的范围大，不起作用 tips1.背景裁剪和背景原点移动，移动web会用到tips2.多背景用逗号隔开tips3.背景颜色写在最后或者单独写 三、渐变：还是属于背景，是颜色渐变一） 线形渐变【linear-gradient】 (等同于background-image)【用的是to】 1.设置完gradient之后仍然可以当作background-image 来设置宽高，repeat之类属性 2.background-image：linear-gradient（方向，起始颜色，终止颜色）； 方向： to right：从左到右 to left 到左 to top 到上 方向还可以定义角度 ，单位为 deg 3.多颜色渐变(百分比就是盒子从这个方向开始，进行到百分之多少就换颜色)【渐变是模糊的样子】 1background-image: linear-gradient(to right,red 0%,blue 30%,yellow 60%); 4.颜色突变【图片就是色彩分明】 1background-image: linear-gradient(to right,red 0%,red 30%,blue 30%,blue 60%,yellow 60%,yellow 100%); （注：背景渐变可以当作background-image来设置background-size、repeat等） 二） 径向渐变【radial-gradient】【用的是at】 1.radial-gradient（辐射半径 中心点位置，起始颜色，终止颜色） 2.中心点颜色，at left，right，top，bottom，center 3.at 50px（水平距离） 50px（垂直距离） 径向渐变就是在盒子某一处为圆心，设置好半径来辐射 四、过渡（这个可厉害了!CSS3实现动画啊！） 1.transition：过渡属性 过渡持续时间 加速度（linear：匀速） 延迟时间 a)transition-property：过渡属性 b)transition-duration：过渡持续时间 (几秒动画结束) c)transition-timimg-function：加速度如何，其取值如下： 1.linear：匀速 2.ease：减速 3.ease-in：加速 4.ease-out：减速 5.ease-in-out：先加速后减速 d)transition-delay：过渡延迟 2.如果需要所有属性都过渡 a)transition-property：all 【写all性能不好】 可以写成这样:transition:transform 2s;意思为，只有transform(rotate,translate,scale)变换给他过渡,其他的宽高背景色之类的不给过渡。 最后：简写方法： 1transition:all 0.7s ease-in-out; 五、2D变换 1.transform:其value值如下： 缩放（scale）、位移（translate）、旋转（rotate） tips:变换后不会影响其他盒子，很乖巧吧！~ 2.缩放scale（倍率） a)不可以写百分数 b)大于1是放大，小于1缩小 (eg: transform:scale(2,0.5);【水平放大2倍，竖直缩小一半】) c)写一个值，宽高等比缩放 d)内容也会等比缩放e)写两个值，第一个是水平缩放倍率，第二个是垂直缩放倍率 3.位移translate（） a)右移正数，左移负数（右下为正，左下为负） b)第一个值水平移动，第二个值垂直移动距离 c)可写百分比数值，相对与自身的尺寸d)盒子在父盒子中居中方法【translate引申运用！】 width: 300px; height: 150px; ``` ```cssleft: 50%; 12margin-left: -150px; ``` ```css /*推荐方法，利用translate位移向左移动50%*/ left:50%; transform:translate(-50%); 4.旋转：rotate（角度） a) 正值顺时针，负值逆时针 b) 旋转中心：transform-origin：水平坐标 垂直坐标 c) 默认旋转中心：几何中心 未完待续。。。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"CSS3入坑记(一)","date":"2017-03-13T16:22:15.000Z","path":"2017/03/14/CSS3入坑记(一)/","text":"一、给力的选择器 1.标签选择器。 类名选择器，id选择器。后代选择器，标签指定（交集）选择器 。并集选择器，子代选择器，通配符等基础的选择器 a)div+p：选择div后第一个兄弟p（紧跟div）还是兄弟关系哦 b)div~p：选择div后所有兄弟P 大家都是兄弟，给良辰一个面子 2.属性选择器 tips：通过标签属性来选择 ①div[属性] ②div[class^=‘aa’]：有class属性并且属性属性值以aa开头③div[class$=‘aa’]：有class属性并且属性属性值以aa结尾④div[class*=‘aa’]：有class属性并且属性属性值包含aa 3.伪类选择器 伪类，伪元素都可以修饰dom元素，但是伪类还是类，对整个类进行修饰 3.1 普通伪类 ①：link ：正常状态 ②：visited 已访问过的链接 ③：hover 鼠标经过 ④：action 点击 ⑤:lvha 3.2 结构伪类 所选到的标签类型必须是E否则无效 E ：first-child：选择E父盒子中的第一个E E ：last-child：选择E父盒子中的最后一个E E ：nth-child（5）：选择E父盒子中的第5个E（标号从1开始） E ：nth-child（odd/even）：选择E-父盒子中编号为奇数/偶数的E标签 a) E ：nth-child（2n）：选择E父盒子中的所有编号为偶数的E b) E：nth-child（2n+1）：选择E父盒子中的所有编号为奇数的E E ：nth-child（n）：选择E父盒子中的所有E a) n &lt; 1无效 E ：nth-child（n）：选择E父盒子中的所有E，-n全不选 E ：nth-child（-n+5）：选择E父盒子中的前五个E标签 E ：nth-last-child(1):倒数第一个 E ：nth-last-child（-n+5）：选择倒数第五个 E ：nth-child（7n）：选择编号为7的倍数的标签 E ：nth-child（7n-1）：选择编号为7的倍数减1的标签 3.3状态伪类 E:empty 如果盒子是空的就会被选中 E:target 通常和锚点配合使用，比如一个h2标签代表一段的标题，然后通过锚点到达该处，该h2就会显示出相应的样式 4.伪元素 伪元素只是元素，他只能修饰被修饰者内部的某一部分内容，而非整个类 1) 伪就是假的，通过css模拟出html效果，必须有content属性 2) 伪元素虽然可以单:，但是在CSS3规范中规定伪类用:，伪元素用双:: 3) ::before，在之前添加 123div::before&#123; content : \"在前面\"; &#125; 4) ::after，在之后添加 1234div::after&#123; content : \"在后面\"; color: #f00; &#125; 5) 产生的伪元素相当于div的子元素 6) 伪元素可以使用标签的属性(啥宽、高、bgc、display之类的)，如下eg: css:123456789101112span::before&#123; content: '今天'; background: paleturquoise; display: inline-block; width: 60px; height: 30px; &#125; span::after&#123; content: '真好'; background: darkseagreen; &#125; /*必须要写content*/ html: 123&lt;body&gt;&lt;span&gt;天气&lt;/span&gt;&lt;/body&gt; 效果： ::bofore和::after可以做图标放在字体前后 5 伪元素选择器选中盒子里的某一块区域1) ::frist-letter 选择第一个字母2) ::frist-line 选择第一行3) ::selection 选择区域的样式 (网页上选中一段文字一般是蓝色框和白色背景，可以自己换颜色)a)一般只设置背景颜色和字体颜色4) 通常用::first-letter和flaot:left以及字体加大设置首字下沉，如下：二、颜色的升级 设置透明色的话 传统的opcity属性会被子代继承，且子代的opacity属性不能修改，多可怕 transparent；完全透明，无法修改属性值，直接没了，你也太狠了 CSS3引入新的颜色方式 RGBA模式 a)红绿蓝 b)alpha（透明度） HSLA模式a)H:色相、色调 0-360（红橙黄绿青蓝紫）b)S:饱和度 0-100%c)L:明度 、亮度 0-100%d)A:透明度 0-1 tips：有颜色的地方都可以用半透明 三、文本阴影的引入 文本阴影a)text-shadow：水平距离 垂直距离 模糊程度 颜色*（注意：文本阴影前三个值单位为px，文本可以设置3个px属性，而box-shadow可以再多一个px属性为阴影面积）b)左下为正，右上为负c)一个文本可以有多个阴影，用逗号隔开，常用一黑一白的阴影来做凹凸字(黑白阴影模拟光照) 四、CSS3盒子模型(重点) 传统盒子模型传统盒子中，我们看到的：a)宽度 = padding+border+widthb)内容区域大小不变c)总体大小变化 CSS3盒子模型a) 可以给盒子设置box-sizing属性属性值为：content-box/padding-box/border-box 设置谁，谁不变 content-box：内容盒子，外加模式，整个盒子撑大,内容盒子不变，加大边距和边框会加大总体大小，内容区域大小不变 border-box：边框盒子，内减模式，整个盒子大小不变，内容盒子减小。加内边距和边框只会减小内容的大小 五、私有化前缀有些CSS属性浏览器无法识别时，可以在属性值前加上私有化前缀，以让浏览器识别。 可以解决兼容性 问题 -webkit- 谷歌、苹果浏览器内核 -moz- 火狐浏览器内核 -ms- IE浏览器内核 -o- 欧鹏浏览器内核 兼容性写法示例： 123456background: -webkit-linear-gradient(left,aquamarine,skyblue); background: -moz-linear-gradient(left,aquamarine,skyblue); background: -ms-linear-gradient(left,aquamarine,skyblue); background: -o-linear-gradient(left,aquamarine,skyblue); background: linear-gradient(left,aquamarine,skyblue); /*最后一行加上正常的不加私有化的*/ tips1：最后要加无前缀的样式tips2：加私有化前缀如果也无法解决，放弃 tips3：这里只是做个实例，一般线性渐变背景写法为： 1background: linear-gradient(to right,yellow 0%,pink 30%,blue 60%,red 100%); 接下来，让我们在CSS3入坑记（二）再相会！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Html5入坑记","date":"2017-03-11T09:30:07.000Z","path":"2017/03/11/Html5入坑记（一）/","text":"一、标准改变Html4.0 网页开发： html -&gt; 结构 4.0 Css -&gt; 样式 2.0 Js -&gt; 行为 用户交互HTML5.0 html4.0 升级版: Html5 -&gt; 结构 5.0 css3 -&gt; 样式 js -&gt; 行为 js API 有所增强 地理定位 web存储 拖拽 HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。广义概念：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器呈现技术得到了一个飞跃发展和广泛支持，它包括：HTML5，CSS3，Javascript，API在内的一套技术组合 H5范称HTML + CSS3 + JS优点：HTML5的优点 二、Html结构 新增语义化标签①语法规范，去除冗余内容，书写规则简洁、清晰。 dtd简洁、标签不用写关闭符号、双标签省略结束标签、html、head、body、colgroup、tbody可以完全省略 实际开发中应规范书写，不建议太随意 ！如图 ②新增语义标签12345678910&lt;nav&gt; //表示导航&lt;header&gt; //表示页眉&lt;footer&gt; //表示页脚&lt;section&gt; //表示区块&lt;article&gt; //表示文章 如文章、评论、帖子、博客&lt;aside&gt; //表示侧边栏 如文章的侧栏&lt;figure&gt; //表示媒介内容分组 与 ul &gt; li 做个比较&lt;mark&gt; //表示标记 (带用“UI”，不怎么用)&lt;progress&gt; //表示进度 (带用“UI”，不怎么用)&lt;time&gt; //表示日期本质上新语义标签与div、span没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别对于传统的网页布局，采用div+css，给div给定header,nav,section,aside,article,footer等class，h5新增了该语义化标签，便于理解和网站seoH5经典网页布局123456789101112&lt;!-- 头部 --&gt;&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;!-- 主体部分 --&gt;&lt;section&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/section&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt;h5兼容IE处理l less 小于t than 比e equal 等于g great 大于三、表单新特性——–①输入类型123456789101112email 输入email格式tel 手机号码 url 只能输入url格式number 只能输入数字search 搜索框range 范围 滑动条color 拾色器time 时间date 日期 不是绝对的--datetime 时间日期month 月份week 星期部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 ②新的表单标签 datalist : 可以和input关联起来,变成特殊的select 12345678910&lt;input type=\"text\" list=\"car\" title=\"\"&gt;&lt;!--可以用datalist和input关联起来--&gt;&lt;datalist id=\"car\"&gt; &lt;option&gt;宝马&lt;/option&gt; &lt;option&gt;宝骏&lt;/option&gt; &lt;option&gt;宝强&lt;/option&gt; &lt;option&gt;奥拓&lt;/option&gt; &lt;option&gt;奥迪&lt;/option&gt; &lt;option&gt;大众&lt;/option&gt;&lt;/datalist&gt; keygen 生成加密字符串 1234keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 服务器获取客户端的私钥后可用来和公钥比较判断是否被劫持过。 output 仅仅在页面表单里展示数据，没啥用，还不能提交 meter 表示度量器，不建议用作进度条 progress Min-width 三、表单属性 placeholder 占位符 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成，用于表单元素，也可用于表单自身(on[默认开启]/off) ‘ autofocus：自动获取焦点 novalidate 关闭验证，可用于form标签 required 必填项 pattern 正则表达式 验证表单 1手机号:&lt;input type=\"tel\" name=\"tel\" required=\"required\" pattern=\"^(\\+86)?1[3,5,8](\\d&#123;9&#125;)$\"&gt; 四、表单事件 oninput 用户输入内容时触发，可用于移动端输入字数统计 oninvalid 验证不通过时触发 五、多媒体 之前在网页上播放多媒体必须依赖第三方插件 mediaplay、flash插件等 现在在H5里面提高了视频、音频标签，可以不求人啦 audio音频标签、video视频标签 a)controls:播放控制条 b)autoplay：自动播放 c)loop：循环播放 d)音频支持：mp3/wav/ogg e)视频支持：mp4、ogg、webm tips：vidio格式为行内块 f)source引用方式来做兼容 123456&lt;audio controls&gt; &lt;source src = \"music.mp3\"&gt; &lt;source src = \"music.ogg\"&gt; &lt;source src = \"music.wav\"&gt; 抱歉，你的浏览器不支持音频标签 &lt;/audio&gt; 六、dom扩展Tips:Html5对dom进行了扩展，使得多出很多api来操作document(dom)，跟JQuery一样方便，还不用引入JQ的类库，妈妈再也不用担心我忘记带JQ类库啦! document 文档对象①类操作 1234561.var new = document.querySelector（“选择器”）//只会选择符合条件的第一个元素2.var newArr = document.querySelectorAll(“选择器”)3.box.classList.add(“类名”)：//添加类名4.box.classList.remove(“类名”)://删除类名5.box.classList.contains（“类名”）：//是否包含某个类名6.box.classList.toggle(“类名”)://切换类名 ②自定义属性（假设有一个class为box的div）1.自定义属性必须以data开头（格式：data-属性名=””） 1eg:&lt;div class=&quot;box&quot; data-myData=&quot;lalala&quot;&gt;&lt;/div&gt; 2.获取标签属性 a)原有属性 .box.属性名 b)自定义属性 .box.dataset[‘data后的部分’] eg: .box.dataset[‘myData’] 特别注意！:如果自定义属性的属性名为data-my-name，那么获取的时候要 .box.dataset[“myName”]","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"JQuery动画之动画队列和stop方法","date":"2017-03-06T12:08:39.000Z","path":"2017/03/06/JQuery动画之动画队列和stop方法/","text":"在介绍动画队列之前，先谈谈js的单线程和浏览器的事件驱动。 Javascript是单线程的【转】因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。 异步事件驱动前面已经提到浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。每个浏览器具体实现主事件队列不尽相同，在此不赘述。 浏览器不是单线程的虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程： javascript引擎线程 界面渲染线程 浏览器事件触发线程 Http请求线程 很多人弄不清，如果js是单线程的，那么谁去轮询大的Event loop事件队列？答案是浏览器会有单独的线程去处理这个队列。 Ajax异步请求是否真的异步? 很多人不清楚，既然说JavaScript是单线程运行的，那么XMLHttpRequest在连接后是否真的异步? 其实请求确实是异步的，这请求是由浏览器新开一个线程请求（见前面的浏览器多线程）。当请求的状态变更时，如果先前已设置回调，这异步线程就产生状态变更事件放到 JavaScript引擎的事件处理队列中等待处理。当浏览器空闲的时候出队列任务被处理，JavaScript引擎始终是单线程运行回调函数。javascript引擎确实是单线程处理它的任务队列，能理解成就是普通函数和回调函数构成的队列。 总结一下，Ajax请求确实是异步的，这请求是由浏览器新开一个&gt;线程请求，事件回调的时候是放入Eventloop单线程事件队列等候处理。 setTimeout(func, 0)为什么有时候有用？ 写js多的人可能发现，有时候加一个setTimeout(func, 0)非常有用，为什么？难道是模拟多线程吗？错！前面已经说过了，javascript是JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，setTimeout(func, 0)神奇在哪儿？那就是告诉js引擎，在0ms以后把func放到主事件队列中，等待当前的代码执行完毕再执行，注意：重点是改变了代码流程，把func的执行放到了等待当前的代码执行完毕再执行。这就是它的神奇之处了。它的用处有三个： ①让浏览器渲染当前的变化（很多浏览器UI render和js执行是放在一个线程中，线程阻塞会导致界面无法更新渲染） ②重新评估”script is running too long”警告 ③改变执行顺序 接下来，我们来聊聊JQuery的动画队列。【原】在用户触发动画事件时，也将会把动画方法放入队列中，以队列的方式执行。如下图，该粉色的div盒子，可以由上方的按钮触发滑入滑出动画。(最后一个停止先不看) 12345678910111213&lt;script&gt; $(document).ready(function () &#123; $(\"button:eq(0)\").click(function () &#123; $(\"div:eq(0)\").slideDown(\"slow\"); &#125;); $(\"button:eq(1)\").click(function () &#123; $(\"div:eq(0)\").slideUp(\"slow\"); &#125;); $(\"button:eq(2)\").click(function () &#123; $(\"div:eq(0)\").stop(true,true); &#125;); &#125;); &lt;/script&gt; 当依次点击滑入、滑出按钮时，会将slideDown和slideUp方法依次放入事件队列中，待处理完之前的事件后，会按两个方法入队列的顺序依次执行，也就是先执行slideDown再执行slideUp方法。如果我们将动画的执行时间设置的再慢些(动画方法中的参数:fast:200ms,normal:400ms,slow:600ms)，如3000ms时，你会看到该盒子会慢慢地展开，等完全展开完毕后才会再收起，这就是按入队列顺序执行动画。接下来就可以聊聊JQuery中的stop方法。该方法有三个参数(type,clearQueue, gotoEnd)，第一个type参数先不谈，方法的clearQueue, gotoEnd参数分别为什么意思呢？让我们通过实验来了解。 stop方法的上述2个参数默认都为false。 默认false,false ① 第一种情况:false,false (后续动画不停止,当前动画不继续执行,原地停下) 1$(\"div:eq(0)\").stop(false,false); ②第二种情况:true,false(后续动画停止，当前动画不继续执行,原地停下) 1$(\"div:eq(0)\").stop(true,false); ③第三种情况:false,true(后续动画不停止,当前动画立马执行完成) 1$(\"div:eq(0)\").stop(false,true); ④第四种情况:true,true; (后续动画停止,当前动画立马执行完成) 1$(\"div:eq(0)\").stop(true,true) 看到这，应该已经明白。第一个clearQueue参数代表是否停止后续动画(true表示停止后续动画),第二个 gotoEnd代表当前动画是立即完成还是直接原地停下(true表示当前动画立马执行完成，false表示当前动画立马原地停下)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JQuery选择器小结","date":"2017-03-05T07:45:53.000Z","path":"2017/03/05/JQuery选择器小结/","text":"先贴张图 “引号内选择器”以下选择器，都在$(“”)的双引号内写 一丶基本选择器 1234$(\"#top\") //id选择器，返回单个$(\"div\") //标签选择器，返回数组 $(\".box\") //类选择器，返回数组 $(\"*\") // 选择文档中所有元素，返回数组 二丶层级选择器 1234$(\"form input\") //选择所有的后代 $(\"div &gt; .box\") //选择子代(亲儿子)$(\"label + input\") //[返回]label标签后面直接跟一个input标签的所有[input标签] $(\"#prev ~ div\") //同胞选择器，[返回]id为prev的所有同父[div同胞] 三丶基本过滤选择器 123456789101112$(\"tr:even\") //返回偶数tr（注意：返回数组，序号从0开始,0,2,4..） $(\"tr:odd\") //返回奇数tr $(\"td:eq(2)\") //索引等于2的td $(\"td:gt(4)\") //索引大于4$(\"td:ll(4)\") //索引小于4 $(\"tr:first\") //所有tr元素的第一个 $(\"tr:last\") //所有tr元素的最后一个 $(\"input:checked\") //所有被选中的input$(\"input:not(:checked)\") //所有没被选中的input$(\":header\") //所有的标题元素(h1-h6)$(\"div:animated\") //所有正在运动的div 四丶内容过滤选择器 (根据内容来选择) 1234$(\"div:contains('github')\") //选择所有div中含有github文本的[div]$(\"td:empty\") //选择所有内容为空（也不包括文本节点）的[td]$(\"div:has(p)\") //选择所有含有p标签的[div元素] $(\"td:parent\") //选择已为人父的[td](有子标签或文本都算为人父) 五丶可视化过滤选择器 12$(\"div:hidden\") //被hidden的div元素 $(\"div:visible\") //可视化的div元素 六丶属性过滤选择器 (根据属性来选择) 1234567$(\"div[id]\") //选择所有含有id属性的div元素 $(\"input[name='news']\") //选择name属性为'news'的input元素$(\"input[name!='newsletter']\") //选择name属性不为'news'的input元素$(\"input[name^='news']\") //选择name属性以'news'开头的input元素 $(\"input[name$='news']\") //选择name属性以'news'结尾的input元素 $(\"input[name*='color']\") //选择name属性包含'color'的input元素$(\"input[id][name$='color']\") //多个属性联合选择 七丶子元素过滤选择器 123$(\"div span:first-child\") //返回所有的div元素的第一个子节点的数组 $(\"div span:last-child\") //返回所有的div元素的最后一个节点的数组 $(\"div button:only-child\") //只有唯一一个子节点的所有子节点的数组 八丶表单元素选择器： 1234567891011$(\":input\") //所有的表单元素，input, textarea, select等 $(\":text\") //所有的text input元素 $(\":password\") //所有的password input元素 $(\":radio\") //所有的radio input元素 $(\":checkbox\") //所有的checkbox input元素 $(\":submit\") //所有的submit input元素 $(\":image\") //所有的image input元素 $(\":reset\") //所有的reset input元素 $(\":button\") //所有的button input元素 $(\":file\") //所有的file input元素 $(\":hidden\")//所有hidden input元素 九丶表单元素过滤选择器 1234$(\":enabled\") //选择所有的可操作的表单元素 $(\":disabled\") //所有的不可操作的表单元素 $(\":checked\") //所有的被checked的表单元素 $(\"select option:selected\") //所有的select的子元素option中被selected的option “方法调用选择器”以下都为【方法】，需要在$(“”)外.方法() 1234567.find(selector) //后代查找.children(selector) //子代查找.parent(selector) //查找亲父亲.siblings(selector) //查找所有兄弟.eq(index) //相等查找.prev(selector) //查找前一个兄弟.next(selector) //查找后一个兄弟 1注：方法中有selector，为选择器的意思，如果方法不加参数，默认选择，加了参数就多了一层筛选，比如$(\".box\").find()为查找class为box的所有后代，而$(\".box\").find(\"ul\")为查找它的所有ul后代而非全部后代","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"第二章 Java内存区域与内存溢出异常","date":"2017-03-02T06:10:10.000Z","path":"2017/03/02/第二章-Java内存区域与内存溢出异常/","text":"2.2 运行时数据区域 图1.1 Java虚拟机运行时数据区 2.2.1 程序计数器 (线程私有) 程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都依赖这个计数器。java多线程是通过处理器轮流切换并分配处理器执行时间的方式来实现，在一个处理器，或者多核处理器的一个内核中，都只会执行一条线程中的指令，为了在java多线程切换后能回到正确的执行位置，所以程序计数器是每个线程独立独占的。 线程执行：Java方法： 计数器记录的是正在执行的虚拟机字节码指令的地址。Native方法： 计数器为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OOM情况的区域。 2.2.2 Java虚拟机栈 (线程私有) 生命周期与线程相同,虚拟器栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储 局部变量表、操作数栈、动态连接、方法入口等。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：存放编译期可见的各种数据类型(boolean,byte,char,short,int,float,long,double)、对象引用(reference类型)、returnAddress类型(指向一条字节码指令的地址) Jvm栈有两种异常情况：StackOverflowError：线程请求的栈深度大于虚拟机允许的深度OutOfMemoryError：虚拟机栈可以动态扩展，当扩展时无法申请到足够内存抛出 2.2.3 本地方法栈 (线程私有) 与虚拟机栈作用非常相似，不过执行的是本地方法，语言、数据结构都没强制规定，为虚拟机使用到的Native方法服务。也会抛出StackOverflowError和OutOfMemoryError 2.2.4 Java堆 (线程共有) 在虚拟机启动时创建，是Java虚拟机管理的最大一块内存，也是垃圾收集器管理的主要区域(所以很多时候也称作GC堆)。此内存区域唯一目的就是：存放对象的实例。 从内存回收角度，Java堆可以细分为：新生代和老年代，再细点就是 Eden空间、Form Survivor空间、To Survivor空间从内存分配角度，线程共享的Java堆可以划分出： 多个线程私有的分配缓冲区(TLAB，Thread Local Allocation Buffer) 不论怎么划分，都与存放内容无关，存放的都是对象实例，划分都为了更好的回收内存或更快地分配内存。 —未完待续","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"http://yoursite.com/tags/《深入理解Java虚拟机》/"}]},{"title":"JVM常用参数种类","date":"2017-03-02T05:22:09.000Z","path":"2017/03/02/JVM常用参数种类/","text":"一、配置堆区(-Xms、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn)①-Xms：表示Java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。 ②-Xmx：表示Java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的1/4大小。但是开发时，通常会将-Xms与-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配隔离计算堆区大小而浪费资源。一般对堆区的内存分配只需配置上述两个参数(-Xms,-Xmx)即可，但如果想细化，可配置以下三个参数(-XX:newSize、-XX:MaxnewSize、-Xmn) 对堆区进一步细分。 1)-XX:newSize：新生代内存的大小，应小于-Xms的值2)-XX:MaxnewSize：由字面意思可知，新生代可被分配的最大内存，应小于-Xmx的值3)-Xmn：对上面两个参数同时配置，即 -Xmn = -XX:newSize = -XX:MaxnewSize 在JDK1.4以后才可用-Xmn这个很厉害的参数 二、配置非堆区①-XX:PermSize：表示非堆区初始内存分配大小.(Permanent Size)持久化内存 ②-XX:MaxPermSize：表示非堆区分配的最大内存上限 注意！在配置之前要慎重考虑该非堆区内存大小，因为此处是不会被Java垃圾回收机制进行处理同时，最大堆内存+最大非堆内存 &lt; 操作系统可用内存 eg示例: 1VM参数：-verbose : gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX : SurvivorRatio = 8 表示为：Java堆大小为20M，不可扩展，10M给新生代，10M给老年代，新生代中Eden区： Survivor区 = 8：1新生代可用总空间为: Eden区 + 1个Survivor区 即 10M * 9/10 = 9M","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"正则表达式小结 ","date":"2017-03-01T15:04:47.000Z","path":"2017/03/01/正则表达式小结/","text":"一、创建方式js中，创建正则表达式的两种方式： 121.通过构造函数定义var 变量名= new RegExp(/表达式/); 122.通过直接量定义var 变量名= /表达式/; 二、五大内置对象1.预定义类① .除了换行和回车符(\\r\\n)其他的都可以 12console.log(/./.test(\"\\n\\r\"));//false console.log(/./.test(\"sa35490df574!@@$\"));//true ②\\d数字才能匹配 12console.log(/\\d/.test(\"132465465\"));//trueconsole.log(/\\d/.test(\"abs\"));//false ③\\D非数字才能匹配 12console.log(/\\D/.test(\"132465465\"));//false console.log(/\\D/.test(\"abs\"));//true ④\\s空格才能匹配 12console.log(/\\s/.test(\" \"));//true console.log(/\\s/.test(\"sad\"));//false ⑤\\S非空格才能匹配 12console.log(/\\S/.test(\" \"));//falseconsole.log(/\\S/.test(\"sad\"));//true ⑥\\w对单词的匹配12\\w：单词才能匹配，匹配字母或数字或下划线 [a-zA-Z_0-9] 单词字符\\W：非单词才能匹配[^a-zA-Z_0-9] 非单词字符 ⑦\\d代表单词的开头和结尾 1/\\dstudy\\d/ 2.简单类 12345678①/string/.test(\"string\") //中间是任意字符串，只要完整包含他即可(有他就行，完整的他)console.log(/git520/.test(\"gi\"));//fasleconsole.log(/git520/.test(\"asdgit520#$\"));//trueconsole.log(/git520/.test(\"052tig\"));//false 反向不行②/[string]/.test(\"string\") //[]整体对应一个字符，如[abc]，只要有[string]内的任意一个字符，都可以 console.log(/[520git]/.test(\"ilove\"));//true 3.负向类 123456 //[^string] 对括号内的字符取反，不够和正好返回false，多了和没有返回true(eg:[^abc]中，只有test a,ab,abc都返回false,其他的都是true)console.log(/[^abc]/.test(\"a\"));//falseconsole.log(/[^abc]/.test(\"ab\"));//falseconsole.log(/[^abc]/.test(\"abc\"));//falseconsole.log(/[^abc]/.test(\"abs\"));//true//就是/[^abc]/.test() 只要test 的是a,ab,abc就错,其他的都对 4.范围类 123456//只要存在字符在这个范围内的都行console.log(/[a-c]/.test(\"b\"));//trueconsole.log(/[a-c]/.test(\"ss\"));//falseconsole.log(/[a-c]/.test(\"sasd\"));//true 5.组合类 123456789//组合起来，存在这个范围内的字符都可以,一个[]就代表一个字符console.log(/[a-c1-3]/.test(2));//trueconsole.log(/[a-c1-3]/.test(\"a\"));//trueconsole.log(/[a-c1-3]/.test(\"abs23fz\"));//trueconsole.log(/[a-c1-3]/.test(\"z5\"));//true 三、正则边界 1.正则边界 12345//1.以^开始，以$结尾，代表精确匹配//注：^只有在[]里表示取反。在//表示正则的开头console.log(/^rick$/.test(\"rick\"));//trueconsole.log(/^rick$/.test(\"rickl\"));//fasleconsole.log(/^rick$/.test(\"ric\"));//false 四、量词 1.量词 ❤（多个字母，重复最后一个）❤ 12345678910111213141516171819202122232425// * 贪婪 大于等于0// + 懒惰 大于等于1// ? 占有 要么0要么1console.log(/^a*$/.test(\"\"));//true 0次可以console.log(/^a*$/.test(\"a\"));//trueconsole.log(/^a*$/.test(\"aaaa\"));//trueconsole.log(/^a*$/.test(\"aaab\"));//false 因为^$控制了边界内只能有大于等于0个aconsole.log(/^a*$/.test(\"b\"));//false b更错了console.log(/^zxcv*$/.test(\"zxcvv\"));//true 多个字母，重复最后一个console.log(/^zxcv*$/.test(\"zxc\"));//true 大于等于0，0个也可以console.log(/^zxcv*$/.test(\"zxzv\"));//false 边界定义了，边界内必须要完全匹配 // &#123;&#125;重复多少次的意思，&#123;n&#125; n次 &#123;n,&#125; n次即以上 &#123;n,m&#125; n&lt;=x&lt;=m// * &#123;0,&#125;// + &#123;1.&#125;// ? &#123;0.1&#125;// x|y x或者y //()括号：提高权限，优先计算 | :前后只要有一个符合即可console.log(/(abc)|(xyz)/.test(\"abcq\"));//trueconsole.log(/(abc)|(xyz)/.test(\"sxyz\"));//trueconsole.log(/(abc)|(xyz)/.test(\"abxy\"));//false 都没有完整符合abc或xyz中的一个console.log(/(abc)|(xyz)/.test(\"ab\"));//false 同上 五、练习 1.练习 12//eg: 0562-2812914 (0开头，4位)-(2开头，7位) var RegExp = /^0\\d&#123;3&#125;-2\\d&#123;6&#125;$/; —未完待续","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"springmvc使用hibernate-validator校验框架实现后端校验","date":"2017-02-28T05:20:18.000Z","path":"2017/02/28/springmvc使用hibernate-validator校验框架实现后端校验/","text":"一 springmvc校验springmvc使用JSR-303校验规范，JSR-303是javaEE6的规范。 springmvc具体使用hibernate-validator校验框架（和hibernate的ORM没有关系），hibernate-validator基于javabean的属性校验。 二 实现步骤① 添加jar包支持 本例使用hibernate-validator 4.3.0.Final版本 maven的pom文件引入以下内容即可 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;4.3.0.Final&lt;/version&gt;&lt;/dependency&gt; jboss-logging和validation-api为其依赖。 ② 在springmvc的处理器适配器中配置validator：1&lt;mvc:annotation-driven validator=\"validator\"/&gt; 定义validator的bean 1234567891011121314151617181920&lt;!-- 定义校验器 --&gt; &lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;!-- 校验器 --&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" /&gt; &lt;!-- 指定校验使用的资源文件，如果不指定则默认使用classpath下的ValidationMessages.properties--&gt; &lt;property name=\"validationMessageSource\" ref=\"messageSource\" /&gt; &lt;/bean&gt; &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomerValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=\"fileEncodings\" value=\"utf-8\"/&gt; &lt;!-- 对资源文件内容缓存时间，秒 --&gt; &lt;property name=\"cacheSeconds\" value=\"120\"/&gt; &lt;/bean&gt; ③ 在需要校验的javaben实体类中添加相关校验注解，此处以Items这个po类为例 123456789public class Items &#123; @Size(min=1,max=30,message=\"&#123;item.name.length&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) @NotNull(message=\"&#123;item.name.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private String name; private String pic; @NotNull(message=\"&#123;item.createdate.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private Date createtime; 相关的校验规则由注解名称即可理解，这里解释下注解内的属性含义。message为出现错误时的提示信息，groups为将我们的校验器分组，因为po类是共用的，可能同一个字段在不同的场景下有不同的校验需求，所以将其分组，在controller中进行校验时，可指定分组，来进行校验。分组groups中的XXX.class为定义的一个“空的interface”，没有含义，仅仅只是为了分组。 在po类中利用注解进行校验分类和定义后，可以在后台进行校验，一般选择在service层，因为判断数据合法性属于业务需求，可是在有些情况下，对于用户的体验性来说，如果在controller就进行数据合法性校验，如果不合法可以直接返回，不调用service，响应稍微快些，用户体验好。所以此例中在controller层进行校验。 ④ 在后台通过注解校验 12345678910111213141516// 修改商品提交 @RequestMapping(\"/saveItems\") public String saveItems(Model model, Integer id, @Validated(value = &#123; ItemsValidationForEdit.class&#125;) Items item, BindingResult bindingResult) throws Exception &#123; if (bindingResult.hasErrors()) &#123; List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); model.addAttribute(\"allErrors\", allErrors); return \"editItem\"; &#125; // 更新 itemsService.updateItems(id, item); // 返回成功页面 // 重定向到商品查询 return \"forward:queryItems.action\"; &#125; controller方法参数中的@Validated(value = { ItemsValidationForEdit.class}) Items item, BindingResult bindingResult） 含义为： 对Items这个形参进行校验，选择他其中定义的ItemsValidationForEdit这个分组的校验规则。 注意：如果你需要进行校验，在方法参数中，需要在校验对象的前后加上@Validated和BindingResult bindingResult，他们是成对出现的。 顺便贴下hibernate-validator的校验注解 123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"SpringMVC中post、get乱码解决","date":"2017-02-28T05:14:14.000Z","path":"2017/02/28/SpringMVC中post、get乱码解决/","text":"一 乱码原因由于中间件为Tomcat，用户请求和返回的响应都需要经过tomcat，tomcat默认编码为ISO-8859-1和我们程序的编码(一般为UTF-8)不同，导致post、get请求乱码。 二 解决方案 Post乱码解决方案：在web.xml中添加编码过滤器来解决，可以自己编写过滤器，最常用的方法是使用spring提供的编码过滤器：在Web.xml中增加如下配置（要注意的是它的位置一定要是第一个执行的过滤器） 12345678910111213&lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 该过滤器要做的其实就是强制为所有请求和响应设置编码格式：request.setCharacterEncoding(“utf-8”);response.setCharacterEncoding(“utf-8”); GET乱码解决方案 针对Get方式的乱码问题，由于参数是通过URL传递的，所以上面通过request设置的编码格式是不起作用的12345678910方法①修改tomcat目录 的conf/server.xml文件，添加URIEncoding=\"utf-8\"&lt;Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;只需增加 URIEncoding=\"UTF-8\" 这一句，然后重启tomcat即可。方法②对参数进行重新编码：String userName = new String(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\")ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 通过以上对POST和GET的处理，妈妈再也不用担心我们遇到乱码了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"以mybatis为例浅聊SQL注入","date":"2017-02-28T05:03:08.000Z","path":"2017/02/28/以mybatis为例浅聊SQL注入/","text":"以用户登录为例，传统代码为一个form表单，输入username和password去数据库发送sql检索，用的是字符串拼接${}。 select * from t_user where password = '${password}'and username = '${username}' 如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 此时无论用户名为zhangsan的该用户密码为何值，均能查询出一条记录。 而用了预编译的#{}占位符后代码为 select * from t_user where password = #{password} and username = #{username} 即mybatis发送给数据库的sql为 select * from t_user where password = ? and username = ? 在数据库端便会对该sql进行编译，如果下次有该查询时，mabatis会发送 select * from t_user where password = #{password} and username = #{username} 作为“KEY”，页面传入的参数作为“VALUE”去数据库查询，预编译的方式使得发送至数据库的值为sql “KEY” 和 参数 “VALUE”，数据库根据KEY找到编译好的sql，将参数注入进行查询如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 看到这也许会有疑问，这和传统的字符串拼接，得到的sql还是一样的啊？其实并不是，sql只是数据库端给我们看的一段字符串，真正的查询方式，传统字符串拼接查询，传入数据库的是一个参数，为在程序端拼接好的sql，直接去数据库执行。而预编译方式，传入数据库的是两个参数，一个是 select * from t_user where password = ? and username = ? 语句，一个是值。如果数据库里没该条SQL就会编译好缓存，如果缓存有的话，直接类似“函数接收参数”的方式去执行sql，那么，数据库里是不会有任何一条记录的密码为1111’ or ‘1 = 1，就不会返回记录。从某种意义上来说防止了SQL注入。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"MySQL和Oracle分页的区别","date":"2017-02-28T05:01:20.000Z","path":"2017/02/28/MySQL和Oracle分页的区别/","text":"MySQL和Oracle分页的区别 MySQL 分页 (利用LIMIT关键字） 计算参数为 开始序号(startNum)，要查的总条数 (totalNum) Oracle 分页 (利用自带的rownum) 计算参数为 开始序号(startNum) ， 结束序号 (endNum) Oracle分页利用其自带的rownum，但是rownum在表中不能使用&gt;号(比如select rownum,e.* from emp where rownum &gt; n,n为除了0以外的任何值,查出的都是空)，但是可以使用&lt;,为了避免，所以采用子查询将其rownum转换为子查询表中的一列数据列,而不是数据表自带的rownum属性使其可以使用 这种方式的好处在于，除了中间的业务查询，其余的都是固定的模版，我们只需要关心中间的业务查询即可。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"OCUpload、pinyin4j、poi简单入门","date":"2017-02-28T04:50:16.000Z","path":"2017/02/28/OCUpload、pinyin4j、poi简单入门/","text":"通过几个小demo完成以上三项的简单入门，通过此篇博客，您可以对它们有初步的认识，编写日常简单的应用。具体深入可以查询相关api。 OCUpload OCUpload为JQuery的插件(One Click Upload)，意思为一键上传，封装了对于文件上传的一些方法，只需几行代码，文件上传优雅而简洁。 对于传统的文件上传，只是通过input标签，通过设置enctype为multipart/form-data，选中文件后还需点击按钮，提交表单，才能在后台进行相关字段解析，通过流来进行文件上传，上传成功后，页面多半要刷新，无法给用户良好的体验。 OCUpload实现了页面“不刷新”，选择文件后直接上传，不需要选中文件后再点击按钮上传表单。简单实现为： 在页面的head里引入JQuery的类库，由于这里使用了easyUI使按钮和提示相对美观些，所以也导入了easyUI的核心类库，当然别忘了导入我们的OCUpload的库，本篇博客使用的版本为jquery.ocupload-1.1.2.js.首先在body中使用一个元素来“占位子”，任何标签元素都可以，不过上传文件一般点击按钮，所以我们使用easyUI的linkbutton，给按钮设置id为import.123&lt;body&gt; &lt;a id=\"import\" class=\"easyui-linkbutton\" data-options=\"iconCls:'icon-redo'\"&gt;上传文档&lt;/a&gt;&lt;/body&gt; 在head中给id为import的按钮添加upload事件，这是OCUpload的上传方法，参数为json对象，由于是简单入门，在这里即使用三个主要的属性：action(处理上传文件的后台action路径)，name(给文件设置name，便于后台通过name获取)，onComplete(参数为function，执行上传完毕的回调函数)。12345678910111213141516&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#import\").upload(&#123; action:'$&#123;pageContext.request.contextPath&#125;/regionAction_importXls', name:'upload', onComplete: function (data, self, element) &#123; if(data=='1')&#123; $.messager.alert(\"提示信息\",\"数据导入成功!\",\"info\"); &#125;else&#123; $.messager.alert(\"提示信息\",\"数据导入失败!\",\"info\"); &#125; location.reload(); &#125; &#125;);&#125;);&lt;/script&gt; 到此便完成一键上传的前台代码，只需要后台对上传文件进行解析处理即可完成文件上传。 让我们来看看这些代码做了些什么。访问页面，打开F12调试。可以看到，OCUpload将我们的linkbutton底部添加了一个带有文件input的form和一个display:none 不可见的iframe。 选择文件后form中的input触发onChange事件，直接提交表单，实现了选择文件后直接上传 文件上传后，本来页面是要刷新的，但是OCUpload将target指向底部隐藏的iframe，使得隐藏的iframe刷新，从而达到我们的页面“不刷新”的效果 poixls文件解析 在后台使用poi对上传的xls文件进行解析，将文件中的一行(row)解析成javabean，通过hibernate存入数据库。 12345678910111213141516171819202122232425262728293031public class RegionAction extends BaseAction&lt;Region&gt; &#123; private File upload; public String importXls() throws FileNotFoundException, IOException &#123; HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(upload));//此为poi的核心对象，通过构造方法中的InputStream生成HSSWorkbook对象。 HSSFSheet sheetAt = workbook.getSheetAt(0);//这里得到第一张表格(sheet) List&lt;Region&gt; regions = new ArrayList&lt;Region&gt;(); for (Row row : sheetAt) &#123; //通过遍历sheetAt获取每一行(row),再通过每一行获取每一个值 String value1 = row.getCell(0).getStringCellValue();//id String value2 = row.getCell(1).getStringCellValue();//province String value3 = row.getCell(2).getStringCellValue();//city String value4 = row.getCell(3).getStringCellValue();//district String value5 = row.getCell(4).getStringCellValue();//postcode Region region = new Region(value1, value2, value3, value4, value5); region.setShortcode(StringUtils.join(PinYin4jUtils.getHeadByString(value2+value3), \"\"));//此处利用PinYin4jUtils将表格中的字段转成拼音封装到javabean，暂且不提 region.setCitycode(PinYin4jUtils.hanziToPinyin(value3)); regions.add(region); &#125; String flag = \"1\"; try&#123; regionService.saveBatch(regions);//批处理保存到数据库中，如果抛异常返回标志字符串回前台，做出相应友好提示 &#125;catch(Exception e)&#123; flag = \"0\"; &#125; ServletActionContext.getResponse().setContentType(\"text/html;charset=UTF-8\"); ServletActionContext.getResponse().getWriter().print(flag); return NONE;//上传文件，不需要配视图 &#125; ｝ 那么在poi中，sheet、row、cell分别是什么呢？ sheet: xls中的工作表 row: xls中的行 cell: xls中的每一个数据 xls文件生成 在后台查询出数据list，封装进HSSFWorkbook对象生成xls文件,提供一个输出流，告知浏览器文件名和文件类型，在前台提供按钮或链接，指向此action，实现xls文件导出。 12345678910111213141516171819202122232425262728293031public String exportXls() throws IOException&#123; List&lt;Subarea&gt; list = subareaService.findAll(); HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(\"分区数据\"); HSSFRow headRow = sheet.createRow(0);//标题行 headRow.createCell(0).setCellValue(\"分区编号\"); headRow.createCell(1).setCellValue(\"省\"); headRow.createCell(2).setCellValue(\"市\"); headRow.createCell(3).setCellValue(\"区\"); headRow.createCell(4).setCellValue(\"信息\"); headRow.createCell(5).setCellValue(\"城市编码\"); if(list!=null &amp;&amp; list.size()&gt;0)&#123; for (Subarea subarea : list) &#123; HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum()+ 1); dataRow.createCell(0).setCellValue(subarea.getId()); dataRow.createCell(1).setCellValue(subarea.getRegion().getProvince()); dataRow.createCell(2).setCellValue(subarea.getRegion().getCity()); dataRow.createCell(3).setCellValue(subarea.getRegion().getDistrict()); dataRow.createCell(4).setCellValue(subarea.getRegion().getInfo()); dataRow.createCell(5).setCellValue(subarea.getRegion().getCitycode()); &#125; &#125; String filename = URLEncoder.encode(\"分区数据.xls\", \"UTF-8\"); ServletActionContext.getResponse().setContentType(ServletActionContext.getServletContext().getMimeType(filename));//完成文件下载不要忘了\"一个流，两个头\" ServletActionContext.getResponse().setHeader(\"content-disposition\", \"attachment;filename=\"+filename);//完成文件下载不要忘了\"一个流，两个头\" ServletOutputStream out = ServletActionContext.getResponse().getOutputStream(); workbook.write(out);//通过HSSFWorkbook的write方法，关联一个输出流 return NONE; &#125; pinyin4j主要利用PinYin4jUtils的相关方法进行汉字转拼音。","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":" EasyUI的datagrid组件实现分页","date":"2017-02-28T04:40:30.000Z","path":"2017/02/28/EasyUI的datagrid组件实现分页/","text":"本篇博客用于EasyUI的datagrid组件实现分页展示，后台为Struts2+Spring+Hibernate，利用DetachedCriteria对象进行简单的分页查询。 要点： datagrid组件的参数和响应格式 DetachedCriteria对象的条件查询 首先利用EasyUI渲染出datagrid数据表格 先在body中声明一个table 123&lt;div&gt; &lt;table id=\"grid\"&gt;&lt;/table&gt;&lt;/div&gt; 再去head中通过JQuery代码将table渲染为datagrid对象 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; $(function()&#123; $('#grid').datagrid( &#123; border : false, rownumbers : true, pageList: [10,20,30],//选择一页显示多少数据 pagination : true,//在DataGrid控件底部显示分页工具栏。 columns :[ [ &#123; field : 'name',//简单的测试字段 title : '姓名', width : 120, align : 'center' &#125;, &#123; field : 'telephone', title : '手机号', width : 120, align : 'center' &#125; ] ], url :\"$&#123;pageContext.request.contextPath&#125;/staffAction_pageQuery\", //提交的url地址 idField : 'id' &#125;); &#125;);&lt;/script&gt; 此时你的页面应该是(因为没有在后台提供数据，所以现在页面为空表格) 接下来我们来看下这个datagrid组件发送了什么请求数据 打开浏览器的F12调试，我用的是火狐浏览器，不同的浏览器调试工具页面不同。找到网络栏，我们重新刷新下网页，可以看到 该条post请求是向后台获取数据 点开可以查看到他的请求参数为page、rows ###tips注意：在datagrid的请求参数中，page为当前页码，rows为所要展示的数据条数，而在datagrid的响应参数中，必须有total和rows，返回来的响应参数中，total为通过该条件查询到的总记录数，而这里的rows为所有的记录内容，为一个List集合。 有了请求参数，我们就可以去后台编写了。接下来为后台代码。 后台采用的是Struts2+Spring+Hibernate，我们利用struts2的驱动获取页面请求的page和rows参数。 在StaffAction中，我们提供了page、rows字段以及他们的get、set方法。为了方便起见，我们将分页有关的数据封装成一个名称为PageBean的Class对象。 PageBean StaffAction的pageQuery方法 StaffServiceImpl StaffDao 相关介绍在代码截图中有注释。最后，通过dao查询出来的数据，经过service传到action，在action中通过Jsonlib将数据转成json格式，返回前台。 接下来我们就可以在前台显示出数据库里的数据了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]}]