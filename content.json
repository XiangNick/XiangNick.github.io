[{"title":"JSNotes（三）JS的闭包","date":"2017-04-09T09:39:19.000Z","path":"2017/04/09/JSNotes（三）JS的闭包/","text":"闭包闭包的概念闭包从字面意思理解就是闭合, 包起来. 简单的来说闭包就是,一个具有封闭的对外不公开的, 包裹结构, 或空间.在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包. 闭包要解决什么问题？ 闭包内的数据不允许外界访问 要解决的问题就是间接访问该数据 函数就可以构成闭包, 要解决的问题就是访问到函数内部的数据 我们观察下面的函数foo，在foo内部有一个变量num，能否在函数外部访问到这个变量num呢？ 123456789101112function foo () &#123; var num = 123; return num;&#125;var res = foo();console.log( res ); // =&gt; 123 分析： 在上面的代码中，确实可以访问到num这个函数内部的变量。但是能不能多次访问呢？ 不能，因为每次访问都得重新调用一次foo函数，每次调用都会重新创建一个num = 123，然后返回。 解决思路函数内的数据不能直接在函数外被访问，是因为作用域的关系，上级作用域不能直接访问下级作用域中的数据。 但是如果反过来，下级作用域可以直接访问上级作用域中的数据。那么如果在函数foo内定义一个函数，那么在这个内部函数中是可以直接访问foo中的num的。 12345678910111213141516171819202122function foo() &#123; var num = Math.random(); function func() &#123; return num; &#125; return func;&#125;var f = foo();// f可以直接访问num，而且多次访问，访问的也是同一个，并不会返回新的numvar res1 = f();var res2 = f(); 如何获得超过一个数据函数的返回值只能有一个，那按照上面的方法，我们只能对函数内部的一个数据进行操作。怎么操作函数内的多个数据呢？ 可以使用对象，代码如下： 1234567891011121314151617181920212223242526function foo () &#123; var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return &#123; num1: function () &#123; return num1; &#125;, num2: function () &#123; return num2; &#125; &#125;&#125; 如何完成读取一个数据和修改这个数据前面讲的都是如何去获取函数内部的数据，接下来我们考虑如何修改函数内部的数据。 同样，也是使用内部的函数进行操作。 12345678910111213141516171819202122232425262728function foo() &#123; var num = Math.random(); //分别定义get和set函数，使用对象进行返回 return &#123; //get_num负责获取数据 get_num: function() &#123; return num; &#125;, //set_num负责设置数据 set_num: function(value) &#123; num = value; &#125; &#125;&#125; 我们还可以模仿JQ的方法思路，fun()是获取数据,fun(val)是修改数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function foo()&#123; var fname = \"nick\"; var fage = 23; return &#123; name:function(value)&#123; if(value === undefined)&#123; &#125;else&#123; fname = value; &#125; return fname; &#125;, age:function(value)&#123; if(value === undefined)&#123; &#125;else&#123; fage = value; &#125; return fage; &#125; &#125;; &#125; var obj = foo(); console.log(obj.name()); console.log(obj.age()); console.log(obj.age(24)); 总结闭包的作用：根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. Js中函数可以产生作用域，因此说函数可以构成闭包。 1.可以读取函数内部的变量 2.让这些变量的值始终保持在内存中。 好处：闭包更像是面向对象语言中的封装，函数内部的数据被封装起来私有化，外部无法直接修改，只能依靠我们提供的方法来修改和获取我们私有化的内部数据，Java中的get、set方法。同时，由于是我们提供方法给外部访问我们内部私有化的数据，所以： 1.在函数外部想要修改数据，只能通过函数内部的方法 2.我们可以在函数内部定义的这个方法里设置安全措施，校验之类的操作不合法可以throw异常 3.可以保证系统的安全性和稳定性 坏处:上面说到，闭包的作用之一还有一个将函数内部的私有变量始终保存在内存中，这既是好处(操作的一直是同一个数据)，也有坏处（由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除） 如何理解呢？ 下面摘自偶像阮一峰大神博客的一段内容： 123456789101112131415161718192021222324function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 阮大神在博客结尾留下了两个闭包的思考题： 题一： 1234567891011121314151617181920var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//The Window 题二： 12345678910111213141516171819202122var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//My Object ###解析： 对于题一： 12object.getNameFunc()() 也就是 12345678(function()&#123; return function()&#123; return this.name; &#125;)(); 是不是就是在全局调用这个函数,这是闭包没闭上 由于this是动态的，在调用语句的那一刻来获取上下文，这两题中就看在什么时候才能逐句解释运行到this关键字，来动态获取上下文。 在题一中，在最后调用时this才开始获取上下文，是window ，于是在全局找到了var name = “The Window”; 弹出The Window 对于题二： 由于用了var that = this;这时候，this就是开始获取上下文了！发现是在object内，所以this指向object并赋值给了that，所以这时候that就指向object了！自然弹出作用域里的My Object! 这是包上了，在外部来操作内部变量。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（二）JS的变量声明提升","date":"2017-04-09T09:38:22.000Z","path":"2017/04/09/JSNotes（二）JS的变量声明提升/","text":"JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。我们来看下面这个例子： 12345func();function func()&#123; alert(\"Funciton has been called\");&#125; 在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来Function has been called。 所以，可以得出结论，JavaScript并非仅在运行时简简单单的逐句解析执行！ JavaScript 预解析JavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块提前进行处理。 关键问题是怎么处理呢? 当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。 函数预解析1.普通函数形式12345func();function func()&#123; alert(\"Funciton has been called\");&#125; 由于JavaScript的预解析机制，上面的代码就等效于： 12345function func()&#123; alert(\"Funciton has been called\");&#125;func(); 2.函数表达式形式1234567func(); var func = function()&#123; console.log(1); &#125; 预解析后：123456789var func; func(); func = function()&#123; console.log(1); &#125; 总结：函数的预解析，普通的function func(){}函数会全体提升，而函数表达式var func = function(){}只会提升var func;声明，函数体不提升。看完函数声明的提升，再来看一个变量声明提升的例子： 123alert(a);var a = 1; 由于JavaScript的预解析机制，上面这段代码，alert出来的值是undefined，如果没有预解析，代码应该会直接报错a is not defined，而不是输出值。 Wait a minute, 不是说要提前的吗？那不是应该alert出来1，为什么是undefined? 那么在这里有必要说一下声明、定义、初始化的区别。其实这几个概念是C系语言的人应该都比较了解的。 行为 说明 声明 告诉编译器/解析器有这个变量存在,这个行为是不分配内存空间的,在JavaScript中，声明一个变量的操作为：var a; 定义 为变量分配内存空间，在C语言中，一般声明就包含了定义，比如：int a;,但是在JavaScript中，var a;这种形式就只是声明了。 初始化 在定义变量之后，系统为变量分配的空间内存储的值是不确定的，所以需要对这个空间进行初始化，以确保程序的安全性和确定性 赋值 赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作（修改存储空间内的数据) 所以我们说的提升，是声明的提升。 那么再回过头看，上面的代码就等效于： 12345var a; //这里是声明alert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefineda = 1; 复杂点的情况分析通过上一小节的内容，我们对变量、函数声明提升已经有了一个最基本的理解。那么接下来，我们就来分析一些略复杂的情况。 函数同名观察下面这段代码: 1234567891011func1();function func1()&#123; console.log('This is func1');&#125;func1();function func1()&#123; console.log('This is last func1');&#125; 输出结果为： 123This is last func1This is last func1 原因分析：由于预解析机制，func1的声明会被提升，提升之后的代码为： 1234567891011function func1()&#123; console.log('This is func1');&#125;function func1()&#123; console.log('This is last func1');&#125;func1();func1(); 同名的函数，后面的会覆盖前面的，所以两次输出结果都是This is last func1。 变量和函数同名12345alert(foo);function foo()&#123;&#125;var foo = 2; 当出现变量声明和函数同名的时候，其实变量声明和函数都会提升，但是函数提升的更高，在变量声明的上方，所以上面的代码的输出结果为 1function foo()&#123;&#125;//这是一段字符串,因为是alert里的 我们还是来吧预解析之后的代码展现出来: 1234567function foo()&#123;&#125;;var foo;//没什么影响,可以忽略这句alert(foo);foo = 2; 再来看一种 1234567var num = 1;function num () &#123; alert( num );&#125;num(); 代码执行结果为： 1Uncaught TypeError: num is not a function 直接上预解析后的代码： 1234567function num()&#123; alert(num);&#125;var num; //没什么影响,可以忽略这句num = 1; //把num的地址由函数体改为1了num(); //Uncaught TypeError: num is not a function 总结：123456//a)console.log(num);//function num()&#123;&#125; var num = 123; function num()&#123;&#125;; 和1234//b) var num = 123; function num()&#123;&#125;;console.log(num);//123 为啥会有这样的区别？ 预解析后的代码: 12345//a)function num()&#123;&#125;;var num;//没什么影响,可以忽略这句console.log(num);//function num()&#123;&#125;num = 123; 和12345678//b)function num()&#123;&#125;;var num;//没什么影响,可以忽略这句num = 123;console.log(num);//123 看出来了吗？ ❤当函数和变量同名时，其实函数和变量声明都会提升，但是函数比变量声明提升的还要多，在该作用域顶部。123456 var num = 123; function num()&#123;&#125;;console.log(num);//123 预解析后就是1234567 function num()&#123;&#125;; var num;//没什么影响,可以忽略这句num = 123;console.log(num);//123 a)与b)的区别就是一开始cosole.log(num);的顺序不同导致第二个num = 123在console.log(num);之前。num = 123这句话就是把上面的num函数的地址引用指向了123导致结果与a)不同的 预解析是分作用域的声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。 123456function showMsg()&#123; var msg = 'This is message';&#125;alert(msg); // msg未定义 还是直接把预解析之后的代码写出来： 1234567function showMsg()&#123; var msg; msg = 'This is message';&#125;alert(msg); // msg未定义 预解析是分段的分段，其实就分script标签的 123456789101112131415161718192021&lt;script&gt;func(); // 输出 AA2;function func()&#123; console.log('AA1');&#125;function func()&#123; console.log('AA2');&#125;&lt;/script&gt;&lt;script&gt;function func()&#123; console.log('AA3');&#125;&lt;/script&gt; 在上面代码中，第一个script标签中的两个func进行了提升，第二个func覆盖了第一个func，但是第二个script标签中的func并没有覆盖上面的第二个func。所以说预解析是分段的。 tip:但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。 函数表达式并不会被提升12345func();var func = function()&#123; alert(\"我被提升了\");&#125;; 这里会直接报错，func is not a function，原因就是函数表达式，并不会被提升。只是简单地当做变量声明进行了处理，如下： 1234567var func;func();func = function()&#123; alert(\"我被提升了\");&#125; 条件式函数声明123456789console.log(typeof func);if(true)&#123; function()&#123; return 1; &#125;&#125;console.log(typeof func); 上面这段代码，就是所谓的条件式函数声明，这段代码在Gecko引擎中打印&quot;undefined&quot;、&quot;function&quot;；而在其他浏览器中则打印&quot;function&quot;、&quot;function&quot;。 原因在于Gecko加入了ECMAScript以外的一个feature：条件式函数声明。 Conditionally created functions Functions can be conditionally declared, that is, a function declaration can be nested within an if statement. &gt; Note: Although this kind of function looks like a function declaration, it is actually an expression (or statement), since it is nested within another statement. See differences between function declarations and function expressions. Note中的文字说明，条件式函数声明的处理和函数表达式的处理方式一样，所以条件式函数声明没有声明提升的特性。 最重要的小练习来了！ 例一1234567891011function foo() &#123; var num = 123; console.log(num); //? &#125; foo(); console.log(num); //? 预解析(声明提升)后的代码 123456789101112131415//预解析function foo() &#123;var num;num = 123;console.log(num); //?123&#125;foo();console.log(num); //?报错，num is not defined Tips: ① is not defined 没有定义 是报错 ② undefined 定义了没有赋值 –打印undefined 例二12345678910111213var scope = \"global\"; foo(); function foo() &#123; console.log(scope); //？undefined var scope = \"local\"; console.log(scope); //？ local &#125; 预解析(声明提升)后的代码12345678910111213141516171819//预解析var scope;function foo()&#123;var scope;console.log(scope); //？undefinedscope = \"local\";console.log(scope); //？ local&#125;scope = \"global\";foo(); 例三1234567891011121314151617181920212223function f1()&#123;var a;if(\"a\" in window)&#123;var a = 10;&#125;alert(a); // ?&#125;f1();if(!\"a\" in window)&#123;var a = 10;&#125;alert(a); // ? 预解析(声明提升)后的代码123456789101112131415161718192021222324252627//预解析function f1()&#123;var a;if(\"a\" in window)&#123;a = 10;&#125;alert(a); //10&#125;f1();var a;if(!\"a\" in window)&#123;a = 10;&#125;alert(a); // ? undefined Tips:in 关键字1.用法一 遍历对象 for(var key in 对象名){} 2.用法二 判断属性(数值就是索引值)是否存在对象中,返回boolean if( a in obj){…} 3.用法三 判断数组是否存在某个键 注意!关键字判断数组的时候是判断索引是否存在,而不是值 if(1 in arr){..} 是判断arr数组有没有1索引，感觉挺鸡肋是吧？那么怎么判断数组中是否有指定值呢？ 如何判断数组中是否存在指定的值 arr.indexOf 找到返回指定元素的索引值, 没有找到返回-1 例四123456789101112131415var foo = 1;function bar() &#123;if(!foo) &#123;var foo = 10;&#125;alert(foo); //??10&#125;bar(); 预解析(声明提升)后的代码 123456789101112131415161718192021//预解析var foo;function bar()&#123;var foo;if(!foo) &#123; foo = 10;&#125;alert(foo); //??10&#125;foo = 1;bar(); Tips:foo是undefined，undefined和null作为boolean判断都为false，null参与数值运算是0，undefined参与数值运算是NaN例五 （大题）123456789101112131415161718192021222324252627282930 function Foo() &#123;getName = function()&#123; alert(1); &#125;;return this;&#125;Foo.getName = function() &#123; alert(2); &#125;; //AFoo.prototype.getName = function()&#123; alert(3); &#125;; //Bvar getName = function() &#123; alert(4); &#125;; //Cfunction getName()&#123; alert(5); &#125; //DFoo.getName(); // ?getName(); // ?Foo().getName(); // ?getName(); // ? new Foo.getName(); // ?new Foo().getName(); // ?new new Foo().getName(); // ? 预解析(声明提升)后的代码 123456789101112131415161718192021222324252627282930313233343536//预解析之后 function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this; &#125; var getName; function getName()&#123; alert(5); &#125; //D Foo.getName = function() &#123; alert(2); &#125;; //A Foo.prototype.getName = function()&#123; alert(3); &#125;; //B getName = function() &#123; alert(4); &#125;; //C Foo.getName(); // ? getName(); // ? Foo().getName(); // ? getName(); // ? 4 // new Foo.getName(); // ? new Foo().getName(); // ? new new Foo().getName(); // ? 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1) Foo.getName(); // ? 由于B句是给Foo构造函数添加静态方法 因为已经添加过了，所以此处可以直接调用Foo的静态方法 结果：alert(2) // 2) getName(); // ? 这里去全局找getName()方法，但是看到D和C句都是全局的getName方法，由于C句经过预解析后在下方，所以层叠掉了预解析后的上方的④句，所以调用的是C句这个全局getName方法 结果：alert(4) // 3) Foo().getName(); // ? 这里是调用Foo()方法[注意：Foo()既可以当作构造函数，也可以直接调用执行] 调用Foo()方法的过程中，第一行getName = function()&#123; alert(1); &#125;;，先在Foo()函数创造的作用域内寻找getName，发现没有，就去全局找，找到了C句，所以将其修改为function()&#123; alert(1); &#125;;，所以记住，此时全局的C句的getName方法改为alert(1)了，然后第二行return this;因为是普通的全局调用函数，所以this指向window，即window.getName(); 也就是在全局调用getName方法，此时的全局的C句getName方法已经被修改为alert(1)了，而且预解析后，C句把D句层叠了，所以此处为调用修改后的C句 结果：alert(1) // 4) getName(); // ? 这里就是全局调用getName方法,C句把D句层叠了，而且C句也被修改成alert(1)了 结果: alert(1) // 5) new Foo.getName(); // ? 这里的new Foo.getName()，是先执行后面的Foo.getName()，再执行new,由第一题可知，之前A句就给Foo构造函数添加了静态方法getName,所以可以直接执行Foo构造函数的静态getName方法,为alert(2),由于alert语句执行结束返回值为undefined,new undefined没效果，就不管了 结果：alert(2) // 6) (new Foo).getName(); 这题和上一题不同的是给new Foo加了括号，优先执行。 注意：如果构造函数没有参数的话，可以不写()来new实例对象，所以这个等效于(new Foo()).getName(); function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this; &#125; 这是Foo()构造函数，他内部并没有属性和方法[this.xxx = xxx,this.xxx = function()&#123;xxx&#125;才叫他的成员属性/方法，能给实例对象的] 所以new Foo()出来的实例对象没有成员属性/方法,只有一个__proto__ 既然内部没有，就去原型里找，由B句可知，给Foo的原型绑定了一个getName方法，所以可以通过new Foo()出来的实例仅有的__proto__来调用他原型的getName方法 结果：alert(3) // new Foo().getName(); // ? 同上 结果：alert(3) // new new Foo().getName(); // ? 先new Foo()，再调用getName()，同第6)题，实例对象没，就去原型找，然后执行完毕alert(3)后返回undefined，new undefined 没意义。 结果: alert(3)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（一）JS的作用域","date":"2017-04-09T09:36:29.000Z","path":"2017/04/09/JSNotes（一）JS的作用域/","text":"作用域 作用：起作用 域：范围 变量起作用的范围就是变量的作用域 1.块级作用域 JavaScript中没有块级作用域 如果有块级作用域下面的代码的显示结果为 undefined undefined 1234567for(var i=0; i&lt;10;i++)&#123; var num = i;&#125;console.log(i);console.log(num); 但是Js没有块级作用域，所以结果为:10 9 2.词法作用域什么是词法作用域？ 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域. 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 例子1：123456789101112var a = 123; function f1()&#123; console.log(a); &#125; function f2()&#123; var a = 456; f1(); &#125; f2(); //123 词法作用域就是在代码写好的那一刻，变量的作用域就确定了。所以调用f2(),f2内部再调用f1时，f1()打印的a就是f1()函数写好时确定的a，也就是全局的var a=123 例子2：12345if ( false ) &#123; var num = 123;&#125;console.log( num ); // undefiend 这里的if(){}块不具备作用域，所以num声明可以提升出来为：123456789var num;if ( false ) &#123; num = 123;&#125;console.log( num ); // undefiend 例子3：1234567891011121314var num = 123;function foo() &#123; var num = 456; function func() &#123; console.log( num ); &#125; func();&#125;foo(); 3.函数级作用域在JavaScript中唯一能产生作用域的东西是 函数！ 也就是在function(){}内才能有他的作用域，访问权限，o(︶︿︶)o 唉~ 这点要牢记，JavaScript中只有函数和全局作用域！除去默认的全局作用域，也就只有函数能产生作用域了！！ 12345678var a = 1;function test()&#123; var b = 10;&#125; 这里就有着函数的作用域，导致变量提升只能在作用域内，为123456var a;a = 1;function test()&#123; var b; b = 10;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"AtomicInteger：支持原子性操作，基于CAS实现了乐观锁","date":"2017-03-29T09:28:42.000Z","path":"2017/03/29/AtomicInteger：支持原子性操作，基于CAS实现了乐观锁/","text":"AtomicInteger,一个提供原子操作的Integer的类。在java.util.concurrent.atomic包中。 一、使用场景在多线程环境中，AtomicInteger的使用场景就是提供一些原子性的数值改变，不会出现多个线程下的数据不一致问题。例如：仓库总量的增减，ID的顺序获取等。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。对于并发情况下，我们加锁的方式通常有两种：悲观锁和乐观锁。 二、悲观锁和乐观锁 悲观锁 在并发情况下，它假设最坏的情况，在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。这种方式将需要事务管理的代码块一律加上同步synchronized，这种独占锁会将其他线程挂起阻塞住，直到该事务结束后才将资源放出。线程的挂起和恢复过程，开销是很大的，当线程被挂起等待时，无法做任何事，而notify()或notifyAll()重新唤醒后又将开始新的资源争用，如果某个线程”人品很差”，一直被阻塞，争用不到资源，事务的执行会等待很久，效率很低。 在计算机组成原理这本书中提到，cpu是时分复用的，cpu的时间片，分配给不同的thread、process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。 小栗子：线程的挂起和恢复执行过程中存在着很大的开销。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。 乐观锁：每次不加锁，假设没有冲突而去完成操作。他的思路是：每次不加锁，认为大家都很自觉，不会发生数据冲突，万一发生冲突就自我重试，重新再去获取新值再来一遍，不影响其他线程，直到成功为止，就不像悲观锁那么自私霸道。对于数据库的增删改查，只有在最后提交的时候才会去检查，通常我们采用一个版本号version字段来检查该线程此时获取的数据是否被修改了，“是否还是往日的她”。每次comit时会检查该线程持有的版本号是否和实际版本号一致，如果不一致说明该数据已经被修改了，此时提交是不安全的，无法保证数据一致性，对于这种冲突，发生就无限循环重试，重新获取新的值和版本号，再在cpu争用中等到调度自己时再去尝试比对提交，直到成功为止。在上面的例子中，某个线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。三、什么是CASCAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 JDK1.5中引入了底层的支持，在int、long和对象的引用等类型上都公开了CAS的操作，并且JVM把它们编译为底层硬件提供的最有效的方法，在运行CAS的平台上，运行时把它们编译为相应的机器指令。在java.util.concurrent.atomic包下面的所有的原子变量类型中，比如AtomicInteger，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作。 四、 AtomicInteger实现CASAtomicInteger 是一个支持原子操作的 Integer 类，就是保证对AtomicInteger类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。 通过两个简单的例子来看一下 AtomicInteger 的优势在哪:普通线程同步: 1234567891011class Test2 &#123; private volatile int count = 0; public synchronized void increment() &#123; count++; //若要线程安全执行执行count++，需要加锁 &#125; public int getCount() &#123; return count; &#125;&#125; 使用AtomicInteger: 1234567891011class Test2 &#123; private AtomicInteger count = new AtomicInteger(); public void increment() &#123; count.incrementAndGet(); &#125; //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。 public int getCount() &#123; return count.get(); &#125;&#125; 从上面的例子中我们可以看出：使用AtomicInteger是非常的安全的.而且因为AtomicInteger由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。 五、 AtomicInteger源码查看接下来通过源码来看AtomicInteger具体是如何由硬件来实现原子操作的。 AtomicInteger继承了Number类并且实现了Serializable接口，支持序列化 1public class AtomicInteger extends Number implements java.io.Serializable &#123;...&#125; 构造函数 1234567891011121314 private volatile int value;/** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */ public AtomicInteger() &#123;&#125; 可以看出，AtomicInteger提供了空构造函数和赋值构造，对与空构造函数(AtomicInteger count = new AtomicInteger();)，其默认值为0。而赋值构造，其value值是被volatile修饰的int值 volatile 变量可以被看作是一种 “程度较轻的 synchronized” 锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。① 互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。② 可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。 Volatile变量具有 synchronized 的可见性特性，但是不具备原子特性。也就是说线程能够自动发现 volatile 变量的最新值。 下面是他的一些方法12345678910111213141516171819//获取当前的值public final int get();//取当前的值，并设置新的值 public final int getAndSet(int newValue);//获取当前的值，并自增 public final int getAndIncrement();//获取当前的值，并自减public final int getAndDecrement();//获取当前的值，并加上预期的值public final int getAndAdd(int delta); 同理，还有一些与之相反的incrementAndGet、decrementAndGet、addAndGet等，从名称可知， 分别是自增后返回新值，自减后返回新值，加上预期值后返回新值。他们的实现大致一样，只是返回值前者为return current;而后者为return next; 来看看incrementAndGet() 方法，下面是具体的代码。 12345678910111213/** * Atomically increments by one the current value. * * @return the updated value */ public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; 通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面，compareAndSet()方法的代码如下： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; 我们继续跟踪到compareAndSet()方法调用的compareAndSwapInt()方法，他是一个native方法。 1publicfinal native boolean compareAndSwapInt(Object var1, long var2, int var4, intvar5); compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet所做的为调用 sun.misc.Unsafe的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。 类似的，还有decrementAndGet()方法。它和incrementAndGet()的区别是将 value 减 1，赋值给next 变量。","tags":[{"name":"高并发与多线程","slug":"高并发与多线程","permalink":"http://yoursite.com/tags/高并发与多线程/"}]},{"title":"JQuery插件总结","date":"2017-03-19T14:46:23.000Z","path":"2017/03/19/JQuery插件总结/","text":"一、Jquery Full Page 全屏滚动","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"CSS3入坑记（二）","date":"2017-03-14T05:38:34.000Z","path":"2017/03/14/CSS3入坑记（二）/","text":"一、边框 边框圆角 border-radiusa)border-top-left-radius：水平半径 垂直半径b)border-radius：顺时针四个方向的切圆水平半径/顺时针四个方向的切圆垂直半径 c)单位：百分比(相对于自身宽高)和像素d)最好使用%e)img 也可以使用圆角，但是效果通常不怎么样 边框图片a)路径border-image-sourceb)裁剪border-image-slicec)平铺border-image-repeat:可选value值如下i.repeat平铺（无优化，就是普通的平铺，在四角交界处可能会有误差）ii.round：平铺（优化过的repeat,很完美哦）iii.stretch：拉伸(默认值，宽和高谁长就拉伸谁，不平铺)d)边框宽度：border-image-width:通常设置和裁剪slice一个数值，但是slice没单位，width单位为px eg:先选择一张边框素材图： 由fireworks测量得知一个小方块大小27px，所以border-image-slice值为27，同时，border-image-width值为27px;CSS: 12345678910111213div&#123; width: 500px; height: 400px; border: 1px solid transparent; /*新版chrome浏览器需要先写border，在把border-image属性设置在 border之后才能显示图片边框*/ border-image-source: url(\"images/border.png\"); border-image-slice: 27; border-image-width: 27px; border-image-repeat: round; margin: 100px auto; padding: 2em; box-sizing: border-box;/*内减模式*/&#125; html: 123&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 效果： 二、背景一）backgrounf-size：背景大小，其可选value值如下： 1.背景尺寸：数值，百分比，和普通的图片设置一样 2.cover覆盖：图片等比例放大，保证完全覆盖混盒子，不保证完全显示。会超出，但是这个值使得背景图片，有一定的自适应效果【背景绝对会完全铺满，不留空白，但是有可能会超出部分不显示】 3.contain包含 : 最大化的等比例显示在盒子中。不会铺满盒子，有一定的自适应效果【可能会背景铺不满，有空白】 4.cover,contain都会自适应盒子尺寸,个人偏爱cover一点，因为他不会留白啊 二） background-origin ： 背景原点 a) 默认背景从padding-box开始平铺 b) background-origin 可选value值： border-box、padding-box(默认)、 content-box 效果图： padding-box(默认值) border-box： content-box： 三）background-clip ： 背景裁剪 ,可选属性值如下： a) border-box b) padding-box c) content-box d) 设置谁，超出谁的就裁减掉 e) clip属性值要是比原点的范围大，不起作用 tips1.背景裁剪和背景原点移动，移动web会用到tips2.多背景用逗号隔开tips3.背景颜色写在最后或者单独写 三、渐变：还是属于背景，是颜色渐变一） 线形渐变【linear-gradient】 (等同于background-image)【用的是to】 1.设置完gradient之后仍然可以当作background-image 来设置宽高，repeat之类属性 2.background-image：linear-gradient（方向，起始颜色，终止颜色）； 方向： to right：从左到右 to left 到左 to top 到上 方向还可以定义角度 ，单位为 deg 3.多颜色渐变(百分比就是盒子从这个方向开始，进行到百分之多少就换颜色)【渐变是模糊的样子】 1background-image: linear-gradient(to right,red 0%,blue 30%,yellow 60%); 4.颜色突变【图片就是色彩分明】 1background-image: linear-gradient(to right,red 0%,red 30%,blue 30%,blue 60%,yellow 60%,yellow 100%); （注：背景渐变可以当作background-image来设置background-size、repeat等） 二） 径向渐变【radial-gradient】【用的是at】 1.radial-gradient（辐射半径 中心点位置，起始颜色，终止颜色） 2.中心点颜色，at left，right，top，bottom，center 3.at 50px（水平距离） 50px（垂直距离） 径向渐变就是在盒子某一处为圆心，设置好半径来辐射 四、过渡（这个可厉害了!CSS3实现动画啊！） 1.transition：过渡属性 过渡持续时间 加速度（linear：匀速） 延迟时间 a)transition-property：过渡属性 b)transition-duration：过渡持续时间 (几秒动画结束) c)transition-timimg-function：加速度如何，其取值如下： 1.linear：匀速 2.ease：减速 3.ease-in：加速 4.ease-out：减速 5.ease-in-out：先加速后减速 d)transition-delay：过渡延迟 2.如果需要所有属性都过渡 a)transition-property：all 【写all性能不好】 可以写成这样:transition:transform 2s;意思为，只有transform(rotate,translate,scale)变换给他过渡,其他的宽高背景色之类的不给过渡。 最后：简写方法： 1transition:all 0.7s ease-in-out; 五、2D变换 1.transform:其value值如下： 缩放（scale）、位移（translate）、旋转（rotate） tips:变换后不会影响其他盒子，很乖巧吧！~ 2.缩放scale（倍率） a)不可以写百分数 b)大于1是放大，小于1缩小 (eg: transform:scale(2,0.5);【水平放大2倍，竖直缩小一半】) c)写一个值，宽高等比缩放 d)内容也会等比缩放e)写两个值，第一个是水平缩放倍率，第二个是垂直缩放倍率 3.位移translate（） a)右移正数，左移负数（右下为正，左下为负） b)第一个值水平移动，第二个值垂直移动距离 c)可写百分比数值，相对与自身的尺寸d)盒子在父盒子中居中方法【translate引申运用！】 width: 300px; height: 150px; ``` ```cssleft: 50%; 12margin-left: -150px; ``` ```css /*推荐方法，利用translate位移向左移动50%*/ left:50%; transform:translate(-50%); 4.旋转：rotate（角度） a) 正值顺时针，负值逆时针 b) 旋转中心：transform-origin：水平坐标 垂直坐标 c) 默认旋转中心：几何中心 未完待续。。。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"CSS3入坑记(一)","date":"2017-03-13T16:22:15.000Z","path":"2017/03/14/CSS3入坑记(一)/","text":"一、给力的选择器 1.标签选择器。 类名选择器，id选择器。后代选择器，标签指定（交集）选择器 。并集选择器，子代选择器，通配符等基础的选择器 a)div+p：选择div后第一个兄弟p（紧跟div）还是兄弟关系哦 b)div~p：选择div后所有兄弟P 大家都是兄弟，给良辰一个面子 2.属性选择器 tips：通过标签属性来选择 ①div[属性] ②div[class^=‘aa’]：有class属性并且属性属性值以aa开头③div[class$=‘aa’]：有class属性并且属性属性值以aa结尾④div[class*=‘aa’]：有class属性并且属性属性值包含aa 3.伪类选择器 伪类，伪元素都可以修饰dom元素，但是伪类还是类，对整个类进行修饰 3.1 普通伪类 ①：link ：正常状态 ②：visited 已访问过的链接 ③：hover 鼠标经过 ④：action 点击 ⑤:lvha 3.2 结构伪类 所选到的标签类型必须是E否则无效 E ：first-child：选择E父盒子中的第一个E E ：last-child：选择E父盒子中的最后一个E E ：nth-child（5）：选择E父盒子中的第5个E（标号从1开始） E ：nth-child（odd/even）：选择E-父盒子中编号为奇数/偶数的E标签 a) E ：nth-child（2n）：选择E父盒子中的所有编号为偶数的E b) E：nth-child（2n+1）：选择E父盒子中的所有编号为奇数的E E ：nth-child（n）：选择E父盒子中的所有E a) n &lt; 1无效 E ：nth-child（n）：选择E父盒子中的所有E，-n全不选 E ：nth-child（-n+5）：选择E父盒子中的前五个E标签 E ：nth-last-child(1):倒数第一个 E ：nth-last-child（-n+5）：选择倒数第五个 E ：nth-child（7n）：选择编号为7的倍数的标签 E ：nth-child（7n-1）：选择编号为7的倍数减1的标签 3.3状态伪类 E:empty 如果盒子是空的就会被选中 E:target 通常和锚点配合使用，比如一个h2标签代表一段的标题，然后通过锚点到达该处，该h2就会显示出相应的样式 4.伪元素 伪元素只是元素，他只能修饰被修饰者内部的某一部分内容，而非整个类 1) 伪就是假的，通过css模拟出html效果，必须有content属性 2) 伪元素虽然可以单:，但是在CSS3规范中规定伪类用:，伪元素用双:: 3) ::before，在之前添加 123div::before&#123; content : \"在前面\"; &#125; 4) ::after，在之后添加 1234div::after&#123; content : \"在后面\"; color: #f00; &#125; 5) 产生的伪元素相当于div的子元素 6) 伪元素可以使用标签的属性(啥宽、高、bgc、display之类的)，如下eg: css:123456789101112span::before&#123; content: '今天'; background: paleturquoise; display: inline-block; width: 60px; height: 30px; &#125; span::after&#123; content: '真好'; background: darkseagreen; &#125; /*必须要写content*/ html: 123&lt;body&gt;&lt;span&gt;天气&lt;/span&gt;&lt;/body&gt; 效果： ::bofore和::after可以做图标放在字体前后 5 伪元素选择器选中盒子里的某一块区域1) ::frist-letter 选择第一个字母2) ::frist-line 选择第一行3) ::selection 选择区域的样式 (网页上选中一段文字一般是蓝色框和白色背景，可以自己换颜色)a)一般只设置背景颜色和字体颜色4) 通常用::first-letter和flaot:left以及字体加大设置首字下沉，如下：二、颜色的升级 设置透明色的话 传统的opcity属性会被子代继承，且子代的opacity属性不能修改，多可怕 transparent；完全透明，无法修改属性值，直接没了，你也太狠了 CSS3引入新的颜色方式 RGBA模式 a)红绿蓝 b)alpha（透明度） HSLA模式a)H:色相、色调 0-360（红橙黄绿青蓝紫）b)S:饱和度 0-100%c)L:明度 、亮度 0-100%d)A:透明度 0-1 tips：有颜色的地方都可以用半透明 三、文本阴影的引入 文本阴影a)text-shadow：水平距离 垂直距离 模糊程度 颜色*（注意：文本阴影前三个值单位为px，文本可以设置3个px属性，而box-shadow可以再多一个px属性为阴影面积）b)左下为正，右上为负c)一个文本可以有多个阴影，用逗号隔开，常用一黑一白的阴影来做凹凸字(黑白阴影模拟光照) 四、CSS3盒子模型(重点) 传统盒子模型传统盒子中，我们看到的：a)宽度 = padding+border+widthb)内容区域大小不变c)总体大小变化 CSS3盒子模型a) 可以给盒子设置box-sizing属性属性值为：content-box/padding-box/border-box 设置谁，谁不变 content-box：内容盒子，外加模式，整个盒子撑大,内容盒子不变，加大边距和边框会加大总体大小，内容区域大小不变 border-box：边框盒子，内减模式，整个盒子大小不变，内容盒子减小。加内边距和边框只会减小内容的大小 五、私有化前缀有些CSS属性浏览器无法识别时，可以在属性值前加上私有化前缀，以让浏览器识别。 可以解决兼容性 问题 -webkit- 谷歌、苹果浏览器内核 -moz- 火狐浏览器内核 -ms- IE浏览器内核 -o- 欧鹏浏览器内核 兼容性写法示例： 123456background: -webkit-linear-gradient(left,aquamarine,skyblue); background: -moz-linear-gradient(left,aquamarine,skyblue); background: -ms-linear-gradient(left,aquamarine,skyblue); background: -o-linear-gradient(left,aquamarine,skyblue); background: linear-gradient(left,aquamarine,skyblue); /*最后一行加上正常的不加私有化的*/ tips1：最后要加无前缀的样式tips2：加私有化前缀如果也无法解决，放弃 tips3：这里只是做个实例，一般线性渐变背景写法为： 1background: linear-gradient(to right,yellow 0%,pink 30%,blue 60%,red 100%); 接下来，让我们在CSS3入坑记（二）再相会！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Html5入坑记","date":"2017-03-11T09:30:07.000Z","path":"2017/03/11/Html5入坑记（一）/","text":"一、标准改变Html4.0 网页开发： html -&gt; 结构 4.0 Css -&gt; 样式 2.0 Js -&gt; 行为 用户交互HTML5.0 html4.0 升级版: Html5 -&gt; 结构 5.0 css3 -&gt; 样式 js -&gt; 行为 js API 有所增强 地理定位 web存储 拖拽 HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。广义概念：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器呈现技术得到了一个飞跃发展和广泛支持，它包括：HTML5，CSS3，Javascript，API在内的一套技术组合 H5范称HTML + CSS3 + JS优点：HTML5的优点 二、Html结构 新增语义化标签①语法规范，去除冗余内容，书写规则简洁、清晰。 dtd简洁、标签不用写关闭符号、双标签省略结束标签、html、head、body、colgroup、tbody可以完全省略 实际开发中应规范书写，不建议太随意 ！如图 ②新增语义标签12345678910&lt;nav&gt; //表示导航&lt;header&gt; //表示页眉&lt;footer&gt; //表示页脚&lt;section&gt; //表示区块&lt;article&gt; //表示文章 如文章、评论、帖子、博客&lt;aside&gt; //表示侧边栏 如文章的侧栏&lt;figure&gt; //表示媒介内容分组 与 ul &gt; li 做个比较&lt;mark&gt; //表示标记 (带用“UI”，不怎么用)&lt;progress&gt; //表示进度 (带用“UI”，不怎么用)&lt;time&gt; //表示日期本质上新语义标签与div、span没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别对于传统的网页布局，采用div+css，给div给定header,nav,section,aside,article,footer等class，h5新增了该语义化标签，便于理解和网站seoH5经典网页布局123456789101112&lt;!-- 头部 --&gt;&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;!-- 主体部分 --&gt;&lt;section&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/section&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt;h5兼容IE处理l less 小于t than 比e equal 等于g great 大于三、表单新特性——–①输入类型123456789101112email 输入email格式tel 手机号码 url 只能输入url格式number 只能输入数字search 搜索框range 范围 滑动条color 拾色器time 时间date 日期 不是绝对的--datetime 时间日期month 月份week 星期部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 ②新的表单标签 datalist : 可以和input关联起来,变成特殊的select 12345678910&lt;input type=\"text\" list=\"car\" title=\"\"&gt;&lt;!--可以用datalist和input关联起来--&gt;&lt;datalist id=\"car\"&gt; &lt;option&gt;宝马&lt;/option&gt; &lt;option&gt;宝骏&lt;/option&gt; &lt;option&gt;宝强&lt;/option&gt; &lt;option&gt;奥拓&lt;/option&gt; &lt;option&gt;奥迪&lt;/option&gt; &lt;option&gt;大众&lt;/option&gt;&lt;/datalist&gt; keygen 生成加密字符串 1234keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 服务器获取客户端的私钥后可用来和公钥比较判断是否被劫持过。 output 仅仅在页面表单里展示数据，没啥用，还不能提交 meter 表示度量器，不建议用作进度条 progress Min-width 三、表单属性 placeholder 占位符 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成，用于表单元素，也可用于表单自身(on[默认开启]/off) ‘ autofocus：自动获取焦点 novalidate 关闭验证，可用于form标签 required 必填项 pattern 正则表达式 验证表单 1手机号:&lt;input type=\"tel\" name=\"tel\" required=\"required\" pattern=\"^(\\+86)?1[3,5,8](\\d&#123;9&#125;)$\"&gt; 四、表单事件 oninput 用户输入内容时触发，可用于移动端输入字数统计 oninvalid 验证不通过时触发 五、多媒体 之前在网页上播放多媒体必须依赖第三方插件 mediaplay、flash插件等 现在在H5里面提高了视频、音频标签，可以不求人啦 audio音频标签、video视频标签 a)controls:播放控制条 b)autoplay：自动播放 c)loop：循环播放 d)音频支持：mp3/wav/ogg e)视频支持：mp4、ogg、webm tips：vidio格式为行内块 f)source引用方式来做兼容 123456&lt;audio controls&gt; &lt;source src = \"music.mp3\"&gt; &lt;source src = \"music.ogg\"&gt; &lt;source src = \"music.wav\"&gt; 抱歉，你的浏览器不支持音频标签 &lt;/audio&gt; 六、dom扩展Tips:Html5对dom进行了扩展，使得多出很多api来操作document(dom)，跟JQuery一样方便，还不用引入JQ的类库，妈妈再也不用担心我忘记带JQ类库啦! document 文档对象①类操作 1234561.var new = document.querySelector（“选择器”）//只会选择符合条件的第一个元素2.var newArr = document.querySelectorAll(“选择器”)3.box.classList.add(“类名”)：//添加类名4.box.classList.remove(“类名”)://删除类名5.box.classList.contains（“类名”）：//是否包含某个类名6.box.classList.toggle(“类名”)://切换类名 ②自定义属性（假设有一个class为box的div）1.自定义属性必须以data开头（格式：data-属性名=””） 1eg:&lt;div class=&quot;box&quot; data-myData=&quot;lalala&quot;&gt;&lt;/div&gt; 2.获取标签属性 a)原有属性 .box.属性名 b)自定义属性 .box.dataset[‘data后的部分’] eg: .box.dataset[‘myData’] 特别注意！:如果自定义属性的属性名为data-my-name，那么获取的时候要 .box.dataset[“myName”]","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"JQuery动画之动画队列和stop方法","date":"2017-03-06T12:08:39.000Z","path":"2017/03/06/JQuery动画之动画队列和stop方法/","text":"在介绍动画队列之前，先谈谈js的单线程和浏览器的事件驱动。 Javascript是单线程的【转】因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。 异步事件驱动前面已经提到浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。每个浏览器具体实现主事件队列不尽相同，在此不赘述。 浏览器不是单线程的虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程： javascript引擎线程 界面渲染线程 浏览器事件触发线程 Http请求线程 很多人弄不清，如果js是单线程的，那么谁去轮询大的Event loop事件队列？答案是浏览器会有单独的线程去处理这个队列。 Ajax异步请求是否真的异步? 很多人不清楚，既然说JavaScript是单线程运行的，那么XMLHttpRequest在连接后是否真的异步? 其实请求确实是异步的，这请求是由浏览器新开一个线程请求（见前面的浏览器多线程）。当请求的状态变更时，如果先前已设置回调，这异步线程就产生状态变更事件放到 JavaScript引擎的事件处理队列中等待处理。当浏览器空闲的时候出队列任务被处理，JavaScript引擎始终是单线程运行回调函数。javascript引擎确实是单线程处理它的任务队列，能理解成就是普通函数和回调函数构成的队列。 总结一下，Ajax请求确实是异步的，这请求是由浏览器新开一个&gt;线程请求，事件回调的时候是放入Eventloop单线程事件队列等候处理。 setTimeout(func, 0)为什么有时候有用？ 写js多的人可能发现，有时候加一个setTimeout(func, 0)非常有用，为什么？难道是模拟多线程吗？错！前面已经说过了，javascript是JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，setTimeout(func, 0)神奇在哪儿？那就是告诉js引擎，在0ms以后把func放到主事件队列中，等待当前的代码执行完毕再执行，注意：重点是改变了代码流程，把func的执行放到了等待当前的代码执行完毕再执行。这就是它的神奇之处了。它的用处有三个： ①让浏览器渲染当前的变化（很多浏览器UI render和js执行是放在一个线程中，线程阻塞会导致界面无法更新渲染） ②重新评估”script is running too long”警告 ③改变执行顺序 接下来，我们来聊聊JQuery的动画队列。【原】在用户触发动画事件时，也将会把动画方法放入队列中，以队列的方式执行。如下图，该粉色的div盒子，可以由上方的按钮触发滑入滑出动画。(最后一个停止先不看) 12345678910111213&lt;script&gt; $(document).ready(function () &#123; $(\"button:eq(0)\").click(function () &#123; $(\"div:eq(0)\").slideDown(\"slow\"); &#125;); $(\"button:eq(1)\").click(function () &#123; $(\"div:eq(0)\").slideUp(\"slow\"); &#125;); $(\"button:eq(2)\").click(function () &#123; $(\"div:eq(0)\").stop(true,true); &#125;); &#125;); &lt;/script&gt; 当依次点击滑入、滑出按钮时，会将slideDown和slideUp方法依次放入事件队列中，待处理完之前的事件后，会按两个方法入队列的顺序依次执行，也就是先执行slideDown再执行slideUp方法。如果我们将动画的执行时间设置的再慢些(动画方法中的参数:fast:200ms,normal:400ms,slow:600ms)，如3000ms时，你会看到该盒子会慢慢地展开，等完全展开完毕后才会再收起，这就是按入队列顺序执行动画。接下来就可以聊聊JQuery中的stop方法。该方法有三个参数(type,clearQueue, gotoEnd)，第一个type参数先不谈，方法的clearQueue, gotoEnd参数分别为什么意思呢？让我们通过实验来了解。 stop方法的上述2个参数默认都为false。 默认false,false ① 第一种情况:false,false (后续动画不停止,当前动画不继续执行,原地停下) 1$(\"div:eq(0)\").stop(false,false); ②第二种情况:true,false(后续动画停止，当前动画不继续执行,原地停下) 1$(\"div:eq(0)\").stop(true,false); ③第三种情况:false,true(后续动画不停止,当前动画立马执行完成) 1$(\"div:eq(0)\").stop(false,true); ④第四种情况:true,true; (后续动画停止,当前动画立马执行完成) 1$(\"div:eq(0)\").stop(true,true) 看到这，应该已经明白。第一个clearQueue参数代表是否停止后续动画(true表示停止后续动画),第二个 gotoEnd代表当前动画是立即完成还是直接原地停下(true表示当前动画立马执行完成，false表示当前动画立马原地停下)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JQuery选择器小结","date":"2017-03-05T07:45:53.000Z","path":"2017/03/05/JQuery选择器小结/","text":"先贴张图 “引号内选择器”以下选择器，都在$(“”)的双引号内写 一丶基本选择器 1234$(\"#top\") //id选择器，返回单个$(\"div\") //标签选择器，返回数组 $(\".box\") //类选择器，返回数组 $(\"*\") // 选择文档中所有元素，返回数组 二丶层级选择器 1234$(\"form input\") //选择所有的后代 $(\"div &gt; .box\") //选择子代(亲儿子)$(\"label + input\") //[返回]label标签后面直接跟一个input标签的所有[input标签] $(\"#prev ~ div\") //同胞选择器，[返回]id为prev的所有同父[div同胞] 三丶基本过滤选择器 123456789101112$(\"tr:even\") //返回偶数tr（注意：返回数组，序号从0开始,0,2,4..） $(\"tr:odd\") //返回奇数tr $(\"td:eq(2)\") //索引等于2的td $(\"td:gt(4)\") //索引大于4$(\"td:ll(4)\") //索引小于4 $(\"tr:first\") //所有tr元素的第一个 $(\"tr:last\") //所有tr元素的最后一个 $(\"input:checked\") //所有被选中的input$(\"input:not(:checked)\") //所有没被选中的input$(\":header\") //所有的标题元素(h1-h6)$(\"div:animated\") //所有正在运动的div 四丶内容过滤选择器 (根据内容来选择) 1234$(\"div:contains('github')\") //选择所有div中含有github文本的[div]$(\"td:empty\") //选择所有内容为空（也不包括文本节点）的[td]$(\"div:has(p)\") //选择所有含有p标签的[div元素] $(\"td:parent\") //选择已为人父的[td](有子标签或文本都算为人父) 五丶可视化过滤选择器 12$(\"div:hidden\") //被hidden的div元素 $(\"div:visible\") //可视化的div元素 六丶属性过滤选择器 (根据属性来选择) 1234567$(\"div[id]\") //选择所有含有id属性的div元素 $(\"input[name='news']\") //选择name属性为'news'的input元素$(\"input[name!='newsletter']\") //选择name属性不为'news'的input元素$(\"input[name^='news']\") //选择name属性以'news'开头的input元素 $(\"input[name$='news']\") //选择name属性以'news'结尾的input元素 $(\"input[name*='color']\") //选择name属性包含'color'的input元素$(\"input[id][name$='color']\") //多个属性联合选择 七丶子元素过滤选择器 123$(\"div span:first-child\") //返回所有的div元素的第一个子节点的数组 $(\"div span:last-child\") //返回所有的div元素的最后一个节点的数组 $(\"div button:only-child\") //只有唯一一个子节点的所有子节点的数组 八丶表单元素选择器： 1234567891011$(\":input\") //所有的表单元素，input, textarea, select等 $(\":text\") //所有的text input元素 $(\":password\") //所有的password input元素 $(\":radio\") //所有的radio input元素 $(\":checkbox\") //所有的checkbox input元素 $(\":submit\") //所有的submit input元素 $(\":image\") //所有的image input元素 $(\":reset\") //所有的reset input元素 $(\":button\") //所有的button input元素 $(\":file\") //所有的file input元素 $(\":hidden\")//所有hidden input元素 九丶表单元素过滤选择器 1234$(\":enabled\") //选择所有的可操作的表单元素 $(\":disabled\") //所有的不可操作的表单元素 $(\":checked\") //所有的被checked的表单元素 $(\"select option:selected\") //所有的select的子元素option中被selected的option “方法调用选择器”以下都为【方法】，需要在$(“”)外.方法() 1234567.find(selector) //后代查找.children(selector) //子代查找.parent(selector) //查找亲父亲.siblings(selector) //查找所有兄弟.eq(index) //相等查找.prev(selector) //查找前一个兄弟.next(selector) //查找后一个兄弟 1注：方法中有selector，为选择器的意思，如果方法不加参数，默认选择，加了参数就多了一层筛选，比如$(\".box\").find()为查找class为box的所有后代，而$(\".box\").find(\"ul\")为查找它的所有ul后代而非全部后代","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"第二章 Java内存区域与内存溢出异常","date":"2017-03-02T06:10:10.000Z","path":"2017/03/02/第二章-Java内存区域与内存溢出异常/","text":"2.2 运行时数据区域 图1.1 Java虚拟机运行时数据区 2.2.1 程序计数器 (线程私有) 程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都依赖这个计数器。java多线程是通过处理器轮流切换并分配处理器执行时间的方式来实现，在一个处理器，或者多核处理器的一个内核中，都只会执行一条线程中的指令，为了在java多线程切换后能回到正确的执行位置，所以程序计数器是每个线程独立独占的。 线程执行：Java方法： 计数器记录的是正在执行的虚拟机字节码指令的地址。Native方法： 计数器为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OOM情况的区域。 2.2.2 Java虚拟机栈 (线程私有) 生命周期与线程相同,虚拟器栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储 局部变量表、操作数栈、动态连接、方法入口等。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：存放编译期可见的各种数据类型(boolean,byte,char,short,int,float,long,double)、对象引用(reference类型)、returnAddress类型(指向一条字节码指令的地址) Jvm栈有两种异常情况：StackOverflowError：线程请求的栈深度大于虚拟机允许的深度OutOfMemoryError：虚拟机栈可以动态扩展，当扩展时无法申请到足够内存抛出 2.2.3 本地方法栈 (线程私有) 与虚拟机栈作用非常相似，不过执行的是本地方法，语言、数据结构都没强制规定，为虚拟机使用到的Native方法服务。也会抛出StackOverflowError和OutOfMemoryError 2.2.4 Java堆 (线程共有) 在虚拟机启动时创建，是Java虚拟机管理的最大一块内存，也是垃圾收集器管理的主要区域(所以很多时候也称作GC堆)。此内存区域唯一目的就是：存放对象的实例。 从内存回收角度，Java堆可以细分为：新生代和老年代，再细点就是 Eden空间、Form Survivor空间、To Survivor空间从内存分配角度，线程共享的Java堆可以划分出： 多个线程私有的分配缓冲区(TLAB，Thread Local Allocation Buffer) 不论怎么划分，都与存放内容无关，存放的都是对象实例，划分都为了更好的回收内存或更快地分配内存。 —未完待续","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"http://yoursite.com/tags/《深入理解Java虚拟机》/"}]},{"title":"JVM常用参数种类","date":"2017-03-02T05:22:09.000Z","path":"2017/03/02/JVM常用参数种类/","text":"一、配置堆区(-Xms、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn)①-Xms：表示Java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。 ②-Xmx：表示Java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的1/4大小。但是开发时，通常会将-Xms与-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配隔离计算堆区大小而浪费资源。一般对堆区的内存分配只需配置上述两个参数(-Xms,-Xmx)即可，但如果想细化，可配置以下三个参数(-XX:newSize、-XX:MaxnewSize、-Xmn) 对堆区进一步细分。 1)-XX:newSize：新生代内存的大小，应小于-Xms的值2)-XX:MaxnewSize：由字面意思可知，新生代可被分配的最大内存，应小于-Xmx的值3)-Xmn：对上面两个参数同时配置，即 -Xmn = -XX:newSize = -XX:MaxnewSize 在JDK1.4以后才可用-Xmn这个很厉害的参数 二、配置非堆区①-XX:PermSize：表示非堆区初始内存分配大小.(Permanent Size)持久化内存 ②-XX:MaxPermSize：表示非堆区分配的最大内存上限 注意！在配置之前要慎重考虑该非堆区内存大小，因为此处是不会被Java垃圾回收机制进行处理同时，最大堆内存+最大非堆内存 &lt; 操作系统可用内存 eg示例: 1VM参数：-verbose : gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX : SurvivorRatio = 8 表示为：Java堆大小为20M，不可扩展，10M给新生代，10M给老年代，新生代中Eden区： Survivor区 = 8：1新生代可用总空间为: Eden区 + 1个Survivor区 即 10M * 9/10 = 9M","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"正则表达式小结 ","date":"2017-03-01T15:04:47.000Z","path":"2017/03/01/正则表达式小结/","text":"一、创建方式js中，创建正则表达式的两种方式： 121.通过构造函数定义var 变量名= new RegExp(/表达式/); 122.通过直接量定义var 变量名= /表达式/; 二、五大内置对象1.预定义类① .除了换行和回车符(\\r\\n)其他的都可以 12console.log(/./.test(\"\\n\\r\"));//false console.log(/./.test(\"sa35490df574!@@$\"));//true ②\\d数字才能匹配 12console.log(/\\d/.test(\"132465465\"));//trueconsole.log(/\\d/.test(\"abs\"));//false ③\\D非数字才能匹配 12console.log(/\\D/.test(\"132465465\"));//false console.log(/\\D/.test(\"abs\"));//true ④\\s空格才能匹配 12console.log(/\\s/.test(\" \"));//true console.log(/\\s/.test(\"sad\"));//false ⑤\\S非空格才能匹配 12console.log(/\\S/.test(\" \"));//falseconsole.log(/\\S/.test(\"sad\"));//true ⑥\\w对单词的匹配12\\w：单词才能匹配，匹配字母或数字或下划线 [a-zA-Z_0-9] 单词字符\\W：非单词才能匹配[^a-zA-Z_0-9] 非单词字符 ⑦\\d代表单词的开头和结尾 1/\\dstudy\\d/ 2.简单类 12345678①/string/.test(\"string\") //中间是任意字符串，只要完整包含他即可(有他就行，完整的他)console.log(/git520/.test(\"gi\"));//fasleconsole.log(/git520/.test(\"asdgit520#$\"));//trueconsole.log(/git520/.test(\"052tig\"));//false 反向不行②/[string]/.test(\"string\") //[]整体对应一个字符，如[abc]，只要有[string]内的任意一个字符，都可以 console.log(/[520git]/.test(\"ilove\"));//true 3.负向类 123456 //[^string] 对括号内的字符取反，不够和正好返回false，多了和没有返回true(eg:[^abc]中，只有test a,ab,abc都返回false,其他的都是true)console.log(/[^abc]/.test(\"a\"));//falseconsole.log(/[^abc]/.test(\"ab\"));//falseconsole.log(/[^abc]/.test(\"abc\"));//falseconsole.log(/[^abc]/.test(\"abs\"));//true//就是/[^abc]/.test() 只要test 的是a,ab,abc就错,其他的都对 4.范围类 123456//只要存在字符在这个范围内的都行console.log(/[a-c]/.test(\"b\"));//trueconsole.log(/[a-c]/.test(\"ss\"));//falseconsole.log(/[a-c]/.test(\"sasd\"));//true 5.组合类 123456789//组合起来，存在这个范围内的字符都可以,一个[]就代表一个字符console.log(/[a-c1-3]/.test(2));//trueconsole.log(/[a-c1-3]/.test(\"a\"));//trueconsole.log(/[a-c1-3]/.test(\"abs23fz\"));//trueconsole.log(/[a-c1-3]/.test(\"z5\"));//true 三、正则边界 1.正则边界 12345//1.以^开始，以$结尾，代表精确匹配//注：^只有在[]里表示取反。在//表示正则的开头console.log(/^rick$/.test(\"rick\"));//trueconsole.log(/^rick$/.test(\"rickl\"));//fasleconsole.log(/^rick$/.test(\"ric\"));//false 四、量词 1.量词 ❤（多个字母，重复最后一个）❤ 12345678910111213141516171819202122232425// * 贪婪 大于等于0// + 懒惰 大于等于1// ? 占有 要么0要么1console.log(/^a*$/.test(\"\"));//true 0次可以console.log(/^a*$/.test(\"a\"));//trueconsole.log(/^a*$/.test(\"aaaa\"));//trueconsole.log(/^a*$/.test(\"aaab\"));//false 因为^$控制了边界内只能有大于等于0个aconsole.log(/^a*$/.test(\"b\"));//false b更错了console.log(/^zxcv*$/.test(\"zxcvv\"));//true 多个字母，重复最后一个console.log(/^zxcv*$/.test(\"zxc\"));//true 大于等于0，0个也可以console.log(/^zxcv*$/.test(\"zxzv\"));//false 边界定义了，边界内必须要完全匹配 // &#123;&#125;重复多少次的意思，&#123;n&#125; n次 &#123;n,&#125; n次即以上 &#123;n,m&#125; n&lt;=x&lt;=m// * &#123;0,&#125;// + &#123;1.&#125;// ? &#123;0.1&#125;// x|y x或者y //()括号：提高权限，优先计算 | :前后只要有一个符合即可console.log(/(abc)|(xyz)/.test(\"abcq\"));//trueconsole.log(/(abc)|(xyz)/.test(\"sxyz\"));//trueconsole.log(/(abc)|(xyz)/.test(\"abxy\"));//false 都没有完整符合abc或xyz中的一个console.log(/(abc)|(xyz)/.test(\"ab\"));//false 同上 五、练习 1.练习 12//eg: 0562-2812914 (0开头，4位)-(2开头，7位) var RegExp = /^0\\d&#123;3&#125;-2\\d&#123;6&#125;$/; —未完待续","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"springmvc使用hibernate-validator校验框架实现后端校验","date":"2017-02-28T05:20:18.000Z","path":"2017/02/28/springmvc使用hibernate-validator校验框架实现后端校验/","text":"一 springmvc校验springmvc使用JSR-303校验规范，JSR-303是javaEE6的规范。 springmvc具体使用hibernate-validator校验框架（和hibernate的ORM没有关系），hibernate-validator基于javabean的属性校验。 二 实现步骤① 添加jar包支持 本例使用hibernate-validator 4.3.0.Final版本 maven的pom文件引入以下内容即可 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;4.3.0.Final&lt;/version&gt;&lt;/dependency&gt; jboss-logging和validation-api为其依赖。 ② 在springmvc的处理器适配器中配置validator：1&lt;mvc:annotation-driven validator=\"validator\"/&gt; 定义validator的bean 1234567891011121314151617181920&lt;!-- 定义校验器 --&gt; &lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;!-- 校验器 --&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" /&gt; &lt;!-- 指定校验使用的资源文件，如果不指定则默认使用classpath下的ValidationMessages.properties--&gt; &lt;property name=\"validationMessageSource\" ref=\"messageSource\" /&gt; &lt;/bean&gt; &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomerValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=\"fileEncodings\" value=\"utf-8\"/&gt; &lt;!-- 对资源文件内容缓存时间，秒 --&gt; &lt;property name=\"cacheSeconds\" value=\"120\"/&gt; &lt;/bean&gt; ③ 在需要校验的javaben实体类中添加相关校验注解，此处以Items这个po类为例 123456789public class Items &#123; @Size(min=1,max=30,message=\"&#123;item.name.length&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) @NotNull(message=\"&#123;item.name.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private String name; private String pic; @NotNull(message=\"&#123;item.createdate.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private Date createtime; 相关的校验规则由注解名称即可理解，这里解释下注解内的属性含义。message为出现错误时的提示信息，groups为将我们的校验器分组，因为po类是共用的，可能同一个字段在不同的场景下有不同的校验需求，所以将其分组，在controller中进行校验时，可指定分组，来进行校验。分组groups中的XXX.class为定义的一个“空的interface”，没有含义，仅仅只是为了分组。 在po类中利用注解进行校验分类和定义后，可以在后台进行校验，一般选择在service层，因为判断数据合法性属于业务需求，可是在有些情况下，对于用户的体验性来说，如果在controller就进行数据合法性校验，如果不合法可以直接返回，不调用service，响应稍微快些，用户体验好。所以此例中在controller层进行校验。 ④ 在后台通过注解校验 12345678910111213141516// 修改商品提交 @RequestMapping(\"/saveItems\") public String saveItems(Model model, Integer id, @Validated(value = &#123; ItemsValidationForEdit.class&#125;) Items item, BindingResult bindingResult) throws Exception &#123; if (bindingResult.hasErrors()) &#123; List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); model.addAttribute(\"allErrors\", allErrors); return \"editItem\"; &#125; // 更新 itemsService.updateItems(id, item); // 返回成功页面 // 重定向到商品查询 return \"forward:queryItems.action\"; &#125; controller方法参数中的@Validated(value = { ItemsValidationForEdit.class}) Items item, BindingResult bindingResult） 含义为： 对Items这个形参进行校验，选择他其中定义的ItemsValidationForEdit这个分组的校验规则。 注意：如果你需要进行校验，在方法参数中，需要在校验对象的前后加上@Validated和BindingResult bindingResult，他们是成对出现的。 顺便贴下hibernate-validator的校验注解 123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"SpringMVC中post、get乱码解决","date":"2017-02-28T05:14:14.000Z","path":"2017/02/28/SpringMVC中post、get乱码解决/","text":"一 乱码原因由于中间件为Tomcat，用户请求和返回的响应都需要经过tomcat，tomcat默认编码为ISO-8859-1和我们程序的编码(一般为UTF-8)不同，导致post、get请求乱码。 二 解决方案 Post乱码解决方案：在web.xml中添加编码过滤器来解决，可以自己编写过滤器，最常用的方法是使用spring提供的编码过滤器：在Web.xml中增加如下配置（要注意的是它的位置一定要是第一个执行的过滤器） 12345678910111213&lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 该过滤器要做的其实就是强制为所有请求和响应设置编码格式：request.setCharacterEncoding(“utf-8”);response.setCharacterEncoding(“utf-8”); GET乱码解决方案 针对Get方式的乱码问题，由于参数是通过URL传递的，所以上面通过request设置的编码格式是不起作用的12345678910方法①修改tomcat目录 的conf/server.xml文件，添加URIEncoding=\"utf-8\"&lt;Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;只需增加 URIEncoding=\"UTF-8\" 这一句，然后重启tomcat即可。方法②对参数进行重新编码：String userName = new String(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\")ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 通过以上对POST和GET的处理，妈妈再也不用担心我们遇到乱码了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"以mybatis为例浅聊SQL注入","date":"2017-02-28T05:03:08.000Z","path":"2017/02/28/以mybatis为例浅聊SQL注入/","text":"以用户登录为例，传统代码为一个form表单，输入username和password去数据库发送sql检索，用的是字符串拼接${}。 select * from t_user where password = '${password}'and username = '${username}' 如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 此时无论用户名为zhangsan的该用户密码为何值，均能查询出一条记录。 而用了预编译的#{}占位符后代码为 select * from t_user where password = #{password} and username = #{username} 即mybatis发送给数据库的sql为 select * from t_user where password = ? and username = ? 在数据库端便会对该sql进行编译，如果下次有该查询时，mabatis会发送 select * from t_user where password = #{password} and username = #{username} 作为“KEY”，页面传入的参数作为“VALUE”去数据库查询，预编译的方式使得发送至数据库的值为sql “KEY” 和 参数 “VALUE”，数据库根据KEY找到编译好的sql，将参数注入进行查询如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 看到这也许会有疑问，这和传统的字符串拼接，得到的sql还是一样的啊？其实并不是，sql只是数据库端给我们看的一段字符串，真正的查询方式，传统字符串拼接查询，传入数据库的是一个参数，为在程序端拼接好的sql，直接去数据库执行。而预编译方式，传入数据库的是两个参数，一个是 select * from t_user where password = ? and username = ? 语句，一个是值。如果数据库里没该条SQL就会编译好缓存，如果缓存有的话，直接类似“函数接收参数”的方式去执行sql，那么，数据库里是不会有任何一条记录的密码为1111’ or ‘1 = 1，就不会返回记录。从某种意义上来说防止了SQL注入。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"MySQL和Oracle分页的区别","date":"2017-02-28T05:01:20.000Z","path":"2017/02/28/MySQL和Oracle分页的区别/","text":"MySQL和Oracle分页的区别 MySQL 分页 (利用LIMIT关键字） 计算参数为 开始序号(startNum)，要查的总条数 (totalNum) Oracle 分页 (利用自带的rownum) 计算参数为 开始序号(startNum) ， 结束序号 (endNum) Oracle分页利用其自带的rownum，但是rownum在表中不能使用&gt;号(比如select rownum,e.* from emp where rownum &gt; n,n为除了0以外的任何值,查出的都是空)，但是可以使用&lt;,为了避免，所以采用子查询将其rownum转换为子查询表中的一列数据列,而不是数据表自带的rownum属性使其可以使用 这种方式的好处在于，除了中间的业务查询，其余的都是固定的模版，我们只需要关心中间的业务查询即可。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"OCUpload、pinyin4j、poi简单入门","date":"2017-02-28T04:50:16.000Z","path":"2017/02/28/OCUpload、pinyin4j、poi简单入门/","text":"通过几个小demo完成以上三项的简单入门，通过此篇博客，您可以对它们有初步的认识，编写日常简单的应用。具体深入可以查询相关api。 OCUpload OCUpload为JQuery的插件(One Click Upload)，意思为一键上传，封装了对于文件上传的一些方法，只需几行代码，文件上传优雅而简洁。 对于传统的文件上传，只是通过input标签，通过设置enctype为multipart/form-data，选中文件后还需点击按钮，提交表单，才能在后台进行相关字段解析，通过流来进行文件上传，上传成功后，页面多半要刷新，无法给用户良好的体验。 OCUpload实现了页面“不刷新”，选择文件后直接上传，不需要选中文件后再点击按钮上传表单。简单实现为： 在页面的head里引入JQuery的类库，由于这里使用了easyUI使按钮和提示相对美观些，所以也导入了easyUI的核心类库，当然别忘了导入我们的OCUpload的库，本篇博客使用的版本为jquery.ocupload-1.1.2.js.首先在body中使用一个元素来“占位子”，任何标签元素都可以，不过上传文件一般点击按钮，所以我们使用easyUI的linkbutton，给按钮设置id为import.123&lt;body&gt; &lt;a id=\"import\" class=\"easyui-linkbutton\" data-options=\"iconCls:'icon-redo'\"&gt;上传文档&lt;/a&gt;&lt;/body&gt; 在head中给id为import的按钮添加upload事件，这是OCUpload的上传方法，参数为json对象，由于是简单入门，在这里即使用三个主要的属性：action(处理上传文件的后台action路径)，name(给文件设置name，便于后台通过name获取)，onComplete(参数为function，执行上传完毕的回调函数)。12345678910111213141516&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#import\").upload(&#123; action:'$&#123;pageContext.request.contextPath&#125;/regionAction_importXls', name:'upload', onComplete: function (data, self, element) &#123; if(data=='1')&#123; $.messager.alert(\"提示信息\",\"数据导入成功!\",\"info\"); &#125;else&#123; $.messager.alert(\"提示信息\",\"数据导入失败!\",\"info\"); &#125; location.reload(); &#125; &#125;);&#125;);&lt;/script&gt; 到此便完成一键上传的前台代码，只需要后台对上传文件进行解析处理即可完成文件上传。 让我们来看看这些代码做了些什么。访问页面，打开F12调试。可以看到，OCUpload将我们的linkbutton底部添加了一个带有文件input的form和一个display:none 不可见的iframe。 选择文件后form中的input触发onChange事件，直接提交表单，实现了选择文件后直接上传 文件上传后，本来页面是要刷新的，但是OCUpload将target指向底部隐藏的iframe，使得隐藏的iframe刷新，从而达到我们的页面“不刷新”的效果 poixls文件解析 在后台使用poi对上传的xls文件进行解析，将文件中的一行(row)解析成javabean，通过hibernate存入数据库。 12345678910111213141516171819202122232425262728293031public class RegionAction extends BaseAction&lt;Region&gt; &#123; private File upload; public String importXls() throws FileNotFoundException, IOException &#123; HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(upload));//此为poi的核心对象，通过构造方法中的InputStream生成HSSWorkbook对象。 HSSFSheet sheetAt = workbook.getSheetAt(0);//这里得到第一张表格(sheet) List&lt;Region&gt; regions = new ArrayList&lt;Region&gt;(); for (Row row : sheetAt) &#123; //通过遍历sheetAt获取每一行(row),再通过每一行获取每一个值 String value1 = row.getCell(0).getStringCellValue();//id String value2 = row.getCell(1).getStringCellValue();//province String value3 = row.getCell(2).getStringCellValue();//city String value4 = row.getCell(3).getStringCellValue();//district String value5 = row.getCell(4).getStringCellValue();//postcode Region region = new Region(value1, value2, value3, value4, value5); region.setShortcode(StringUtils.join(PinYin4jUtils.getHeadByString(value2+value3), \"\"));//此处利用PinYin4jUtils将表格中的字段转成拼音封装到javabean，暂且不提 region.setCitycode(PinYin4jUtils.hanziToPinyin(value3)); regions.add(region); &#125; String flag = \"1\"; try&#123; regionService.saveBatch(regions);//批处理保存到数据库中，如果抛异常返回标志字符串回前台，做出相应友好提示 &#125;catch(Exception e)&#123; flag = \"0\"; &#125; ServletActionContext.getResponse().setContentType(\"text/html;charset=UTF-8\"); ServletActionContext.getResponse().getWriter().print(flag); return NONE;//上传文件，不需要配视图 &#125; ｝ 那么在poi中，sheet、row、cell分别是什么呢？ sheet: xls中的工作表 row: xls中的行 cell: xls中的每一个数据 xls文件生成 在后台查询出数据list，封装进HSSFWorkbook对象生成xls文件,提供一个输出流，告知浏览器文件名和文件类型，在前台提供按钮或链接，指向此action，实现xls文件导出。 12345678910111213141516171819202122232425262728293031public String exportXls() throws IOException&#123; List&lt;Subarea&gt; list = subareaService.findAll(); HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(\"分区数据\"); HSSFRow headRow = sheet.createRow(0);//标题行 headRow.createCell(0).setCellValue(\"分区编号\"); headRow.createCell(1).setCellValue(\"省\"); headRow.createCell(2).setCellValue(\"市\"); headRow.createCell(3).setCellValue(\"区\"); headRow.createCell(4).setCellValue(\"信息\"); headRow.createCell(5).setCellValue(\"城市编码\"); if(list!=null &amp;&amp; list.size()&gt;0)&#123; for (Subarea subarea : list) &#123; HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum()+ 1); dataRow.createCell(0).setCellValue(subarea.getId()); dataRow.createCell(1).setCellValue(subarea.getRegion().getProvince()); dataRow.createCell(2).setCellValue(subarea.getRegion().getCity()); dataRow.createCell(3).setCellValue(subarea.getRegion().getDistrict()); dataRow.createCell(4).setCellValue(subarea.getRegion().getInfo()); dataRow.createCell(5).setCellValue(subarea.getRegion().getCitycode()); &#125; &#125; String filename = URLEncoder.encode(\"分区数据.xls\", \"UTF-8\"); ServletActionContext.getResponse().setContentType(ServletActionContext.getServletContext().getMimeType(filename));//完成文件下载不要忘了\"一个流，两个头\" ServletActionContext.getResponse().setHeader(\"content-disposition\", \"attachment;filename=\"+filename);//完成文件下载不要忘了\"一个流，两个头\" ServletOutputStream out = ServletActionContext.getResponse().getOutputStream(); workbook.write(out);//通过HSSFWorkbook的write方法，关联一个输出流 return NONE; &#125; pinyin4j主要利用PinYin4jUtils的相关方法进行汉字转拼音。","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":" EasyUI的datagrid组件实现分页","date":"2017-02-28T04:40:30.000Z","path":"2017/02/28/EasyUI的datagrid组件实现分页/","text":"本篇博客用于EasyUI的datagrid组件实现分页展示，后台为Struts2+Spring+Hibernate，利用DetachedCriteria对象进行简单的分页查询。 要点： datagrid组件的参数和响应格式 DetachedCriteria对象的条件查询 首先利用EasyUI渲染出datagrid数据表格 先在body中声明一个table 123&lt;div&gt; &lt;table id=\"grid\"&gt;&lt;/table&gt;&lt;/div&gt; 再去head中通过JQuery代码将table渲染为datagrid对象 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; $(function()&#123; $('#grid').datagrid( &#123; border : false, rownumbers : true, pageList: [10,20,30],//选择一页显示多少数据 pagination : true,//在DataGrid控件底部显示分页工具栏。 columns :[ [ &#123; field : 'name',//简单的测试字段 title : '姓名', width : 120, align : 'center' &#125;, &#123; field : 'telephone', title : '手机号', width : 120, align : 'center' &#125; ] ], url :\"$&#123;pageContext.request.contextPath&#125;/staffAction_pageQuery\", //提交的url地址 idField : 'id' &#125;); &#125;);&lt;/script&gt; 此时你的页面应该是(因为没有在后台提供数据，所以现在页面为空表格) 接下来我们来看下这个datagrid组件发送了什么请求数据 打开浏览器的F12调试，我用的是火狐浏览器，不同的浏览器调试工具页面不同。找到网络栏，我们重新刷新下网页，可以看到 该条post请求是向后台获取数据 点开可以查看到他的请求参数为page、rows ###tips注意：在datagrid的请求参数中，page为当前页码，rows为所要展示的数据条数，而在datagrid的响应参数中，必须有total和rows，返回来的响应参数中，total为通过该条件查询到的总记录数，而这里的rows为所有的记录内容，为一个List集合。 有了请求参数，我们就可以去后台编写了。接下来为后台代码。 后台采用的是Struts2+Spring+Hibernate，我们利用struts2的驱动获取页面请求的page和rows参数。 在StaffAction中，我们提供了page、rows字段以及他们的get、set方法。为了方便起见，我们将分页有关的数据封装成一个名称为PageBean的Class对象。 PageBean StaffAction的pageQuery方法 StaffServiceImpl StaffDao 相关介绍在代码截图中有注释。最后，通过dao查询出来的数据，经过service传到action，在action中通过Jsonlib将数据转成json格式，返回前台。 接下来我们就可以在前台显示出数据库里的数据了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]}]