[{"title":"移动端web开发常见问题总结","date":"2017-05-11T15:42:03.000Z","path":"2017/05/11/移动端web开发常见问题总结/","text":"常见问题1、移动端如何定义字体font-family三大手机系统的字体： ios 系统默认中文字体是Heiti SC默认英文字体是Helvetica默认数字字体是HelveticaNeue无微软雅黑字体 android 系统默认中文字体是Droidsansfallback默认英文和数字字体是Droid Sans无微软雅黑字体 winphone 系统默认中文字体是Dengxian(方正等线体)默认英文和数字字体是Segoe无微软雅黑字体 各个手机系统有自己的默认字体，且都不支持微软雅黑，如无特殊需求，手机端无需定义中文字体，使用系统默认英文字体和数字字体可使用 Helvetica ，三种系统都支持 移动端定义字体的代码 1body&#123;font-family:Helvetica;&#125; 2、移动端字体单位font-size选择px还是rem对于只需要适配手机设备，使用px即可 对于需要适配各种移动设备，使用rem，例如只需要适配iPhone和iPad等分辨率差别比较挺大的设备 rem配置参考：123456789101112131415161718192021222324252627282930313233343536html &#123;font-size:10px&#125;@media screen and (min-width:480px) and (max-width:639px) &#123; html &#123; font-size: 15px &#125;&#125;@media screen and (min-width:640px) and (max-width:719px) &#123; html &#123; font-size: 20px &#125;&#125;@media screen and (min-width:720px) and (max-width:749px) &#123; html &#123; font-size: 22.5px &#125;&#125;@media screen and (min-width:750px) and (max-width:799px) &#123; html &#123; font-size: 23.5px &#125;&#125;@media screen and (min-width:800px) and (max-width:959px) &#123; html &#123; font-size: 25px &#125;&#125;@media screen and (min-width:960px) and (max-width:1079px) &#123; html &#123; font-size: 30px &#125;&#125;@media screen and (min-width:1080px) &#123; html &#123; font-size: 32px &#125;&#125; 3、什么是Retina 显示屏，带来了什么问题retina：一种具备超高像素密度的液晶屏，同样大小的屏幕上显示的像素点由1个变为多个，如在同样带下的屏幕上，苹果设备的retina显示屏中，像素点1个变为4个在高清显示屏中的位图被放大，图片会变得模糊，因此移动端的视觉稿通常会设计为传统PC的2倍 那么，前端的应对方案是：设计稿切出来的图片长宽保证为偶数，并使用backgroud-size把图片缩小为原来的1/212//例如图片宽高为：200px*200px，那么写法如下.css&#123;width:100px;height:100px;background-size:100px 100px;&#125; 其它元素的取值为原来的1/2，例如视觉稿40px的字体，使用样式的写法为20px .css{font-size:20px} 4、viewport模板12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;&lt;title&gt;标题&lt;/title&gt;&lt;link rel=\"stylesheet\" href=\"index.css\"&gt;&lt;/head&gt;&lt;body&gt;这里开始内容&lt;/body&gt;&lt;/html&gt; sublime里使用meta:vp然后tab即可 5、优先使用最新版本 IE 和 Chrome1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt; 6. 添加到主屏后的标题（IOS）1&lt;meta name=\"apple-mobile-web-app-title\" content=\"标题\"&gt; 7. 启用 WebApp 全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）12&lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt; &lt;meta name=\"apple-touch-fullscreen\" content=\"yes\" /&gt; 8. 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：1&lt;meta http-equiv=\"Cache-Control\" content=\"no-siteapp\" /&gt; 9. 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在 “apple-mobile-web-app-capable” content=”yes” 时生效1&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\" /&gt; content 参数：default ：状态栏背景是白色。black ：状态栏背景是黑色。black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。 10. 移动端手机号码识别（IOS）在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：7位数字，形如：1234567带括号及加号的数字，形如：(+86)123456789双连接线的数字，形如：00-00-0011111位数字，形如：13800138000可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：1&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt; 开启电话功能1&lt;a href=\"tel:123456\"&gt;123456&lt;/a&gt; 开启短信功能：1&lt;a href=\"sms:123456\"&gt;123456&lt;/a&gt; 11. 移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别：1&lt;meta content=\"email=no\" name=\"format-detection\" /&gt; 同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：1&lt;a mailto:dooyoe@gmail.com\"&gt;dooyoe@gmail.com&lt;/a&gt; 12、ios系统中元素被触摸时产生的半透明灰色遮罩怎么去掉ios用户点击一个链接，会出现一个半透明灰色遮罩, 如果想要禁用，可设置-webkit-tap-highlight-color的alpha值为0，也就是属性值的最后一位设置为0就可以去除半透明灰色遮罩123a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0)&#125; 13、部分android系统中元素被点击时产生的边框怎么去掉android用户点击一个链接，会出现一个边框或者半透明灰色遮罩, 不同生产商定义出来额效果不一样，可设置-webkit-tap-highlight-color的alpha值为0去除部分机器自带的效果1234a,button,input,textarea&#123; -webkit-tap-highlight-color: rgba(0,0,0,0) -webkit-user-modify:read-write-plaintext-only; &#125; -webkit-user-modify有个副作用，就是输入法不再能够输入多个字符另外，有些机型去除不了，如小米2对于按钮类还有个办法，不使用a或者input标签，直接用div标签 14、winphone系统a、input标签被点击时产生的半透明灰色背景怎么去掉1&lt;meta name=\"msapplication-tap-highlight\" content=\"no\"&gt; 15、webkit表单元素的默认外观怎么重置1.css&#123;-webkit-appearance:none;&#125; 16、webkit表单输入框placeholder的颜色值能改变么12input::-webkit-input-placeholder&#123;color:#AAAAAA;&#125;input:focus::-webkit-input-placeholder&#123;color:#EEEEEE;&#125; 17、webkit表单输入框placeholder的文字能换行么ios可以，android不行~ 18、关闭iOS键盘首字母自动大写在iOS中，默认情况下键盘是开启首字母大写的功能的，如果启用这个功能，可以这样：1&lt;input type=\"text\" autocapitalize=\"off\" /&gt; 19、关闭iOS输入自动修正和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉：1&lt;input type=\"text\" autocorrect=\"off\" /&gt; 20、禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：123html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 meta viewport。 21、移动端如何清除输入框内阴影在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：12345input,textarea &#123; border: 0; -webkit-appearance: none; &#125; 22、屏幕旋转的事件和样式window.orientation，取值：正负90表示横屏模式、0和180表现为竖屏模式；1234567891011window.onorientationchange = function()&#123; switch(window.orientation)&#123; case -90: case 90: alert(\"横屏:\" + window.orientation); case 0: case 180: alert(\"竖屏:\" + window.orientation); break; &#125;&#125; 样式12345678//竖屏时使用的样式@media all and (orientation:portrait) &#123; .css&#123;&#125;&#125;//横屏时使用的样式@media all and (orientation:landscape) &#123; .css&#123;&#125;&#125; 23、audio元素和video元素在ios和andriod中无法自动播放应对方案：触屏即播123$('html').one('touchstart',function()&#123; audio.play()&#125;) 24、摇一摇功能HTML5 deviceMotion：封装了运动传感器数据的事件，可以获取手机运动状态下的运动加速度等数据。 25、手机拍照和上传图片1234567&lt;input type=\"file\"&gt;的accept 属性&lt;!-- 选择照片 --&gt;&lt;input type=file accept=\"image/*\"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept=\"video/*\"&gt; 使用总结：ios 有拍照、录像、选取本地图片功能部分android只有选取本地图片功能winphone不支持input控件默认外观丑陋 26、消除transition闪屏123456.css&#123; -webkit-transform-style: preserve-3d; -webkit-backface-visibility: hidden;&#125; 开启硬件加速解决页面闪白保证动画流畅123456.css &#123; -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0);&#125; 设计高性能CSS3动画的几个要素尽可能地使用合成属性transform和opacity来设计CSS3动画，不使用position的left和top来定位利用translate3D开启GPU加速 27、android 上去掉语音输入按钮123input::-webkit-input-speech-button &#123; display: none&#125; 28、模拟按钮hover效果移动端触摸按钮的效果，可明示用户有些事情正要发生，是一个比较好体验，但是移动设备中并没有鼠标指针，使用css的hover并不能满足我们的需求，还好国外有个激活css的active效果，代码如下，1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"utf-8\"&gt;&lt;meta content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no\" name=\"viewport\"&gt;&lt;meta content=\"yes\" name=\"apple-mobile-web-app-capable\"&gt;&lt;meta content=\"black\" name=\"apple-mobile-web-app-status-bar-style\"&gt;&lt;meta content=\"telephone=no\" name=\"format-detection\"&gt;&lt;meta content=\"email=no\" name=\"format-detection\"&gt;&lt;style type=\"text/css\"&gt;a&#123;-webkit-tap-highlight-color: rgba(0,0,0,0);&#125;.btn-blue&#123;display:block;height:42px;line-height:42px;text-align:center;border-radius:4px;font-size:18px;color:#FFFFFF;background-color: #4185F3;&#125;.btn-blue:active&#123;background-color: #357AE8;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"btn-blue\"&gt;按钮&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;document.addEventListener(\"touchstart\", function()&#123;&#125;, true)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 框架1、移动端基础框架zepto.js 语法与jquery几乎一样，会jquery基本会zepto~iscroll.js 解决页面不支持弹性滚动，不支持fixed引起的问题~ 实现下拉刷新，滑屏，缩放等功能~underscore.js 该库提供了一整套函数式编程的实用功能，但是没有扩展任何JavaScript内置对象。fastclick 加快移动端点击响应时间animate.css CSS3动画效果库Normalize.css Normalize.css是一种现代的、CSS reset为HTML5准备的优质替代方案 2、滑屏框架适合上下滑屏、左右滑屏等滑屏切换页面的效果slip.jsiSlider.jsfullpage.jsswiper 3、瀑布流框架masonry 工具推荐caniuse 各浏览器支持html5属性查询paletton 调色搭配","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"前端构建工具总结","date":"2017-05-11T01:43:58.000Z","path":"2017/05/11/前端构建工具总结/","text":"一、bower基于NodeJS的一个静态资源管理工具，由twitter公司开发维护，解决大型网站中静态资源的依赖问题。 准备工作 【依赖NodeJS环境和git工具】 安装node环境： node.js官网 安装npm下载npm源码包git clone --recursive git://github.com/isaacs/npm.gitcd 到 npm的代码文件夹下，使用以下命令安装node cli.js install npm -gf 安装Git，bower需要从远程git仓库获取代码包，所以依赖git环境：Git笔记 安装bower使用npm，打开终端，输入：npm install -g bower其中-g命令表示全局安装 如果未翻墙，可在最后加--registry=https://registry.npm.taobao.org使用淘宝镜像 bower命令 bower search 静态资源名 查找资源信息、版本 bower install 静态资源名[#版本] –save下载资源，通过#号可以指定版本号–save参数是保存配置到bower.json文件中 bower info 静态资源名查看资源信息比如我们想要查找jquery都有哪些个版本，输入如下命令：bower info jquery会看到jquery的bower.json的信息，和可用的版本信息 bower uninstall 静态资源名 卸载（删除）资源 bower init初始化（在windows下只能使用cmd来操作），用来记录资源信息及依赖。使用bash会报错bower init会初始化，同时在该目录生成bower.json文件用来保存该项目的配置 包的更新上面安装的是最新版的高版本jquery，假如想要兼容低版本浏览器的呢？已经查到兼容低版本浏览器的jquery版本为1.11.3，下面直接修改bower.json文件中的jquery版本号如下： 123\"dependencies\": &#123; \"jquery\": \"~1.11.3\"&#125; 然后执行如下命令： bower updatebower就会切换jquery的版本 版本号的一种定义规则叫做Semantic Versioning 版本格式：主版本号.次版本号.修订号，版本号递增规则如下： 主版本号：当你做了不兼容的 API 修改，次版本号：当你做了向下兼容的功能性新增，修订号：当你做了向下兼容的问题修正。先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸 对于模块版本号管理 *: 任意版本1.1.0: 指定版本，写死的~1.1.0: &gt;=1.1.0 &amp;&amp; &lt; 1.2.0^1.1.0: &gt;=1.1.0 &amp;&amp; &lt; 2.0.0 对与~和^ ~ 前缀表示，安装大于指定的这个版本，并且匹配到 x.y.z 中 z 最新的版本。^ 前缀在 ^0.y.z 时的表现和 ~0.y.z 是一样的，然而 ^1.y.z 的时候，就会 匹配到 y 和 z 都是最新的版本。特殊的是，当版本号为 ^0.0.z 或者 ~0.0.z 的时候，考虑到 0.0.z 是一个不稳定版本， 所以它们都相当于 =0.0.z 二、Gulp多个开发者共同开发一个项目，每位开发者负责不同的模块，这就会造成一个完整的项目实际上是由许多的“代码版段”组成的，不同的模块需要不同的处理插件，可以用gulp来进行管理 使用less、sass等一些预处理程序，降低CSS的维护成本，最终需要将这些预处理程序进行解析； 合并css、javascript，压缩html、css、javascript、images可以加速网页打开速度，提升性能； 这一系列的任务完全靠手动完成几乎是不可能的，借助构建工具可以轻松实现。所谓构建工具是指通过简单配置就可以帮我们实现合并、压缩、校验、预处理等一系列任务的软件工具。 常见的构建工具包括：Grunt、Gulp、F.I.S（百度出品）、webpack Gulp安装全局安装 npm install -g gulp 【为了在命令行可以使用gulp命令】 Gulp基础 npm init 初始化 会自动生成package.json来记录npm依赖关系 本地安装gulp 【具体的某个任务目录来具体安装】进入项目根目录执行npm install gulp –save-dev（添加–save-dev会在package.json记录依赖关系）。Tips:安装的模块会保存在node_modules文件夹里。如果不小心删除了该文件夹，只要package.json文件在，就可以根据其记录的依赖利用npm install来下载所有package.json文件里记录的module 任务清单在项目根目录中创建gulpfile.js（这是一个配置文件）【名称固定死的】 定义任务在gulpfile.js定义构建任务，如压缩、合并，Gulp自身并不执行任何任务，是通过调用具体插件来完成的。以编译LESS为例，安装npm install gulp-less，如下图定义任务 执行任务输入命令 gulp less 【用全局的gulp命令来执行当前目录下的less任务】这样我们的LESS文件便会编译成CSS了。 Gulp工作原理通过不同的插件实现构建任务，Gulp只是按着配置文件调用执行了这些插件。 Gulp APIGulp是基于NodeJS的，通过require可以引入一个NodeJS的包（模块），其作用类似于浏览器中的script标签引入资源，被引入的包存放在node_modules目录下。 引入gulp包（模块）后返回一个对象，习惯赋值给变量gulp，通过该对象提供的方法（API）完成任务的配置。 gulp.task() 定义各种不同的任务，如下图有两个参数不同任务间存在依赖关系时，可以指定依赖，如下图 gulp.src() 需要构建资源的路径，字符串或数组（可以填正则表达式） gulp.pipe() 管道，将需要构建的资源“输送”给插件。 gulp.dest() 构建任务完成后资源存放的路径（会自动创建） gulp.watch() 常用Gulp插件gulp-less 编译LESS文件gulp-autoprefixer 添加CSS私有前缀gulp-cssmin 压缩CSSgulp-rname重命名gulp-imagemin 图片压缩gulp-uglify 压缩Javascriptgulp-concat 合并gulp-htmlmin 压缩HTMLgulp-rev 添加版本号【把静态文件内容字符串md5加密，文件有改动，md5串就会变化，截取一部分md5串给文件名命名，让修改过后的静态文件不会因为浏览器缓存而读取不了base.css -&gt; base-e972672397.css】gulp-rev-collector 内容替换【因为静态资源名改变了，html里引入的名也得改变】gulp-userefgulp-ifGulp-autoprefix Gulp常见使用实例准备工作 在工作路径新建gulpfile.js 文件用来定义Gulp的任务 使用Gulp的插件需要先在工作路径安装插件npm install gulp-插件名插件会安装在node_modules 文件夹中 在gulpfile.js 文件头部引入下载好的需要使用的gulp插件变量名可以自己定义，后面的gulp.task中填该变量名即可 定义任务 编译less成css并压缩,添加私有化前缀、css文件添加rev版本号并利用gulp-rev-collector来将html中引用的css文件名替换成rev模式 压缩图片 压缩JavaScript 简单合并文件，只能合并，不能修改引用路径 压缩html Css自动加上私有化前缀 合并页面中的Js或者Css文件并修改html中的引用名需要先在html文件中添加注释来注明需要合并和修改html中的引用名的文件以JavaScript为例gulpfile.json Gulp构建任务流程实例开发完毕的工作路径构建目标： 构建完毕的目录在当前的release目录，上线时直接用构建完毕的release目录即可 处理css：less转css、压缩、加私有化前缀、rev缓存名修改、html引用名修改 处理图片：压缩、rev缓存名修改、html引用名修改 处理js：html里引用的多个js合并，减少客户端请求次数、压缩js、rev缓存名修改、html引用名修改 将api、public下的公共静态资源不需要修改的直接gulp-copy到release文件夹中 开始构建 一、创建release分支先git创建release分支，在release分支上进行构建测试git checkout -b release 二、创建Gulp初始环境npm init创建完毕后工作目录会出现package.json，该文件记录所有安装Gulp插件记录及其依赖 三、安装各种需要的Gulp插件 [最好在cmd运行命令，能看到进度条,bash看不了进度条]PS：第一个先安装Gulpnpm install gulp --save-devnpm install gulp-less --save-devnpm install gulp-cssmin --save-devnpm install gulp-autoprefixer --save-devnpm install gulp-rev --save-devnpm install gulp-imagemin --save-devnpm install gulp-useref --save-devnpm install gulp-if --save-devnpm install gulp-uglify --save-devnpm install gulp-rename --save-devnpm install gulp-rev-collector --save-dev安装完毕后，package.json文件中也会记录下这些插件的安装记录及其依赖 四、创建任务清单文件 工作根路径touch gulpfile.js 五、编写任务清单[注：以下提到的rev名即为通过gulp-rev插件后改的md5文件名] 5.1 引入、声明gulp插件 5.2 处理css因为页面引用路径是在less下的，所以我们要注释配置下，改到(合并)css下 5.3 处理图片 5.4 处理js 先对待修改的html页面进行注释配置 在编写task 5.5 其他资源存到release里 5.6 给所有之前rev改名后的文件一起修改其在html中的引用路径名 在这个task任务中，由于依赖了其他模块，即等’css’,’image’,’js’任务完成完毕后再执行改引用名操作，但是由于gulp处理task是异步的，经常会导致依赖的任务还没完成就改名完毕了，这是不合理的，所以在所有他依赖的task任务中，给function 加上返回值，即在他依赖的task任务gulp.src(‘…’)前加上return 5.7 添加默认任务 填写完毕就可以在项目根目录(gulpfile.js文件目录)执行gulp命令了。gulp 任务名由于我们指定了default任务，所以可以直接 gulp 启动任务 激动人心，终于完成了任务的构建 完成了以后，可以直接使用release文件夹里的构建完毕的内容上线 六、 git分支合并、提交 由于使用了gulp和bower安装了大量的类库、插件，同时gulp的配置文件也不需要上传，所以需要编写.gitignore文件后再完成git分支合并、提交。 touch .gitignore 填写完毕后 进行git分支合并、提交 在我们进行release开发的release分支下 git status git add -A git commit -m &#39;完成了项目构建&#39; git checkout developer git merge release git branch -d release git push origin developer","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Content-Type决定服务端数据提取方式","date":"2017-05-07T03:16:40.000Z","path":"2017/05/07/Content-Type决定服务端数据提取方式/","text":"HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。协议规定 POST 提交的数据必须放在消息主体（entity-body）中,而消息主体的格式可以自行定义。而服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。 1. application/x-www-form-urlencoded【formData】传递的数据是’key=val&amp;key=val’形式，这种形式叫formData这是最常见的 POST 提交数据的方式。浏览器的原生 form 表单，如果不设置 enctype 属性，默认以 application/x-www-form-urlencoded 方式提交数据。请求类似于123POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。 jQuery的Ajax，Content-Type默认值是application/x-www-form-urlencoded;charset=utf-8 2. multipart/form-data使用表单上传文件时，必须设定form的enctype为该值 123456789101112131415POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA--content-ty 生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 mutipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 3. application/json【Request Payload】现在该请求头越来越流行，直接传json对象，该请求头用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数。 Json 格式支持比键值对复杂得多的结构化数据，当然也可以把数据先 JSON 序列化之后，然后再将序列化后的字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。这样传输的文本节省流量，服务器接收了可以后台解析。 在AngularJS 中的$http服务，默认提交的数据格式就是 JSON 字符串。 最终发送的请求是： POST http://localhost:8000/exmple.php HTTP/1.1Content-Type: application/json;charset=utf-8 这种方案，可以方便的提交复杂的结构化数据，很适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但是这种方式有些服务器语言接收不是很方便，比如Java需要request.getReader();得到BufferedReader，然后再读取流存入String，利用jackson、json-lib等进行解析成jsonObject对象读取数据。php 也无法通过 $_POST对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。 解决方式：服务端接收的是一个Json对象的字符串而不是直接的Json对象，可以在传输数据时选择JSON.stringify(jsonData);先将json对象转成字符串，指定dataType:”json”,contentType:”application/json” ,如果是springmvc后台可以直接 public void saveUser(@RequestBody List&lt;User&gt; users) { userService.batchSave(users); } 来绑定对象或者List 当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。 ###注意：json一般更多用来返回数据而不是在提交数据的时候使用，通常Restful服务都会支持json/xml格式的返回数据。 对于application/x-www-form-urlencoded和application/json;charset=utf-8的选择 如果数据是简单、平面的key-value数值对，那么使用www-form-urlencoded简单实用，后台直接根据key取值，不需要额外的编解码； 如果数据是复杂的嵌套关系，有多层数据，那么使用json会简化数据的处理，从而更高效。 总结： 一般发送数据给服务端用application/x-www-form-urlencoded,方便服务端读取接收，但是如果是结构复杂或者数组对象，那就选择application/json,再传JSON.stringify后的json对象字符串，类似于springmvc后台对json有很好支持的可以直接@RequestBody绑定对象或者List，如果后台对Json数据读取支持不好，可以选择用application/x-www-form-urlencoded，再将stringify后的json字符串对象作为val存入键值对，后台可以很方便的根据key得到json字符串再解析。不建议直接传未序列化过的json对象，这样后台还得从request里去获取原始输入流，转成String后再转成JsonObject对象再读取，效率太低。 服务端返回数据使用application/json ，便于前台解析展示。 误区解释： 之前JQuery发送Ajax的application/x-www-form-urlencoded请求，用的都是data:json格式来传递数据，其实这是JQuery的一个封装，为了我们书写方便阅读性强。虽然我们给的是json格式，可是他底层将其遍历解析转换成了key=val&amp;key=val的格式来传递 4. text/plain数据以纯文本形式进行编码，其中不含任何控件或格式字符。一般通过request.InputStream或者request.getReader，从流中提取出数据 5. text/xml它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。不过个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 和键值对会更灵活方便。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"AngularJS学习","date":"2017-05-07T03:16:02.000Z","path":"2017/05/07/AngularJS学习/","text":"一、特点&emsp;&emsp;AngularJS与jQuery是有一定的区别的，jQuery更准确来说只一个类库（类库指的是一系列函数的集合）以DOM做为驱动（核心），而AngularJS则一个框架（诸多类库的集合）以数据和逻辑做为驱动（核心）。框架对开发的流程和模式做了约束，开发者遵照约束进行开发，更注重的实际的业务逻辑。AngularJS有着诸多特性，最为核心的是：模块化、双向数据绑定、语义化标签、依赖注入等。与之类似的框架还有BackBone、KnockoutJS、Vue、React等。 二、模块化 控制器、模型 页面视图 三、指令&emsp;&emsp;传统的HTML书写页面(应用)存在诸多不足之处，比如没有循环、if判断、switch等结构，之前一般会使用JSP的jstl标签库或者导入页面模版js来强化html结构。AngularJS也可以通过扩展一系列的HTML属性或标签来弥补这些缺陷，所谓指令就是AngularJS自定义的HTML属性或标签，这些指令都是以ng-做为前缀的，例如ng-app、ng-controller、ng-repeat等。 3.1 内置指令为AngularJS定义好的指令，可以直接使用，这里整理了部分常用内置指令 ng-app 指定应用根元素，至少有一个元素指定了此属性。 ng-controller 指定控制器 ng-show控制元素是否显示，true显示、false不显示 ng-hide控制元素是否隐藏，true隐藏、false不隐藏 ng-if控制元素是否“存在”，true存在、false不存在 ng-src增强图片路径 防止加载dom结构时未加载到Angular不识别&#123;&#123;&#125;&#125;导致不好看 ng-href增强地址 同上 ng-class控制类名 ‘{类名 : true / false}’ 来控制该class样式是否使用 ng-include引入模板 就是相当于 jsp:include标签，直接引用一个页面 ng-disabled ‘true/false’ 表单禁用 ng-readonly ‘true/false’ 表单只读 ng-checked ‘true/false’ 单/复选框表单选中 ng-selected ‘true/false’ 下拉框表单选中 注意：① ng-src、ng-href 等都是对该原标签的加强。因为先加载dom结构，此时AngularJS还未加载，不识别&#123;&#123;&#125;&#125;里的元素，导致src和href之类无法加载，图片会出现未加载的样式，很丑。所以使用ng-src等，在加载dom结构时因为不识别ng-src和ng-href之类，就不会去服务器加载该路径文件，等到AngularJS加载完毕后，他底层会把ng-src里的内容解析成真正的内容同时给该标签添加一个html识别的src属性填充进去，然后再次渲染。 ② ng-include 直接浏览器运行会报错，因为js不能加载本地文件！只有后端语言才可以读取本地文件1XMLHttpRequest cannot load file:///C:/Users/Administrator/Desktop/SublimeWorkSpace/AngularJS/header.html. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https 但是放在服务器环境运行，可以完成导入页面。因为ng-include的原理就是ajax异步请求页面资源，服务器返回html文件，再拼装 要和iframe区分开，iframe独立成页，单独执行；而ng-include是服务器将两个页面合并成一个页面解释后发送到客户端,对于浏览器来说他见到的就是一个页面而已，所以类include指令都要加载本地文件! ③ ng-class还可以写表达式，如ng-class=”{active:type===’M’}”，当model的type为M的时候为true，active的样式就显示 3.2 自定义指令AngularJS允许根据实际业务需要自定义指令，通过angular全局对象下的directive方法实现。 四、数据绑定&emsp;&emsp;AngularJS是以数据做为驱动的MVC框架，所有模型（Model）里的数据经由控制器（Controller）展示到视图（View）中。所谓数据绑定指的就是将模型（Model）中的数据与相应的视图（View）进行关联，分为单向绑定和双向绑定两种方式。 4.1 单向绑定&emsp;&emsp;单向数据绑定是指将模型（Model）数据，按着写好的视图（View）模板生成HTML标签，然后追加到DOM中显示，如之前所学的artTemplate 模板引擎和JSP页面的工作方式，只能模型（Model）数据向视图（View）传递。 4.2 双向绑定&emsp;&emsp;双向绑定则可以实现模型（Model）数据和视图（View）模板的双向传递，模型数据的改变会使视图的数据也改变，视图数据的改变也会让模型数据改变。 4.3 相关指令1.数据绑定指令 模型（Model）数据向视图模板（View）的绑定&#123;&#123; &#125;&#125;ng-bind指令 模型数据通过一个内置服务$scope来提供，这个$scope是一个空对象，通过为这个对象添加属性或者方法便可以在相应的视图（View）模板里被访问。 注：“&#123;&#123;&#125;&#125;”是ng-bind的简写形式，其区别在于通过“&#123;&#123;&#125;&#125;”绑定数据时会有“闪烁”现象，添加ng-cloak也可以解决“闪烁”现象，通过ng-bind-template可以绑定多个数据。 表单元素添加ng-model指令视图（View）模板向模型（Model）数据的绑定。 1&lt;input type=\"text\" ng-model=\"name\"&gt; ng-init 为控制器初始化一个模型,注意格式为key=val;key=val2.事件绑定指令对于js中大部分事件进行了增强，只需要再前部加上ng-即可，这些事件也可以传参，如 1ng-click=\"check('M')\" 3.ng-repeat、ng-switch 理解：与传统的switch when比较12345switch () -这里是ng-switch on case '': -这里是when ... case '': ... 五、作用域5.1 根作用域ng-app指令的标签内就是根作用域，ng-app上的模型全局都能访问到 5.2 子作用域通过ng-controller指令可以创建一个子作用域，新建的作用域可以访问其父作用域的数据访问规则同JavaScript等，父作用域不能访问子作用域内容，子作用域可以访问父作用域内容，如果子作用域有数据优先使用自己的，没有就去父级查找 六、过滤器AngularJS中使用过滤器格式化展示数据，在“&#123;&#123;&#125;&#125;”中使用“|”来调用过滤器，使用“:”传递参数。 6.1 内置过滤器 1、currency将数值格式化为货币格式 ： ￥ 2、date日期格式化，年（y）、月（M）、日（d）、星期（EEEE/EEE）、时（H/h）、分（m）、秒（s）、毫秒（.sss），也可以组合到一起使用。 3、filter在给定数组中选择满足条件的一个子集，并返回一个新数组，其条件可以是一个字符串、对象、函数,如果是对象要和最后的｝加一个空格间隔 4、json将Javascrip对象转成JSON字符串。 5、limitTo取出字符串或数组的前（正数）几位或后（负数）几位 : 位数 6、lowercase将文本转换成小写格式 7、uppercase将文本转换成大写格式 8、number数字格式化，可控制小位位数 : 位数 9、orderBy对数组进行排序 ： 排序字段 true/false 6.2 自定义过滤器除了使用AngularJS内建过滤器外，还可以根据业务需要自定义过滤器，通过模块对象实例提供的filter方法自定义过滤器。 七、依赖注入依赖注入是指在运行时自动查找依赖关系，然后将查找到依赖传递给使用者的一种机制。常见的AngularJS内置服务有$http、$location、$timeout、$rootScope等 7.1 推断式注入没有明确声明依赖，AngularJS会将函数参数名称当成是依赖的名称。这种方式会带来一个问题，当代码经过压缩后函数的参数被压缩，这样便会造成依赖无法找到。 7.2 行内注入以数组形式明确声明依赖，数组元素都是包含依赖名称的字符串，数组最后一个元素是依赖注入的目标函数。 推荐使用这种方式声明依赖 八、服务服务是一个对象或函数，对外提供特定的功能。 8.1 内置服务1、$location是对原生Javascript中location对象属性和方法的封装。2、$timeout&amp;$interval对原生Javascript中的setTimeout和setInterval进行了封装。3、$filter格式化数据。4、$log打印调试信息5、$http用于向服务端发起异步请求。 AngularJS不设置的话默认Content-Type为application/json;charset=utf-8，为了方便的提交复杂的结构化数据，特别适合 RESTful 的接口 get方式请求post方式请求 注意：1.get方式用params传递数据,post方式用data传递数据。 2.post方式需要声明headers的content-type为application/x-www-form-urlencoded，即经过编码为key=val&amp;key=val的格式 3.application/x-www-form-urlencoded即告诉服务器，传递数据格式为key=val&amp;key=val，所以在AngularJS中post传递数据用的data值不能为json对象格式，而应该为key=val的字符串 4.为什么post时data值需要用字符串呢？因为get请求默认content-type就是application/x-www-form-urlencoded，他将key=val&amp;key=val拼接在了url后 而post请求默认是text/plain格式，如果需要传数据要手动转成application/x-www-form-urlencoded，他将key=val&amp;key=val拼接在了请求体里即Form data里 在这里有一个误区，之前JQuery发送Ajax的application/x-www-form-urlencoded请求，用的都是data:json格式来传递数据，其实这是JQuery的一个封装，为了我们书写方便阅读性强。虽然我们给的是json格式，可是他底层将其遍历解析转换成了key=val&amp;key=val的格式来传递，而AngularJS默认传json数据，不提供这种转换，他会直接把json数据当成key，val值为空传递，导致服务端报错，所以我们还是直接写key=val字符串直接传，省去转换的麻烦了吧 $http服务同时还支持多种快捷方式如$http.get()、$http.post()、$http.jsonp 6、$http的jsonp传输 需要指定method为jsonp，同时，在params里定义{ callback: ‘JSON_CALLBACK’ }。对于callback的定义可以在params里，也可以在请求的url后callback可以任意命名，但是后面的JSON_CALLBACK不可以改变。这个名称在AngularJS发出请求时，会自动将JSON_CALLBACK替换成一个唯一的函数名，比如：“callback=angular.callbacks._0”，这个可以通过浏览器debug模式查看. 返回数据必须放在JSON_CALLBACK (json数据)里面。注意：JSON_CALLBACK 必须是angularjs把你的JSON_CALLBACK 替换后的值，如：angular.callbacks._0，假设你请求到后台，你可以先获取到callback这个参数的值，然后把组装你要返回的json数据。eg: 假设是SpringMVCString callback = request.getParameter(“callback”);JSONObject json =new JSONObject();json.put(“id”, “123456”);json.put(“username”, “hhaip”);json.put(“age”, 25);json.put(“sex”, “男”);return callback+”(“+json+”)”; 8.1 自定义服务通过上面例子得知，所谓服务是将一些通用性的功能逻辑进行封装方便使用，AngularJS允许将自定义服务,有factory、service、value方法来自定义服务。 factory方法举例：使用： service方法举例：（ng-app省略了） value方法定义常量 服务本质就是一个对象或函数，所以自定义服务就是要返回一个对象或函数以供使用。 九、模块加载AngularJS模块可以在被加载和执行之前对其自身进行配置。我们可以在应用的加载阶段配置不同的逻辑。 9.1 配置块通过config方法实现对模块的配置，AngularJS中的服务大部分都对应一个“provider”，用来执行与对应服务相同的功能或对其进行配置。比如$log、$http、$location都是内置服务，相对应的“provider”分别是$logProvider、$httpProvider、$locationPorvider。下图以$log为例进行演示，通过其$logProvider修改了$log服务的配置下图以$ngRoute为例进行演示，通过其$routeProvider对路由进行了配置 9.1 运行块服务也是模块形式存在的对且对外提供特定功能，前面学习中都是将服务做为依赖注入进去的，然后再进行调用，除了这种方式外我们也可以直接运行相应的服务模块，AngularJS提供了run方法来实现。【就像eclipse中的run application】 【不但如此，run方法还是最先执行的，利用这个特点我们可以将一些需要优先执行的功能通过run方法来运行，比如验证用户是否登录，未登录则不允许进行任何其它操作。】运行块App.run多运用在AngularJS构建的应用中的加载机制，由于是最先执行的，相当于程序的入口，在该方法中进行一些http请求和$rootScope 等的初始化。 十、路由一个应用是由若个视图组合而成的，根据不同的业务逻辑展示给用户不同的视图，路由则是实现这一功能的关键。 10.1 SPASPA（Single Page Application）指的是通单一页面展示所有功能，通过Ajax动态获取数据然后进行实时渲染，结合CSS3动画模仿原生App交互，然后再进行打包（使用工具把Web应用包一个壳，这个壳本质上是浏览器）变成一个“原生”应用。在PC端也有广泛的应用，通常情况下使用Ajax异步请求数据，然后实现内容局部刷新，局部刷新的本质是动态生成DOM，新生成的DOM元素并没有真实存在于文档中，所以当再次刷新页面时新添加的DOM元素会“丢失”，通过单页面应可以很好的解决这个问题。 10.2 路由在后端开发中通过URL地址可以实现对用户请求的处理，导致页面（视图）的切换，但是AngularJS是一个纯前端MVC框架，在开发单页面应用时，所有功能都在同一页面完成，所以无需切换URL地址（即不允许产生跳转），但Web应用中又经常通过链接（a标签）来更新页面（视图），当点击链接时还要阻止其向服务器发起请求，通过锚点（页内跳转）可以实现这一点。实现单页面应用需要具备：a、只有一页面b、链接使用锚点页面：(a链接使用锚点)JavaScript：通过上面的例子发现在单一页面中可以能过hashchange事件监听到锚点的变化，进而可以实现为不同的锚点准不同的视图，单页面应用就是基于这一原理实现的。AngularJS对这一实现原理进行了封装，将锚点的变化封装成路由（Route）,这是与后端路由的根本区别。在1.2版前路由功能是包含在AngularJS核心代码当中，之后的版本将路由功能独立成一个模块，需要下载导入angular-route.js 10.2.1 使用1、引入angular-route.js2、实例化模块（App）时，当成依赖传进去（模块名称叫ngRoute）。3、配置路由模块4、布局模板通过ng-view指令布局模板，路由匹配的视图会被加载渲染到些区域。 10.2.1 路由参数 提供两个方法匹配路由，分别是when和otherwise，when方法需要两个参数，otherwise方法做为when方法的补充只需要一个参数，其中when方法可以被多次调用。设置:id和:type来匹配url里的路由参数路由里可以传参数$routeParams 服务可以获取路由参数，$routeParams存的就是json对象，可以直接使用他效果展示： 十一、jQuery Lite11.1. 介绍AngularJS强化了前端的MVC逻辑，却弱化了Jquery的Dom操作能力。好在Angular自身也考虑到这个问题，所以它自身内置了jqLite来弥补这方面的不足。 为了项目的精简性，使用了ng有时候不想再引入jq，在没有引入jQuery的前提下AngularJS实现了简版的jQuery Lite，通过angular.element不能选择元素，但可以将一个DOM元素转成jQuery对象，如果引提前引入了jQuery则angular.element则完全等于jQuery。 一般使用angular.element将原生dom对象转成jq对象，可以调用AngularJS实现的部分jq方法。 11.2. 使用 angular.element() 参数要求是HTML string or DOMElement, angular.element 虽然很接近 jQuery，但是直接通过 HTML tag 去获取元素还是不行的，最简单的办法是这样：12var $p = angular.element(document.querySelectorAll('p'));var $box = angular.element(document.querySelector('.box')); 注：querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果需要返回所有的元素，可以使用 querySelectorAll() 方法。 11.2.3 jqlite只实现了以下的jQuery方法 addClass() after() append() attr() - 不支持函数作为参数 bind() - 不支持命名空间，选择器或事件数据 children() - 不支持选择器 clone() contents() css() -只有将内联样式，不叫getcomputedstyle() data() detach() empty() eq() find() - 通过标签名称限定查找 hasClass() html() next() - 不支持选择器 on() - 不支持命名空间，选择器或事件数据 off() - 不支持命名空间或选择器 one() - 不支持命名空间或选择器 parent() - 不支持选择器 prepend() prop() ready() remove() removeAttr() removeClass() removeData() replaceWith() text() toggleClass() triggerHandler() - 通过一个虚拟事件对象来处理。 unbind() - 不支持命名空间 val() wrap()","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"AngularJS","slug":"AngularJS","permalink":"http://yoursite.com/tags/AngularJS/"}]},{"title":"Git笔记","date":"2017-05-02T16:17:43.000Z","path":"2017/05/03/Git笔记/","text":"零、Git命令汇总 git config配置本地仓库 常用git config –global user.name、git config –global user.email git config –list查看配置详情 git init 初始一个仓库，添加–bare可以初始化一个共享（裸）仓库 git status 可以查看当前仓库的状态 git add“文件” 将工作区中的文件添加到暂存区中，其中file可是一个单独的文件，也可以是一个目录、“*”、-A git commit -m ‘备注信息’ 将暂存区的文件，提交到本地仓库 git log 可以查看本地仓库的提交历史 git branch查看分支 git branch“分支名称” 创建一个新的分支 git checkout“分支名称” 切换分支 git checkout -b deeveloper 创建并切到developer分支(加了-b就先创建再切换) git merge“分支名称” 合并分支 git branch -d “分支名称” 删除分支 git clone “仓库地址”获取已有仓库的副本 git push origin “本地分支名称:远程分支名称”将本地分支推送至远程仓库， git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix git push origin hotfix:newfeature 本地仓库分支名称和远程仓库分支名称一样的情况下可以简写成一个，即git push “仓库地址” “分支名称”，如果远程仓库没有对应分支，将会自动创建 git remote add “主机名称” “远程仓库地址”添加远程主机，即给远程主机起个别名，方便使用 git remote 可以查看已添加的远程主机 git remote show “主机名称”可以查看远程主机的信息 一、Bash常见指令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory) 切换目录，如 cd /etc ls (List) 查看当前目录下内容，如 ls -al mkdir (Make Directory) 创建目录，如 mkdir blog touch 创建文件，如 touch index.html cat 查看文件全部内容，如 cat index.html more/less 查看文件，如more /etc/passwd、less /etc/passwd rm (remove) 删除文件，如 rm index.html、rm -rf blog rmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用 mv (move) 移动文件或重命名，如 mv index.html ./demo/index.html cp (copy) 复制文件，cp index.html ./demo/index.html head 查看文件前几行，如 head -5 index.html tail 查看文件后几行 –n –f，如 tail index.html、tail -f -n 5 index.html tab 自动补全，连按两次会将所有匹配内容显示出来 history 查看操作历史 “&gt;” 和 “&gt;&gt;” 重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加 wget 下载，如wget https://nodejs.org/dist/v4.4.0/node-v4.4.0.tar.gz tar 压缩命令，x:解压 c:创建压缩包 z: gzip j：bzip2 v:view f:file后接文件名 -C:指定路径 eg:tar -czvf 文件名.tar.gz 目录 //创建一个文件在该目录 tar -czvf code.tar.gz ./ tar -xzvf 文件名.tar.gz -C 路径 //解压到那个路径 tar -xzvf code.tar.gz -C ./code curl 网络请求，如curl http://www.baidu.com whoami 查看当前用户 | 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。 grep 匹配内容，一般结合管道符使用 二、SSHSSH是一种网络协议，用于计算机之间的加密登录。 12格式：ssh user@host user 代表真实存在的用户host代表要登录的远程计算机ip地址 常见有两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者(非对称性加密)。 对称加密算法在加密和解密时使用的是同一个密钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。 工作原理公钥和私钥是成对出现，可以通过ssh-keygen -t rsa -C ‘your@mail.com’来创建，既可以通过密钥来加密数据，也可以通过私钥来加密数据，如果是以公钥进行的数据加密，只能与之相对应的私钥才可以解密，相反如果以私钥进行的数据加密，则只能与之对应的公钥才可以将数据进行解密，这样就可以提高信息传递的安全性。 免密码登录我们可以将本地机器上的公钥保存到特定的远程计算机上，这样当我们再次登录访问这台远程计算机时就可以实现免密码登录了。 1、ssh-keygen -t rsa会创建公钥和密钥（默认在用户目录/.ssh目录下） 2、ssh-copy-id user@host添加到对应远程主机的用户目录/.ssh目录下 3、也可以登录远程主机，进入到用户目录/.ssh目录下手动创建authorized_keys文件，并将自已的公钥粘入该文件。 GitHub、GitLab多个SSH key共存1. 新建GitHub的SSH key：12345678$ cd ~/.ssh # 切换到C:\\Users\\Administrator\\.sshssh-keygen -t rsa -C \"your@email.com\" # 新建工作的SSH key# 设置名称为id_rsa_github(这一步是给rsa文件命名的)Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_github 2. 新建GitLab的SSH key：12345678$ cd ~/.ssh # 切换到C:\\Users\\Administrator\\.ssh ssh-keygen -t rsa -C \"your@email.com\" # 新建工作的SSH key # 设置名称为id_rsa_gitlab(这一步是给rsa文件命名的) Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): id_rsa_gitlab 这样在C:\\Users\\Administrator\\.ssh目录下就有github和gitlab的公钥私钥了 但是这样github和gitlab是不能识别的，进行ssh登录都会报错，需要新建一个config文件来配置(直接touch config)不需要后缀名 1234567891011121314151617181920# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitlab# githubHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github 这样就可以区分各自的SSHkey了。 接下来就是去github和gitlab的settings里将自己的公钥(id_rsa_gitXX.pub)添加即可 [pub结尾的是公钥，没有pub结尾的是私钥，配置只需要粘贴公钥即可] 三、Git1. 文件管理Git管理我们文件的3种状态 已提交（committed）—- Git仓库 已修改（modified）—- 工作目录 已暂存（staged）—- 暂存区域 这些都是在我们本地电脑的 2. Git基础2.1 配置用户12345678git config --global user.name \"自已的名字\"git config --global user.email \"自已的邮箱地址\"--global 配置当前用户所有仓库--system 配置当前计算机上所有用户的所有仓库 注：配置用户只需要执行1次 2.2 初始化仓库 注：后面提到的”路径”，均为 用户名@ip地址:该电脑上仓库路径 a) git init 初始化仓库后，会有.git的隐藏文件夹，windows需要开启显示隐藏文件才可以看到，bash命令行需要ls -a才可以看到。 b) git clone 路径 保存目录 (如果不写保存目录，默认以项目名为目录保存项目) 假如公司已有项目用了Git，那我们就利用克隆 Tips: git clone 命令相当于 git init + git push 路径 master + git remote add origin 路径 即先在本地初始化一个仓库有，再将远程的master分支push下来，再添加一个远程的简称origin，方便操作 2.3 查看文件状态 git status 初始化仓库后可以通过git status可以检测当前仓库文件的状态 【Untracked files】为未’跟踪’的文件，即未git add添加到暂存区的文件 2.4 添加文件到暂存区 git add 文件名/ 文件路径 “*”或-A代表所有 只有先添加进暂存区才能commit 2.5 撤销更改 git checkout 文件名 【modified】为被修改文件，并被标记了红色 如果发现某个文件有Bug，想要回到之前状态，可以使用git checkout 文件名。 12git checkout index.html 注：从暂存区还原原到工作区 2.6 提交文件 git commit -m ‘备注信息’ \u0003 2.7 查看提交历史 git log \u0006红框部分为该次提交的id，为SHA值，唯一，可通过该id唯一标识一次提交记录，同时可以通过该id来回滚 2.8 返回某次提交状态 git reset –hard 172f147d3 （可以只粘贴部分SHA值） 三、Git分支所有的提交（commit）实际上都是在分支（branch）的基础上进行的。 当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个master的分支，并且有指针（HEAD）指到了末端。 (箭头由新记录指向老记录) 指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。 我们也可以创建自已的分支 3.1 创建分支 git branch hotfix 新的分支会在当前分支原有历史版本的结点上进行创建，为子分支,新建的子分支会继承父分支的所有提交历史。 3.2 切换分支 git checkout hotfix HEAD现在又指向了hotfix的末端 3.3 再次提交 会在hotfix分支进行提交，这次的提交历史版本就会记录在hotfix这个分支上了，并且HEAD伴随hotfix在移动 3.4 切换回master分支 当我们切换回master后，HEAD指向了master分支的末端。hotfix的修改是与master隔离的(不会影响到父分支) 3.5 master继续开发原先内容再次提交 会发现master分支又有了新的提交记录，与hotfix无关 总结：1. 当我们git checkout branchname时，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。 子分支会继承父分支之前的所有提交历史 分支之间相互隔离 3.6 合并分支 git merge 欲合并分支名 这时master会有两个父结点了，master便包含了hotfix里的修复了 3.7 删除分支 git branch -d hotfix 这时用来修复BUG创建的hotfix分支已经没有用处了，我们可以将它删除。 删除分支时，如果那条分支没有合并记录，会有丢失代码的危险，所以git一般不会允许我们删除未merge的分支，会报错，可以先merge该分支再删除，也可以直接git branch -D 分支名 强行删除 四、Git远程（共享）仓库由于git是分布式的版本控制软件，可以有一个远程仓库来进行仓库共享 如何创建一个远程共享仓库呢 4.1 在远程计算机创建裸仓库裸仓库要求， 以.git结尾的目录 仓库是一个空的仓库，并且不允在这个仓库中进行任何修改 123456mkdir repo.git 创建以.git结尾目录cd repo.git 进入这个目录git init --bare 初始化一个共享仓库，也叫裸仓库 注意选项--bare 注意！文件夹名字就是xxx.git,要有.git结尾 4.2 向共享仓库共享（同步）内容将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。 1234cd xxx.git //进入该目录git push 路径 分支名 4.3 向共享仓库取内容 git pull 路径 分支名 4.4 远程相关指令 git remote ：显示所有远程名 git remote 远程名 ：显示该远程名所指向的路径 git remote -v ：显示所有远程名及其路径 git remote add 远程名 远程路径 ： 添加一个远程 五、Git高级5.1 gitignore忽略文件在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里，如项目的配置文件、node_modules等 5.2 比较差异当内容被修改，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 git difftool 比较的是工作区和暂存的差异 git difftool “SHA”比较与特定提交的差异 git difftool “SHA”“SHA”比较某两次提交的差异 git difftool 分支名称 比较与某个分支的差异 5.3 回滚（撤销）操作HEAD 默认指向当前分支的“末端”，即最后的一次提交，但是我们通过git reset 可以改变HEAD的指向。 1、git reset –hard 工作区会变、历史(HEAD)会变， 暂存区也变 –soft 只会变历史(HEAD) –mixed（默认是这个选项）历史(HEAD)会变、暂存区也变，工作区不变 2、git checkout git checkout SHA – “某个文件”，代表只是从SHA这个版中取出特定的文件， 和git reset 是有区别的，reset 重写了历史，checkout 则没有。 5.4 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch 命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch “远程主机”或者 git fetch “远程主机” “分支名称” 我们要注意的是，利用git fetch 获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。如下 git pull origin 某个分支， 上操作相当于下面两步 git fetch、 git merge origin/某个分支 5.5 规范管理1、不要有太多的树杈（子分支） 2、要有一个“稳定分支”，即master分支不要轻意被修改 3、要有一个开发分支（developer），保证master分支的稳定性 4、所有的功能分支（feature）从developer创建 5、所有功能开发完成后新建发布分支（release）","tags":[{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"}]},{"title":"JQuery源码阅读（二）","date":"2017-04-24T12:37:33.000Z","path":"2017/04/24/jQuery源码阅读（二）/","text":"一、jQ原型上的核心方法和属性 1、jQuery 获取版本号 2、selector 代表所有实例默认的选择器，也代表实例是一个jQuery类型的对象 3、length 代表所有实例默认的长度 4、toArray 把实例转换为数组返回 5、get 获取指定下标的元素，获取的是原生DOM 6、each 遍历实例，把遍历到的数据分别传给回调使用 7、map 遍历实例，把遍历到的数据分别传给回调使用，然后把回调的返回值收集起来组成一个数组返回 8、slice 截取实例的部分元素，构成一个新的jQuery实例返回。 9、first 获取实例中的第一个元素，是jQuery类型的实例对象。 10、last 获取实例中的最后一个元素，是jQuery类型的实例对象。 11、eq 获取指定下标的元素，获取的是jQuery类型的实例对象。 12、push 给实例添加新元素 13、sort 对实例中的元素进行排序 14、splice 按照指定下标指定数量删除元素，也可以替换删除的元素。 二、结构抽取123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function(w)&#123; var version = \"1.0.0\"; //对外暴露的工厂函数 function jQuery(selector)&#123; return new jQuery.fn.init(selector); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, jQuery:version, selector:'', length:0, toArray:function()&#123;&#125;, get:function(num)&#123;&#125;, each:function(fn)&#123;&#125;, map:function(fn)&#123;&#125;, slice:function()&#123; eq:function(i)&#123;&#125;, first:function()&#123;&#125;, last:function()&#123;&#125;, push:[].push, pop:[].pop, shift:[].shift, unshift:[].unshift, sort:[].sort, splice:[].splice &#125;; jQuery.extend = jQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125; &#125;; jQuery.extend(&#123; each:function(obj,fn)&#123;&#125;, map:function(obj,fn)&#123;&#125;, trim : function(str)&#123;&#125;, isString : function(str)&#123;&#125;, isHTML : function(html)&#123;&#125;, isFunction : function(fn)&#123;&#125;, isWindow : function(w)&#123;&#125;, isObject : function(obj)&#123;&#125;, isLikeArray : function(arr)&#123;&#125;, ready:function(fn)&#123;&#125; &#125;); // init是真正的构造函数 var init = jQuery.fn.init = function(selector)&#123; //入口函数 &#125;; //把init函数的原型设置为JQ工厂函数的原型 init.prototype = jQuery.fn; w.$ = w.jQuery = jQuery;&#125;)(window); 可以看到，使用情景不同，大部分方法是在jQuery的原型上定义的(实例自己调用)，也就是实例方法，其他方法在jQuery工厂函数静态方法中也有定义(作为工具方法给外部调用)，each和map方法是实例和静态方法中均有。 但是，在静态方法中的each/map接收的参数是需要遍历的对象/数组/伪数组(obj)和回调函数(fn) 因为是静态方法，直接”类名”.来调用，所以遍历对象需要作为形参传入。 而在原型中定义的实例方法中的each/map,接收的参数只有fn，因为实例方法是实例调用的(eg:$(‘.item’).each(function(k,v){});)，属于”方法调用模式”,已经知道调用对象是谁，直接可以用this获取。 实例不能调用静态方法(类方法)，所以通常会在定义好类方法的同时，在原型上也添加一个同名的实例方法，直接在同名的实例方法内调用类方法即可。 三、具体实现方法中以_开头的代表该方法的简便写法,eg:get方法和_get方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258(function(w)&#123; var version = \"1.0.0\"; function jQuery(str)&#123; return new jQuery.fn.init(str); &#125; jQuery.fn = jQuery.prototype = &#123; constructor:jQuery, jQuery:version, selector:'', length:0, // toArray,get,_get,each,map,slice,_slice,eq,_eq,first,last,push,sort,splice toArray:function()&#123; return [].slice.call(this); &#125;, //得到的是原生dom get:function(num)&#123; //如果不传，即num为null、undefined，默认返回数组 if(num == null) return this.toArray(); else if(num&lt;0)&#123; return this[this.length + i]; &#125;else&#123; return this[num]; &#125; &#125;, _get:function(num)&#123; return num==null?this.toArray():(num&gt;=0?this[i]:this[this.length + i]); &#125;, each:function(fn)&#123; return jQuery.each(this,fn); &#125;, map:function(fn)&#123; return jQuery.map(this,fn); &#125;, slice:function()&#123; /* * 1、通过数组的slice截取部分元素(slice返回的是数组)， * 2、把截取到的元素转换为实例对象返回。 * */ // 因为slice的参数会有变化，所以需要是arguments， // 我们要把arguments中的每一项传给数组的slice，所以需要借用apply平铺传递过去， // 最后把slice返回数组，通过jQuery工厂保证成实例返回。\\ var nodes =[].slice.apply(this,arguments); return jQuery(nodes); &#125;, _slice:function()&#123; return jQuery([].slice.apply(this,arguments)); &#125;, eq:function(i)&#123; //返回包装对象 if(i==null)&#123; //null和undefined返回空的包装对象 return jQuery(); &#125; else if(i&gt;=0)&#123; return jQuery(this[i]); &#125;else&#123; return jQuery(this[this.length + i]); &#125; &#125;, _eq:function(i)&#123; // return i==null?jQuery():(i&lt;0?jQuery[this.length + i]:jQuery(this[i])); return i == null?jQuery():jQuery(this.get(i)); &#125;, first:function()&#123; return this.eq(0); &#125;, last:function()&#123; return this.eq(-1); &#125;, push:[].push, pop:[].pop, shift:[].shift, unshift:[].unshift, sort:[].sort, splice:[].splice &#125;; jQuery.extend = jQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125; &#125;; jQuery.extend(&#123; each:function(obj,fn)&#123; var i,len = obj.length,key; if(jQuery.isLikeArray(obj))&#123; for(i = 0,len = obj.length;i &lt; len; i++)&#123; if(fn.call(obj[i],i,obj[i]) === false) break; &#125; &#125;else&#123; for(key in obj)&#123; if(fn.call(obj[key],key,obj[key]) === false) break; &#125; &#125; return obj; &#125;, map:function(obj,fn)&#123; var i,len,key,result = []; if(jQuery.isLikeArray(obj))&#123; for(i = 0,len = obj.length; i&lt;len; i++)&#123; result.push(fn.call(obj[i],i,obj[i])); &#125; &#125;else&#123; for(key in obj)&#123; result.push(fn.call(obj[key],key,obj[key])); &#125; &#125; return result; &#125;, trim : function(str)&#123; if(typeof str !== 'string')&#123; return str; &#125; if( str.trim)&#123; return str.trim(); &#125; return str.replace(/^\\s+|\\s+$/,''); &#125;, isString : function(str)&#123; if(!str)&#123; return false; &#125; else if(typeof str === 'string')&#123; return true; &#125; return false; &#125;, //function&#123;isHTML&#125;判断字符串是否是html片段 //param &#123;html&#125; 字符串 //return &#123;boolean&#125; isHTML : function(html)&#123; if(!html)&#123; return false; &#125; if(html.charAt(0) === \"&lt;\" &amp;&amp; html.charAt(html.length - 1) === \"&gt;\" &amp;&amp; html.length&gt;3)&#123; return true; &#125; return false; &#125;, isFunction : function(fn)&#123; if(typeof fn === \"function\")&#123; return true; &#125; return false; &#125;, isWindow : function(w)&#123; if( w.window === w)&#123; return true; &#125; return false; &#125;, isObject : function(obj)&#123; //防止对null的误判，null属于object，但我们这不符合我们的isObject过滤需求 if(obj === null)&#123; return false; &#125; else if(typeof obj === 'object' || typeof obj === 'function')&#123; return true; &#125; return false; &#125;, //function&#123;isLikeArray&#125; 判断是不是数组(伪数组和真数组都算) //param &#123;arr&#125; object //return &#123;boolean&#125; isLikeArray : function(arr)&#123; //把函数、window对象和非object的排除 if(jQuery.isFunction(arr) || jQuery.isWindow(arr) || !jQuery.isObject(arr))&#123; return false; &#125; //判断是不是真数组 if((&#123;&#125;).toString.call(this,arr) === '[object Array]')&#123; return true; &#125; //判断是不是伪数组 // arr必须有length，在这个基础上，要么length为0，要么有length - 1这个属性值 if(('length' in arr) &amp;&amp; ((arr.length === 0) || (arr.length - 1 in arr)))&#123; return true; &#125; return false; &#125;, ready:function(fn)&#123; if(document.readyState === 'complete')&#123; //dom结构如果都加载完成了就直接执行传入的该函数，不需要下面的判断了 fn(); &#125; //是否支持addEventListener绑定事件方式 else if(document.addEventListener)&#123; //直接把fn添加给DOMContentLoaded事件监听 //DOMContentLoaded,H5新增事件，IE9以上支持,比window.onload快很多 document.addEventListener(\"DOMContentLoaded\",fn); &#125; else&#123; //IE8 document.attachEvent(\"onreadystatechange\",function()&#123; if(document.readyState === 'complete')&#123; fn(); &#125; &#125;); &#125; &#125; &#125;); var init = jQuery.fn.init = function( selector )&#123; //入口函数 if(!selector)&#123; //null,0,undefined,NaN,'' return this;//直接返回一个由init new出来的空实例 &#125; if(jQuery.isFunction(selector))&#123; jQuery.ready(selector); &#125; else if(jQuery.isString(selector))&#123; //字符串先trim下 selector = jQuery.trim(selector); //判断是html片段还是选择器 if( jQuery.isHTML(selector))&#123; var tempDiv = document.createElement(\"div\"); tempDiv.innerHTML = selector; [].push.apply(this,tempDiv.childNodes); return this; &#125; //选择器 else&#123; try&#123; var nodes = document.querySelectorAll(selector); [].push.apply(this,nodes); return this; &#125;catch(e)&#123; this.length = 0; return this; &#125; &#125; &#125; else if(jQuery.isLikeArray(selector))&#123; //数组或伪数组 [].push.apply(this,selector); return this; &#125; else&#123; this[0] = selector; this.length = 1; return this; &#125; &#125;; init.prototype = jQuery.fn; w.$ = w.jQuery = jQuery;&#125;)(window);","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"jQuery源码阅读（一）","date":"2017-04-23T15:40:33.000Z","path":"2017/04/23/jQuery源码阅读（一）/","text":"本次初步阅读的是jQuery的1.7的经典版本。 1. 大体结构 123456789101112131415161718192021222324(function( w ) &#123; // 对外暴露的工厂函数 function jQuery(selector) &#123; return new jQuery.fn.init(selector); &#125; // 给原型提供一个简写方式 jQuery.fn = jQuery.prototype = &#123; constructor:JQuery, //原型核心方法和属性,jquery,selector,length,toArray,each,slice,splice等 //后面会详细解释 &#125;; // init是jQuery中真正的构造函数 var init = jQuery.fn.init = function(selector) &#123; // &#125;; // 替换构造函数的原型 为 jQuery工厂的原型 init.prototype = jQuery.fn;//这步很重要 // 把工厂通过两个变量暴露出去 w.jQuery = w.$ = jQuery; &#125;( window )); 1) 在上述结构中，通过一个立即调用函数，把jQuery代码封装起来，不污染全局，function jQuery(selector){}是jQuery的工厂函数，也是对外界暴露的 2)jQuery.fn就是给jQuery.prototype取了个简短的名字，便于书写，同时把jQuery工厂函数的原型替换 3)jQuery.fn.init是给jQuery的原型添加一个init方法，因为jQuery.fn也是指向jQuery.prototype的地址的，所以修改jQuery.fn就是修改jQuery工厂函数的原型。而在jQuery工厂函数中，返回的就是new jQuery.fn.init(selector)，所以可以说，init方法就是jQuery这个类库的真正的构造函数 2. jQuery插件实现机制在提及jQuery的插件实现机制之前，先看下jQuery类库中给jQuery工厂函数和jQuery.fn这个工厂函数的原型添加的混入方法extend 12345JQuery.extend = JQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125;&#125; 这一段给工厂函数和原型一起添加了一个extend的混入继承方法，这个方法可以方便的一次性拓展多个方法 在《JQuery插件开发》书中提到，JQuery插件开发有2种大方式 1)类级别 通过添加全局函数(给jQuery这个function构造函数添加的类级别的静态方法) 123jQuery.foo = function()&#123; ...&#125; 或者通过混入的方式给jQuery构造函数添加静态方法12345678jQuery.extend(&#123; fn1:function()&#123; ... &#125;, fn2:function()&#123; ... &#125;&#125;); 2)对象级别 给jQuery的原型添加实例方法 混入法12345678(function($)&#123; $.fn.extend(&#123; pluginName:function()&#123; &#125; &#125;);&#125;)(jQuery); 或者直接添加法 12345678(function($)&#123; $.fn.pluginName = function()&#123; &#125;;&#125;)(jQuery); 3.jQuery入口函数对jQuery的入口函数进行了抽取，大致实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179(function(w)&#123; function JQuery(str)&#123; return new JQuery.fn.init(str); &#125; JQuery.fn = JQuery.prototype = &#123; constructor:JQuery &#125;; JQuery.extend = JQuery.fn.extend = function(obj)&#123; for(var key in obj)&#123; this[key] = obj[key]; &#125; &#125;; JQuery.extend(&#123; trim : function(str)&#123; if(typeof str !== 'string')&#123; return str; &#125; if( str.trim)&#123; //优先使用原生的trim方法 return str.trim(); &#125; //^\\s+代表开头的大于等于1的空格 \\s+$代表结尾的大于等于1空格 return str.replace(/^\\s+|\\s+$/,''); &#125;, isString : function(str)&#123; if(!str)&#123; return false; &#125; else if(typeof str === 'string')&#123; return true; &#125; return false; &#125;, //function&#123;isHTML&#125;判断字符串是否是html片段 //param &#123;html&#125; 字符串 //return &#123;boolean&#125; isHTML : function(html)&#123; if(!html)&#123; return false; &#125; if(html.charAt(0) === \"&lt;\" &amp;&amp; html.charAt(html.length - 1) === \"&gt;\" &amp;&amp; html.length&gt;3)&#123; return true; &#125; return false; &#125;, isFunction : function(fn)&#123; if(typeof fn === \"function\")&#123; return true; &#125; return false; &#125;, //如何判断是否是window对象？ //window对象有个属性叫window，仍然指向window isWindow : function(w)&#123; if( w.window === w)&#123; return true; &#125; return false; &#125;, isObject : function(obj)&#123; //防止对null的误判，null属于object，但我们这不符合我们的isObject过滤需求 //所以提前先手动判断 if(obj === null)&#123; return false; &#125; else if(typeof obj === 'object' || typeof obj === 'function')&#123; return true; &#125; return false; &#125;, //function&#123;isLikeArray&#125; 判断是不是数组(伪数组和真数组都算) //param &#123;arr&#125; object //return &#123;boolean&#125; isLikeArray : function(arr)&#123; //把函数、window对象和非object的排除 if(JQuery.isFunction(arr) || JQuery.isWindow(arr) || !JQuery.isObject(arr))&#123; return false; &#125; //判断是不是真数组 if((&#123;&#125;).toString.call(this,arr) === '[object Array]')&#123; return true; &#125; //判断是不是伪数组 // arr必须有length，在这个基础上，要么length为0，要么有length - 1这个属性值 if(('length' in arr) &amp;&amp; ((arr.length === 0) || (arr.length - 1 in arr)))&#123; return true; &#125; return false; &#125;, ready:function(fn)&#123; if(document.readyState === 'complete')&#123; //dom结构如果都加载完成了就直接执行传入的该函数，不需要下面的判断了 fn(); &#125; //是否支持addEventListener绑定事件方式 else if(document.addEventListener)&#123; //直接把fn添加给DOMContentLoaded事件监听 //DOMContentLoaded,H5新增事件，IE9以上支持,比window.onload快很多 document.addEventListener(\"DOMContentLoaded\",fn); &#125; else&#123; //IE8 document.attachEvent(\"onreadystatechange\",function()&#123; if(document.readyState === 'complete')&#123; fn(); &#125; &#125;); &#125; &#125; &#125;); var init = JQuery.fn.init = function( selector )&#123; //入口函数 if(!selector)&#123; //null,0,undefined,NaN,'' return this;//直接返回一个由init new出来的空实例 &#125; //如果传的是函数，直接放入ready方法，在dom加载完毕后执行 if(JQuery.isFunction(selector))&#123; JQuery.ready(selector); &#125; //字符串，html||选择器 else if(JQuery.isString(selector))&#123; //字符串先trim下 selector = JQuery.trim(selector); if( JQuery.isHTML(selector))&#123; var tempDiv = document.createElement(\"div\"); tempDiv.innerHTML = selector; [].push.apply(this,tempDiv.childNodes); return this; &#125; //选择器 else&#123; try&#123; var nodes = document.querySelectorAll(selector); [].push.apply(this,nodes); return this; &#125;catch(e)&#123; this.length = 0; return this; &#125; &#125; &#125; //数组或伪数组 else if(JQuery.isLikeArray(selector))&#123; [].push.apply(this,selector); return this; &#125; else&#123; this[0] = selector; this.length = 1; return this; &#125; &#125;; init.prototype = JQuery.fn; w.$ = w.JQuery = JQuery;&#125;)(window); tips： 上述代码实现大部分使用了上下文调用模式，也就是call/apply方法 apply方法可以该改变this指向，同时可以把数组或伪数组平铺传入给函数， 但是IE8，apply只能平铺真数组或者内置的伪数组，我们自定义的伪数组会报错。 所以需要兼容性写法 1234// 借用数组的slice方法，通过一个伪数组得到一个真数组// [].slice.call( obj ) ;可以将obj伪数组返回真数组[].push.apply( this, [].slice.call( selector ) );//可将上述入口函数//代码的apply替换为该兼容性写法 数组的slice方法是按照指定下标指定数量删除元素，也可以替换删除的元素，返回的是一个新【数组】，如果不传参数，就直接返回完整的新【数组】","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/源码/"}]},{"title":"JSNotes（四）JS中的沙箱、函数调用模式","date":"2017-04-11T01:53:06.000Z","path":"2017/04/11/JSNotes（四）JS中的沙箱、函数调用模式/","text":"沙箱与外界隔绝的一个环境，外界无法修改该环境内任何信息，沙箱内的东西单独属于一个世界 JS中的沙箱模式格式： 123456(function()&#123; var a = 123;&#125;)(); 沙箱采用立即执行函数表达式（IIFE） 因为IIFE不会在外界暴露任何的全局变量，但是又可以形成一个封闭的空间 1.在沙箱中将所有变量的定义放在最上方 2.中间就放一些逻辑代码 3.最后，如果需要，就给外界暴露一些成员（通过window作为参数传入自调用函数） 如： 12345678910111213141516(function(win)&#123; var xiangnick = &#123; getEle:function () &#123; console.log(\"我是getEle方法\"); &#125; &#125; win.XiangNick = win.$ = xiangnick;//这样就绑定在了win形参上了 &#125;)(window) 调用 1234getEle();//Uncaught ReferenceError: getEle is not defined,说明沙箱很好的隔离了全局$.getEle();//我是沙箱内的方法 沙箱是隔离的区域，内部很安全，同时也不会污染全局变量，但是如果需要和外界交互，可以把window作为实参传入，对于沙箱内部来说，操作的只是形参，外界是影响不到沙箱的。 1.如果需要在外界暴露一些属性或者方法，就可以将这些属性和方法,加到window全局对象上去,但是这window全局对象不可以直接引用，因为直接引用会破坏沙箱原则 2.所以我们选择使用传参的形式将 window对象 传入沙箱内,此时沙箱内使用window对象的时候，不会再去全局搜索window对象,而使用的就是沙箱内部定义的形参 沙箱模式的运用场景1.沙箱模式一般应用在书写第三方框架 2.或者为第三方框架书写插件 3.或者书写功能独立的一些组件 沙箱模式的优势 1.沙箱模式使用的是IIFE，不会再外界暴露任何的全局变量，也就不会造成全局变量污染 2.沙箱中的所有数据，都是和外界完全隔离的，外界无法对其进行修改，也就保证了代码的安全性 js中沙箱模式的实现原理 函数可以构建作用域！上级作用域不能直接访问下级作用域中的数据 函数调用模式其实就是this的指向不同A. 函数模式 this—&gt;window B. 方法模式 this—-&gt;调用方法的对象 C. 构造函数模式 C.1 123456789101112131415161718function Person(name,age)&#123; this.name = name; this.age = age; this.sayHi = function()&#123; console.log(\"我是\"+name+\"今年我\"+age+\"岁\"); &#125;&#125;var p = new Person('macal',23);p.sayHi(); this—–&gt;new出来的实例 拓展：由于构造函数new对象时，不写返回值默认返回new的实例，返回值写常量仍然返回new的实例，但是写引用类型，则会返回该引用类型，因此，对于构造函数模式，有了以下的变种【了解即可，与本主题无关】 C.2 工厂模式 123456789101112131415161718function Person(name,age) &#123; var o = &#123; name: name, age: age &#125; return o;&#125;var p = Person('jack',20);console.log(p);//P是一个Object对象,和构造函数Person()无关 C.3 寄生模式 123456789101112131415161718function Fun(name, age) &#123;var o = &#123;name: name,age: age&#125;return o;&#125;var obj = new Fun('jack', 20);//new出来的是Object对象,和构造函数无关 D. 上下文模式 this—–&gt;指定的是谁就是谁 call 函数.call(对象,arg1,arg2,arg3,…argn) apply 函数.apply(对象,数组) 都可以用来改变this的指向为参数的第一个值 call是使用单独的每一个参数来传参 apply是使用数组进行传参的，这个数组在调用的时候，会被意义拆解，当做函数的每一个采参数 call在函数的形参个数确定的情况下使用 apply在函数的形参个数不确定的情况下使用 12345678910111213141516function test() &#123;console.log(this);&#125;test.apply(1);//Numbertest.apply(\"abc\");//Stringtest.apply(true)//Booleantest.apply(null)//Windowtest.apply(undefined)//Window 当用call和apply传入的第一个参数为值类型的时候,会将值类型转换成对应的对象（引用类型） 然后赋值给this 当传入的第一个参数为 null或者undefined的时候，会把this赋值为 window 上下文模式小应用 求数组最大值。 123456var arr = [12,312,53,34,23,12,111]; var max = Math.max.apply(null,arr); console.log(max); 由于Math.max()方法只接收一个个的参数，不接收数组，所以我们用apply的特性，他会把apply方法中第二个参数，也就是数组，拆为一个个单个参数传入，来求最大值。 把传入函数的参数连接成字符串，中间以分隔符相连 123456789101112var result = foo(1, 3, \"abc\", \"ffff\", 99);function foo()&#123;var str = Array.prototype.join.call(arguments,\"-\");//A句return str;&#125;console.log(result); 这里用了数组的join方法。 题外话： 对于A句，我们可以修改为 var str = [].join.call(arguments,”-“); 熟悉原型链的可以知道,[]就相当于new了一个Array的实例，本身没有join方法(因为是Array的公共方法，放在原型里)，就去调用原型里的join方法来满足。 这句虽然写着简便，很短。但其实执行效率没有A句那么好，因为有个实例去原型搜索的过程。 详细介绍函数模式特征:就是一个简单的函数调用，函数名前面没有任何的引导内容 12345678910function foo()&#123;&#125;var func = function()&#123;&#125;foo();func();(function()&#123;&#125;)(); this在函数模式中的含义： this在函数中表示全局对象，在浏览器中是window对象 方法模式特征: 方法一定是依附于一个对象, 将函数赋值给对象的一个属性, 那么就成为了方法. 123456789101112function f() &#123; this.method = function () &#123;&#125;;&#125;var o = &#123; method: function () &#123;&#125;&#125; this在方法模式调用中的含义:表示函数所依附的这个对象 构造器调用模式由于构造函数只是给 this 添加成员. 没有做其他事情. 而方法也可以完成这个操作, 就 this 而言, 构造函数与方法没有本质区别. 特征:使用 new 关键字, 来引导构造函数. 1234567891011121314function Person()&#123; this.name = \"zhangsan\"; this.age = 19; this.sayHello = function()&#123; &#125;;&#125;var p = new Person(); 构造函数中发this与方法中一样, 表示对象, 但是构造函数中的对象是刚刚创建出来的对象 关于构造函数中return关键字的补充说明 构造函数中不需要return, 就会默认的return this 如果手动的添加return, 就相当于 return this 如果手动的添加return 基本类型; 无效, 还是保留原来 返回this 如果手动添加return null; 或return undefiend, 无效 如果手动添加return 对象类型; 那么原来创建的this就会被丢掉, 返回的是 return后面的对象 创建对象的模式工厂方法123456789101112131415161718// 工厂就是用来生产的, 因此如果函数创建对象并返回, 就称该函数为工厂函数function createPerson( name, age, gender ) &#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;// document.createElement()原理 构造方法123456789101112function Person(name, age, gender)&#123; this.name = name; this.age = age; this.gender = gender;&#125;var p = new Person(\"zhangsan\", 19, \"男\"); 寄生式创建对象12345678910111213141516function Person(name, age, gender)&#123; var o = &#123;&#125;; o.name = name; o.age = age; o.gender = gender; return o;&#125;var p = new Person(\"Jack\", 18, \"male\"); 混合式创建混合式继承就是讲所有的属性放在构造方法里面，然后讲所有的方法放在原型里面，使用构造方法和原型配合起来创建对象。 上下文调用模式上下文(Context)，就是函数调用所处的环境。 上下文调用，也就是自定义设置this的含义。 在其他三种调用模式中，函数/方法在调用的时候，this的值都是指定好了的，我们没办法自己进行设置，如果尝试去给this赋值，会报错。 上下文调用的语法12345678910//第一种， apply函数名.apply(对象, [参数]);//第二种， call函数名.call(对象, 参数);//上面两种方式的功能一模一样，只是在传递参数的时候有差异。 功能描述： 语法中的函数名表示的就是函数本身，使用函数调用模式的时候，this默认是全局对象 语法中的函数名也可以是方法(如:obj.method)，在使用方法模式调用的时候，this默认是指当前对象 在使用apply和call的时候，默认的this都会失效，this的值由apply和call的第一个参数决定 补充说明 如果函数或方法中没有this的操作, 那么无论什么调用其实都一样. 如果是函数调用foo(), 那么有点像foo.apply( window ). 如果是方法调用o.method(), 那么有点像o.method.apply( o ). 参数问题call和apply在没有后面的参数的情况下(函数无参数, 方法无参数) 是完全一样的. 如下： 12345678910function foo() &#123; console.log( this );&#125;foo.apply( obj );foo.call( obj ); 第一个参数的使用规则: 如果传入的是一个对象, 那么就相当于设置该函数中的 this 为参数 如果不传入参数, 或传入 null. undefiend 等, 那么相当于 this 默认为 window 12345678foo();foo.apply();foo.apply( null );foo.call( undefined ); 如果传入的是基本类型, 那么 this 就是基本类型对应的包装类型的引用 number -&gt; Number boolean -&gt; Boolean string -&gt; String 第二个参数的使用规则 在使用上下文调用的时候, 原函数(方法)可能会带有参数, 那么这个参数在上下文调用中使用第二个( 第 n 个 )参数来表示 123456789101112function foo( num ) &#123; console.log( num );&#125;foo.apply( null, [ 123 ] );// 等价于foo( 123 ); 上下文调用模式的应用上下文调用只是能修改this, 但是使用的最多的地方上是函数借用. 1. 将伪数组转换为数组传统的做法： 1234567891011121314151617181920var a = &#123;&#125;;a[ 0 ] = 'a';a[ 1 ] = 'b';a.length = 2;// 使用数组自带的方法 concat// 如果参数中有数组会把参数数组展开// 语法: arr.concat( 1, 2, 3, [ 4, [ 5 ] ] );// 特点：不修改原数组var arr = [];var newArr = arr.concat( a ); 由于a是伪数组, 只是长得像数组. 所以上面的代码不能成功，不能使用concat方法。 但是apply方法有一个特性, 可以将数组或伪数组作为参数。（IE8不支持伪数组操作） 12foo.apply( obj, 伪数组 ); // IE8 不支持 利用apply方法，可以写出以下 1234//将伪数组 a 作为 apply 的第二个参数var newArr = Array.prototype.concat.apply( [], a ) 处理数组转换, 实际上就是将元素一个一个的取出来构成一个新数组, 凡是涉及到该操作的方法理论上都可以。 push方法123456789101112131415161718192021222324//用法:arr.push( 1 ); //将这个元素加到数组中, 并返回所加元素的个数arr.push( 1, 2, 3 ); //将这三个元素依次加到数组中, 返回所加个数var a = &#123; length: 0 &#125;; // 伪数组a[ a.length++ ] = 'abc'; // a[ 0 ] = 'abc'; a.length++;a[ a.length++ ] = 'def';// 使用一个空数组, 将元素一个个放到数组中即可var arr = [];arr.push( a ); // 此时不会将元素展开, 而是将这个伪数组作为一个元素加到数组中// 再次利用 apply 可以展开伪数组的特征arr.push.apply( arr, a );// 利用 apply 可以展开伪数组的特性, 这里就相当于 arr.push( a[0], a[1] ) 2. 求数组中的最大值传统的做法 123456789101112var max = arr[ 0 ];for ( var i = 1; i &lt; arr.length; i++ ) &#123; if ( arr[ i ] &gt; max ) &#123; ... &#125;&#125; 在 js 中的Math对象中提供了很多数学函数Math.max( 1,2,3 ) 还是利用 apply 可以展开数组的特性 1234var arr = [ 123456,12345,1234,345345,234,5 ];Math.max.apply( null, arr ); 3.借用构造函数继承12345678910111213141516171819202122function Person ( name, age, gender ) &#123; this.name = name; this.age = age; this.gender = gender;&#125;// 需要提供一个 Student 的构造函数创建学生对象// 学生也应该有 name, age, gender, 同时还需要有 course 课程function Student ( name, age, gender, course ) &#123; Person.call( this, name, age, gender ); this.course = course;&#125; 面试题12345678910111213141516171819202122//1 var age = 38; var obj = &#123; age: 18, getAge: function() &#123; console.log(this.age); &#125; &#125;;// var a = obj.getAge(); //18 var getAge = obj.getAge; getAge();//38 var a = obj.getAge(); 因为是obj点的，是方法模式，this指向obj，所以打印18 var getAge = obj.getAge; getAge(); 就是函数模式调用，自然this指向全局，打印38 1234567891011121314151617181920212223242526//2var age = 38;var obj = &#123; age: 18, getAge: function() &#123; console.log(this.age);//A处 18 function foo() &#123; console.log(this.age); //B处 38 &#125; foo(); &#125;&#125;;obj.getAge(); A处：obj.getAge()是obj调用的，所以A处为方法模式，this指向obj，自然打印出obj内部的age:18 B处：getAge内部还执行了一个foo()函数，看他调用的方式，前面没有对象来点，直接的调用一个函数，就是函数模式，指向window，打印38 1234567891011121314151617181920212223242526//3 var length = 10; function fn()&#123; console.log(this.length); &#125; var obj = &#123; length: 5, method: function (fn) &#123; fn(); //A处 10 arguments[0](); //B处 4 &#125; &#125;; obj.method(fn, 123, 456, 789); method虽然是obj调用的，为方法模式，但是其内部执行了fn()，为函数模式，this指向window，所以A处打印10 然后B处的arguments[0] ();因为arguments是一个对象，内部有着参数，对象[索引]的形式其实就是对象.索引。所以为方法模式，即arguments来调用传入参数内的fn()函数，即打印arguments的长度，为4 总结函数调用模式其实很简单，就看其调用形式 如果是 obj.fn() 就是方法模式，this指向调用者obj 如果是 fn() 就是函数模式，this指向全局window 如果是var obj = new Person(); obj.fn(); 就是构造函数模式，this指向new出来的obj实例 还有一个最特殊的上下文模式 函数.call(对象,arg1,arg2,arg3,...argn) 函数.apply(对象,数组) 都可以用来改变this的指向为参数的第一个值","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（三）JS的闭包","date":"2017-04-09T09:39:19.000Z","path":"2017/04/09/JSNotes（三）JS的闭包/","text":"闭包闭包的概念闭包从字面意思理解就是闭合, 包起来. 简单的来说闭包就是,一个具有封闭的对外不公开的, 包裹结构, 或空间.在JavaScript中函数可以构成闭包. 一般函数是一个代码结构的封闭结构, 即包裹的特性, 同时根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. 因此说函数可以构成闭包. 闭包要解决什么问题？ 闭包内的数据不允许外界访问 要解决的问题就是间接访问该数据 函数就可以构成闭包, 要解决的问题就是访问到函数内部的数据 我们观察下面的函数foo，在foo内部有一个变量num，能否在函数外部访问到这个变量num呢？ 123456789101112function foo () &#123; var num = 123; return num;&#125;var res = foo();console.log( res ); // =&gt; 123 分析： 在上面的代码中，确实可以访问到num这个函数内部的变量。但是能不能多次访问呢？ 不能，因为每次访问都得重新调用一次foo函数，每次调用都会重新创建一个num = 123，然后返回。 解决思路函数内的数据不能直接在函数外被访问，是因为作用域的关系，上级作用域不能直接访问下级作用域中的数据。 但是如果反过来，下级作用域可以直接访问上级作用域中的数据。那么如果在函数foo内定义一个函数，那么在这个内部函数中是可以直接访问foo中的num的。 12345678910111213141516171819202122function foo() &#123; var num = Math.random(); function func() &#123; return num; &#125; return func;&#125;var f = foo();// f可以直接访问num，而且多次访问，访问的也是同一个，并不会返回新的numvar res1 = f();var res2 = f(); 如何获得超过一个数据函数的返回值只能有一个，那按照上面的方法，我们只能对函数内部的一个数据进行操作。怎么操作函数内的多个数据呢？ 可以使用对象，代码如下： 1234567891011121314151617181920212223242526function foo () &#123; var num1 = Math.random(); var num2 = Math.random(); //可以将多个函数包含在一个对象内进行返回，这样就能在函数外部操作当前函数内的多个变量 return &#123; num1: function () &#123; return num1; &#125;, num2: function () &#123; return num2; &#125; &#125;&#125; 如何完成读取一个数据和修改这个数据前面讲的都是如何去获取函数内部的数据，接下来我们考虑如何修改函数内部的数据。 同样，也是使用内部的函数进行操作。 12345678910111213141516171819202122232425262728function foo() &#123; var num = Math.random(); //分别定义get和set函数，使用对象进行返回 return &#123; //get_num负责获取数据 get_num: function() &#123; return num; &#125;, //set_num负责设置数据 set_num: function(value) &#123; num = value; &#125; &#125;&#125; 我们还可以模仿JQ的方法思路，fun()是获取数据,fun(val)是修改数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function foo()&#123; var fname = \"nick\"; var fage = 23; return &#123; name:function(value)&#123; if(value === undefined)&#123; &#125;else&#123; fname = value; &#125; return fname; &#125;, age:function(value)&#123; if(value === undefined)&#123; &#125;else&#123; fage = value; &#125; return fage; &#125; &#125;; &#125; var obj = foo(); console.log(obj.name()); console.log(obj.age()); console.log(obj.age(24)); 总结闭包的作用：根据作用域规则, 只允许函数访问外部的数据, 外部无法访问函数内部的数据, 即封闭的对外不公开的特性. Js中函数可以产生作用域，因此说函数可以构成闭包。 1.可以读取函数内部的变量 2.让这些变量的值始终保持在内存中。 好处：闭包更像是面向对象语言中的封装，函数内部的数据被封装起来私有化，外部无法直接修改，只能依靠我们提供的方法来修改和获取我们私有化的内部数据，Java中的get、set方法。同时，由于是我们提供方法给外部访问我们内部私有化的数据，所以： 1.在函数外部想要修改数据，只能通过函数内部的方法 2.我们可以在函数内部定义的这个方法里设置安全措施，校验之类的操作不合法可以throw异常 3.可以保证系统的安全性和稳定性 坏处:上面说到，闭包的作用之一还有一个将函数内部的私有变量始终保存在内存中，这既是好处(操作的一直是同一个数据)，也有坏处（由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除） 如何理解呢？ 下面摘自偶像阮一峰大神博客的一段内容： 123456789101112131415161718192021222324function f1()&#123; var n=999; nAdd=function()&#123;n+=1&#125; function f2()&#123; alert(n); &#125; return f2; &#125; var result=f1(); result(); // 999 nAdd(); result(); // 1000 在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 阮大神在博客结尾留下了两个闭包的思考题： 题一： 1234567891011121314151617181920var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//The Window 题二： 12345678910111213141516171819202122var name = \"The Window\";var object = &#123; name : \"My Object\", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//My Object 解析：对于题一： 12object.getNameFunc()() 也就是 12345678(function()&#123; return function()&#123; return this.name; &#125;)(); 是不是就是在全局调用这个函数,这是闭包没闭上 由于this是动态的，在调用语句的那一刻来获取上下文，这两题中就看在什么时候才能逐句解释运行到this关键字，来动态获取上下文。 在题一中，在最后调用时this才开始获取上下文，是window ，于是在全局找到了var name = “The Window”; 弹出The Window 对于题二： 由于用了var that = this;这时候，this就是开始获取上下文了！发现是在object内，所以this指向object并赋值给了that，所以这时候that就指向object了！自然弹出作用域里的My Object! 这是包上了，在外部来操作内部变量。 小应用利用闭包+缓存解决递归求解斐波那契数列性能问题对于一般的递归斐波那契数列写法，为： 123456789101112function Fibonacci(n)&#123; if(n &lt;= 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 我们可以在函数内部加上count计数器来计算其递归运算了多少次，以简单的测试其性能 123456789101112131415161718192021222324252627282930var count = 0;function Fibonacci(n)&#123; count++; if(n &lt;= 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;console.log(\"计算5的返回值: \"+Fibonacci(5)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算6的返回值: \"+Fibonacci(6)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算20的返回值: \"+Fibonacci(20)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算21的返回值: \"+Fibonacci(21)+\" ，运算了 【 \"+count+\" 】次\"); 结果： 可以看出，计算20的返回值就要递归上万次，性能可想而知。由于斐波那契数列的特殊性，后者的值需要加上前两项的值，我们采用缓存来存储之前算过的值。同时采用闭包将缓存封装起来，提供我们自己定义的方法来安全操作缓存，提高其安全性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112//定义缓存，闭包封装好，返回指定方法来操作缓存function cacheFactory(length)&#123; var cache = &#123;&#125;; var keys = []; if(length === undefined)&#123; throw &#123; \"errCode\":4, \"errMsg\":\"请定义缓存容量!\" &#125; &#125; return function(key,value)&#123; if(keys.length &gt; length)&#123; //清第一个也就是最旧的数据 var tempKey = keys.shift(); delete cache[tempKey]; &#125; if(value !== undefined)&#123; //设置值 cache[key] = value; keys.push(key);//把key存入数组 return cache[key]; &#125;else&#123; //取值 return cache[key]; &#125; &#125; &#125;//开始计算 var count = 0;function FiboByCache()&#123; var cache = cacheFactory(50); function fibo(n)&#123; count++; if(cache(n) !== undefined)&#123; //缓存有值，直接返回 return cache(n); &#125; //没有，就计算，并加入缓存 if(n &lt;= 2)&#123; cache(n,1); return 1; &#125; var temp = fibo(n -1) + fibo(n -2); cache(n,temp); return temp; &#125; return fibo;&#125;var fib = FiboByCache();console.log(\"计算5的返回值: \"+fib(5)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算6的返回值: \"+fib(6)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算20的返回值: \"+fib(20)+\" ，运算了 【 \"+count+\" 】次\");count = 0;console.log(\"计算21的返回值: \"+fib(21)+\" ，运算了 【 \"+count+\" 】次\"); 结果为： 可见，性能有了很好的提升. = = 最后的最后，通过阅读JQuery源码中对于缓存的写法，在此将上述的缓存代码修改，更加简洁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function cacheFactory(capacity) &#123; var keys = []; //存储键的数组 if (capacity === undefined) &#123; throw &#123; \"errCode\": 4, \"errMsg\": \"请定义缓存容量!\" &#125; &#125; function cache(key, value) &#123; if (keys.push( key + \" \") &gt; capacity ) &#123; delete(cache[keys.shift()]); &#125; return (cache[key + \" \"] = value); &#125; return cache;&#125; //使用方法 var cache = cacheFactory(3); //存值,存值用\"方法\"传入key和value cache(\"key1\",\"valueA\"); cache(\"key2\",\"valueB\"); cache(\"key3\",\"valueC\"); cache(\"key4\",\"valueD\"); //取值，取值用\"属性\"获取的方式[]，而不是再方法传参了 console.log(cache[\"key1 \"]);//undefined 大于容量会被清除缓存 1.因为函数也是对象，直接把闭包返回的函数作为“缓存的对象”，不需要额外定义一个cache{}对象了 2.直接将key存入键数组，返回值为该数组的新长度，如果他的长度大于容量，直接弹出第一个最旧的key，并且从这个函数“缓存对象中”delete 3.这里存key和取key都需要加上空格” “,因为我们是把这个函数对象来缓存数据的，也就是给他加上静态成员变量。为了避免覆盖函数对象原来定义好的内部原生成员变量，所以所有key都加上空格” “ 比如，如果我们存入的缓存值的key为toString，则会覆盖function cache(key,value){}对象的toString方法，所以取值和设值，key都要加上空格.存值并且返回(存值也就是给function对象加上静态属性) 我们可以这么使用他 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var count = 0;function FiboByCache() &#123; var cache = cacheFactory(50); function fibo(n) &#123; count++; if (cache[n+\" \"] !== undefined) &#123; //缓存有值，直接返回 return cache[n +\" \"]; &#125; //没有，就计算，并加入缓存 if (n &lt;= 2) &#123; cache(n, 1); return 1; &#125; var temp = fibo(n - 1) + fibo(n - 2); cache(n, temp); return temp; &#125; return fibo;&#125;var fib = FiboByCache();console.log(\"计算5的返回值: \" + fib(5) + \" ，运算了 【 \" + count + \" 】次\");count = 0;console.log(\"计算6的返回值: \" + fib(6) + \" ，运算了 【 \" + count + \" 】次\");count = 0;console.log(\"计算20的返回值: \" + fib(20) + \" ，运算了 【 \" + count + \" 】次\");count = 0;console.log(\"计算21的返回值: \" + fib(21) + \" ，运算了 【 \" + count + \" 】次\");","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（二）JS的变量声明提升","date":"2017-04-09T09:38:22.000Z","path":"2017/04/09/JSNotes（二）JS的变量声明提升/","text":"JavaScript是解释型的语言，但是他并不是真的在运行的时候逐句的往下解析执行。我们来看下面这个例子： 12345func();function func()&#123; alert(\"Funciton has been called\");&#125; 在上面这段代码中，函数func的调用是在其声明之前，如果说JavaScript代码真的是逐句的解析执行，那么在第一句调用的时候就会出错，然而事实并非如此，上面的代码可以正常执行，并且alert出来Function has been called。 所以，可以得出结论，JavaScript并非仅在运行时简简单单的逐句解析执行！ JavaScript 预解析JavaScript引擎在对JavaScript代码进行解释执行之前，会对JavaScript代码进行预解析，在预解析阶段，会将以关键字var和function开头的语句块提前进行处理。 关键问题是怎么处理呢? 当变量和函数的声明处在作用域比较靠后的位置的时候，变量和函数的声明会被提升到作用域的开头。 函数预解析1.普通函数形式12345func();function func()&#123; alert(\"Funciton has been called\");&#125; 由于JavaScript的预解析机制，上面的代码就等效于： 12345function func()&#123; alert(\"Funciton has been called\");&#125;func(); 2.函数表达式形式1234567func(); var func = function()&#123; console.log(1); &#125; 预解析后：123456789var func; func(); func = function()&#123; console.log(1); &#125; 总结：函数的预解析，普通的function func(){}函数会全体提升，而函数表达式var func = function(){}只会提升var func;声明，函数体不提升。看完函数声明的提升，再来看一个变量声明提升的例子： 123alert(a);var a = 1; 由于JavaScript的预解析机制，上面这段代码，alert出来的值是undefined，如果没有预解析，代码应该会直接报错a is not defined，而不是输出值。 Wait a minute, 不是说要提前的吗？那不是应该alert出来1，为什么是undefined? 那么在这里有必要说一下声明、定义、初始化的区别。其实这几个概念是C系语言的人应该都比较了解的。 行为 说明 声明 告诉编译器/解析器有这个变量存在,这个行为是不分配内存空间的,在JavaScript中，声明一个变量的操作为：var a; 定义 为变量分配内存空间，在C语言中，一般声明就包含了定义，比如：int a;,但是在JavaScript中，var a;这种形式就只是声明了。 初始化 在定义变量之后，系统为变量分配的空间内存储的值是不确定的，所以需要对这个空间进行初始化，以确保程序的安全性和确定性 赋值 赋值就是变量在分配空间之后的某个时间里，对变量的值进行的刷新操作（修改存储空间内的数据) 所以我们说的提升，是声明的提升。 那么再回过头看，上面的代码就等效于： 12345var a; //这里是声明alert(a);//变量声明之后并未有初始化和赋值操作，所以这里是 undefineda = 1; 复杂点的情况分析通过上一小节的内容，我们对变量、函数声明提升已经有了一个最基本的理解。那么接下来，我们就来分析一些略复杂的情况。 函数同名观察下面这段代码: 1234567891011func1();function func1()&#123; console.log('This is func1');&#125;func1();function func1()&#123; console.log('This is last func1');&#125; 输出结果为： 123This is last func1This is last func1 原因分析：由于预解析机制，func1的声明会被提升，提升之后的代码为： 1234567891011function func1()&#123; console.log('This is func1');&#125;function func1()&#123; console.log('This is last func1');&#125;func1();func1(); 同名的函数，后面的会覆盖前面的，所以两次输出结果都是This is last func1。 变量和函数同名12345alert(foo);function foo()&#123;&#125;var foo = 2; 当出现变量声明和函数同名的时候，其实变量声明和函数都会提升，但是函数提升的更高，在变量声明的上方，所以上面的代码的输出结果为 1function foo()&#123;&#125;//这是一段字符串,因为是alert里的 我们还是来吧预解析之后的代码展现出来: 1234567function foo()&#123;&#125;;var foo;//没什么影响,可以忽略这句alert(foo);foo = 2; 再来看一种 1234567var num = 1;function num () &#123; alert( num );&#125;num(); 代码执行结果为： 1Uncaught TypeError: num is not a function 直接上预解析后的代码： 1234567function num()&#123; alert(num);&#125;var num; //没什么影响,可以忽略这句num = 1; //把num的地址由函数体改为1了num(); //Uncaught TypeError: num is not a function 总结：123456//a)console.log(num);//function num()&#123;&#125; var num = 123; function num()&#123;&#125;; 和1234//b) var num = 123; function num()&#123;&#125;;console.log(num);//123 为啥会有这样的区别？ 预解析后的代码: 12345//a)function num()&#123;&#125;;var num;//没什么影响,可以忽略这句console.log(num);//function num()&#123;&#125;num = 123; 和12345678//b)function num()&#123;&#125;;var num;//没什么影响,可以忽略这句num = 123;console.log(num);//123 看出来了吗？ ❤当函数和变量同名时，其实函数和变量声明都会提升，但是函数比变量声明提升的还要多，在该作用域顶部。123456 var num = 123; function num()&#123;&#125;;console.log(num);//123 预解析后就是1234567 function num()&#123;&#125;; var num;//没什么影响,可以忽略这句num = 123;console.log(num);//123 a)与b)的区别就是一开始cosole.log(num);的顺序不同导致第二个num = 123在console.log(num);之前。num = 123这句话就是把上面的num函数的地址引用指向了123导致结果与a)不同的 预解析是分作用域的声明提升并不是将所有的声明都提升到window对象下面，提升原则是提升到变量运行的环境(作用域)中去。 123456function showMsg()&#123; var msg = 'This is message';&#125;alert(msg); // msg未定义 还是直接把预解析之后的代码写出来： 1234567function showMsg()&#123; var msg; msg = 'This is message';&#125;alert(msg); // msg未定义 预解析是分段的分段，其实就分script标签的 123456789101112131415161718192021&lt;script&gt;func(); // 输出 AA2;function func()&#123; console.log('AA1');&#125;function func()&#123; console.log('AA2');&#125;&lt;/script&gt;&lt;script&gt;function func()&#123; console.log('AA3');&#125;&lt;/script&gt; 在上面代码中，第一个script标签中的两个func进行了提升，第二个func覆盖了第一个func，但是第二个script标签中的func并没有覆盖上面的第二个func。所以说预解析是分段的。 tip:但是要注意，分段只是单纯的针对函数，变量并不会分段预解析。 函数表达式并不会被提升12345func();var func = function()&#123; alert(\"我被提升了\");&#125;; 这里会直接报错，func is not a function，原因就是函数表达式，并不会被提升。只是简单地当做变量声明进行了处理，如下： 1234567var func;func();func = function()&#123; alert(\"我被提升了\");&#125; 条件式函数声明123456789console.log(typeof func);if(true)&#123; function()&#123; return 1; &#125;&#125;console.log(typeof func); 上面这段代码，就是所谓的条件式函数声明，这段代码在Gecko引擎中打印&quot;undefined&quot;、&quot;function&quot;；而在其他浏览器中则打印&quot;function&quot;、&quot;function&quot;。 原因在于Gecko加入了ECMAScript以外的一个feature：条件式函数声明。 Conditionally created functions Functions can be conditionally declared, that is, a function declaration can be nested within an if statement. &gt; Note: Although this kind of function looks like a function declaration, it is actually an expression (or statement), since it is nested within another statement. See differences between function declarations and function expressions. Note中的文字说明，条件式函数声明的处理和函数表达式的处理方式一样，所以条件式函数声明没有声明提升的特性。 最重要的小练习来了！ 例一1234567891011function foo() &#123; var num = 123; console.log(num); //? &#125; foo(); console.log(num); //? 预解析(声明提升)后的代码 123456789101112131415//预解析function foo() &#123;var num;num = 123;console.log(num); //?123&#125;foo();console.log(num); //?报错，num is not defined Tips: ① is not defined 没有定义 是报错 ② undefined 定义了没有赋值 –打印undefined 例二12345678910111213var scope = \"global\"; foo(); function foo() &#123; console.log(scope); //？undefined var scope = \"local\"; console.log(scope); //？ local &#125; 预解析(声明提升)后的代码12345678910111213141516171819//预解析var scope;function foo()&#123;var scope;console.log(scope); //？undefinedscope = \"local\";console.log(scope); //？ local&#125;scope = \"global\";foo(); 例三1234567891011121314151617181920212223function f1()&#123;var a;if(\"a\" in window)&#123;var a = 10;&#125;alert(a); // ?&#125;f1();if(!\"a\" in window)&#123;var a = 10;&#125;alert(a); // ? 预解析(声明提升)后的代码123456789101112131415161718192021222324252627//预解析function f1()&#123;var a;if(\"a\" in window)&#123;a = 10;&#125;alert(a); //10&#125;f1();var a;if(!\"a\" in window)&#123;a = 10;&#125;alert(a); // ? undefined Tips:in 关键字1.用法一 遍历对象 for(var key in 对象名){} 2.用法二 判断属性(数值就是索引值)是否存在对象中,返回boolean if( a in obj){…} 3.用法三 判断数组是否存在某个键 注意!关键字判断数组的时候是判断索引是否存在,而不是值 if(1 in arr){..} 是判断arr数组有没有1索引，感觉挺鸡肋是吧？那么怎么判断数组中是否有指定值呢？ 如何判断数组中是否存在指定的值 arr.indexOf 找到返回指定元素的索引值, 没有找到返回-1 例四123456789101112131415var foo = 1;function bar() &#123;if(!foo) &#123;var foo = 10;&#125;alert(foo); //??10&#125;bar(); 预解析(声明提升)后的代码 123456789101112131415161718192021//预解析var foo;function bar()&#123;var foo;if(!foo) &#123; foo = 10;&#125;alert(foo); //??10&#125;foo = 1;bar(); Tips:foo是undefined，undefined和null作为boolean判断都为false，null参与数值运算是0，undefined参与数值运算是NaN例五 （大题）123456789101112131415161718192021222324252627282930 function Foo() &#123;getName = function()&#123; alert(1); &#125;;return this;&#125;Foo.getName = function() &#123; alert(2); &#125;; //AFoo.prototype.getName = function()&#123; alert(3); &#125;; //Bvar getName = function() &#123; alert(4); &#125;; //Cfunction getName()&#123; alert(5); &#125; //DFoo.getName(); // ?getName(); // ?Foo().getName(); // ?getName(); // ? new Foo.getName(); // ?new Foo().getName(); // ?new new Foo().getName(); // ? 预解析(声明提升)后的代码 123456789101112131415161718192021222324252627282930313233343536//预解析之后 function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this; &#125; var getName; function getName()&#123; alert(5); &#125; //D Foo.getName = function() &#123; alert(2); &#125;; //A Foo.prototype.getName = function()&#123; alert(3); &#125;; //B getName = function() &#123; alert(4); &#125;; //C Foo.getName(); // ? getName(); // ? Foo().getName(); // ? getName(); // ? 4 // new Foo.getName(); // ? new Foo().getName(); // ? new new Foo().getName(); // ? 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 1) Foo.getName(); // ? 由于B句是给Foo构造函数添加静态方法 因为已经添加过了，所以此处可以直接调用Foo的静态方法 结果：alert(2) // 2) getName(); // ? 这里去全局找getName()方法，但是看到D和C句都是全局的getName方法，由于C句经过预解析后在下方，所以层叠掉了预解析后的上方的④句，所以调用的是C句这个全局getName方法 结果：alert(4) // 3) Foo().getName(); // ? 这里是调用Foo()方法[注意：Foo()既可以当作构造函数，也可以直接调用执行] 调用Foo()方法的过程中，第一行getName = function()&#123; alert(1); &#125;;，先在Foo()函数创造的作用域内寻找getName，发现没有，就去全局找，找到了C句，所以将其修改为function()&#123; alert(1); &#125;;，所以记住，此时全局的C句的getName方法改为alert(1)了，然后第二行return this;因为是普通的全局调用函数，所以this指向window，即window.getName(); 也就是在全局调用getName方法，此时的全局的C句getName方法已经被修改为alert(1)了，而且预解析后，C句把D句层叠了，所以此处为调用修改后的C句 结果：alert(1) // 4) getName(); // ? 这里就是全局调用getName方法,C句把D句层叠了，而且C句也被修改成alert(1)了 结果: alert(1) // 5) new Foo.getName(); // ? 这里的new Foo.getName()，是先执行后面的Foo.getName()，再执行new,由第一题可知，之前A句就给Foo构造函数添加了静态方法getName,所以可以直接执行Foo构造函数的静态getName方法,为alert(2),由于alert语句执行结束返回值为undefined,new undefined没效果，就不管了 结果：alert(2) // 6) (new Foo).getName(); 这题和上一题不同的是给new Foo加了括号，优先执行。 注意：如果构造函数没有参数的话，可以不写()来new实例对象，所以这个等效于(new Foo()).getName(); function Foo() &#123; getName = function()&#123; alert(1); &#125;; return this; &#125; 这是Foo()构造函数，他内部并没有属性和方法[this.xxx = xxx,this.xxx = function()&#123;xxx&#125;才叫他的成员属性/方法，能给实例对象的] 所以new Foo()出来的实例对象没有成员属性/方法,只有一个__proto__ 既然内部没有，就去原型里找，由B句可知，给Foo的原型绑定了一个getName方法，所以可以通过new Foo()出来的实例仅有的__proto__来调用他原型的getName方法 结果：alert(3) // new Foo().getName(); // ? 同上 结果：alert(3) // new new Foo().getName(); // ? 先new Foo()，再调用getName()，同第6)题，实例对象没，就去原型找，然后执行完毕alert(3)后返回undefined，new undefined 没意义。 结果: alert(3)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSNotes（一）JS的作用域","date":"2017-04-09T09:36:29.000Z","path":"2017/04/09/JSNotes（一）JS的作用域/","text":"作用域 作用：起作用 域：范围 变量起作用的范围就是变量的作用域 1.块级作用域 JavaScript中没有块级作用域 如果有块级作用域下面的代码的显示结果为 undefined undefined 1234567for(var i=0; i&lt;10;i++)&#123; var num = i;&#125;console.log(i);console.log(num); 但是Js没有块级作用域，所以结果为:10 9 2.词法作用域什么是词法作用域？ 词法( 代码 )作用域, 就是代码在编写过程中体现出来的作用范围. 代码一旦写好, 不用执行, 作用范围就已经确定好了. 这个就是所谓词法作用域. 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 例子1：123456789101112var a = 123; function f1()&#123; console.log(a); &#125; function f2()&#123; var a = 456; f1(); &#125; f2(); //123 词法作用域就是在代码写好的那一刻，变量的作用域就确定了。所以调用f2(),f2内部再调用f1时，f1()打印的a就是f1()函数写好时确定的a，也就是全局的var a=123 例子2：12345if ( false ) &#123; var num = 123;&#125;console.log( num ); // undefiend 这里的if(){}块不具备作用域，所以num声明可以提升出来为：123456789var num;if ( false ) &#123; num = 123;&#125;console.log( num ); // undefiend 例子3：1234567891011121314var num = 123;function foo() &#123; var num = 456; function func() &#123; console.log( num ); &#125; func();&#125;foo(); 3.函数级作用域在JavaScript中唯一能产生作用域的东西是 函数！ 也就是在function(){}内才能有他的作用域，访问权限，o(︶︿︶)o 唉~ 这点要牢记，JavaScript中只有函数和全局作用域！除去默认的全局作用域，也就只有函数能产生作用域了！！ 12345678var a = 1;function test()&#123; var b = 10;&#125; 这里就有着函数的作用域，导致变量提升只能在作用域内，为123456var a;a = 1;function test()&#123; var b; b = 10;&#125;","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"AtomicInteger：支持原子性操作，基于CAS实现了乐观锁","date":"2017-03-29T09:28:42.000Z","path":"2017/03/29/AtomicInteger：支持原子性操作，基于CAS实现了乐观锁/","text":"AtomicInteger,一个提供原子操作的Integer的类。在java.util.concurrent.atomic包中。 一、使用场景在多线程环境中，AtomicInteger的使用场景就是提供一些原子性的数值改变，不会出现多个线程下的数据不一致问题。例如：仓库总量的增减，ID的顺序获取等。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。对于并发情况下，我们加锁的方式通常有两种：悲观锁和乐观锁。 二、悲观锁和乐观锁 悲观锁 在并发情况下，它假设最坏的情况，在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。这种方式将需要事务管理的代码块一律加上同步synchronized，这种独占锁会将其他线程挂起阻塞住，直到该事务结束后才将资源放出。线程的挂起和恢复过程，开销是很大的，当线程被挂起等待时，无法做任何事，而notify()或notifyAll()重新唤醒后又将开始新的资源争用，如果某个线程”人品很差”，一直被阻塞，争用不到资源，事务的执行会等待很久，效率很低。 在计算机组成原理这本书中提到，cpu是时分复用的，cpu的时间片，分配给不同的thread、process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。 小栗子：线程的挂起和恢复执行过程中存在着很大的开销。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。 乐观锁：每次不加锁，假设没有冲突而去完成操作。他的思路是：每次不加锁，认为大家都很自觉，不会发生数据冲突，万一发生冲突就自我重试，重新再去获取新值再来一遍，不影响其他线程，直到成功为止，就不像悲观锁那么自私霸道。对于数据库的增删改查，只有在最后提交的时候才会去检查，通常我们采用一个版本号version字段来检查该线程此时获取的数据是否被修改了，“是否还是往日的她”。每次comit时会检查该线程持有的版本号是否和实际版本号一致，如果不一致说明该数据已经被修改了，此时提交是不安全的，无法保证数据一致性，对于这种冲突，发生就无限循环重试，重新获取新的值和版本号，再在cpu争用中等到调度自己时再去尝试比对提交，直到成功为止。在上面的例子中，某个线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。三、什么是CASCAS就是Compare and Swap的意思，比较并操作。很多的cpu直接支持CAS指令。CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。 JDK1.5中引入了底层的支持，在int、long和对象的引用等类型上都公开了CAS的操作，并且JVM把它们编译为底层硬件提供的最有效的方法，在运行CAS的平台上，运行时把它们编译为相应的机器指令。在java.util.concurrent.atomic包下面的所有的原子变量类型中，比如AtomicInteger，都使用了这些底层的JVM支持为数字类型的引用类型提供一种高效的CAS操作。 四、 AtomicInteger实现CASAtomicInteger 是一个支持原子操作的 Integer 类，就是保证对AtomicInteger类型变量的增加和减少操作是原子性的，不会出现多个线程下的数据不一致问题。如果不使用 AtomicInteger，要实现一个按顺序获取的 ID，就必须在每次获取时进行加锁操作，以避免出现并发时获取到同样的 ID 的现象。 通过两个简单的例子来看一下 AtomicInteger 的优势在哪:普通线程同步: 1234567891011class Test2 &#123; private volatile int count = 0; public synchronized void increment() &#123; count++; //若要线程安全执行执行count++，需要加锁 &#125; public int getCount() &#123; return count; &#125;&#125; 使用AtomicInteger: 1234567891011class Test2 &#123; private AtomicInteger count = new AtomicInteger(); public void increment() &#123; count.incrementAndGet(); &#125; //使用AtomicInteger之后，不需要加锁，也可以实现线程安全。 public int getCount() &#123; return count.get(); &#125;&#125; 从上面的例子中我们可以看出：使用AtomicInteger是非常的安全的.而且因为AtomicInteger由硬件提供原子操作指令实现的。在非激烈竞争的情况下，开销更小，速度更快。 五、 AtomicInteger源码查看接下来通过源码来看AtomicInteger具体是如何由硬件来实现原子操作的。 AtomicInteger继承了Number类并且实现了Serializable接口，支持序列化 1public class AtomicInteger extends Number implements java.io.Serializable &#123;...&#125; 构造函数 1234567891011121314 private volatile int value;/** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */ public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */ public AtomicInteger() &#123;&#125; 可以看出，AtomicInteger提供了空构造函数和赋值构造，对与空构造函数(AtomicInteger count = new AtomicInteger();)，其默认值为0。而赋值构造，其value值是被volatile修饰的int值 volatile 变量可以被看作是一种 “程度较轻的 synchronized” 锁提供了两种主要特性：互斥（mutual exclusion）和可见性（visibility）。① 互斥即一次只允许一个线程持有某个特定的锁，因此可使用该特性实现对共享数据的协调访问协议，这样，一次就只有一个线程能够使用该共享数据。② 可见性要更加复杂一些，它必须确保释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的 —— 如果没有同步机制提供的这种可见性保证，线程看到的共享变量可能是修改前的值或不一致的值，这将引发许多严重问题。 Volatile变量具有 synchronized 的可见性特性，但是不具备原子特性。也就是说线程能够自动发现 volatile 变量的最新值。 下面是他的一些方法12345678910111213141516171819//获取当前的值public final int get();//取当前的值，并设置新的值 public final int getAndSet(int newValue);//获取当前的值，并自增 public final int getAndIncrement();//获取当前的值，并自减public final int getAndDecrement();//获取当前的值，并加上预期的值public final int getAndAdd(int delta); 同理，还有一些与之相反的incrementAndGet、decrementAndGet、addAndGet等，从名称可知， 分别是自增后返回新值，自减后返回新值，加上预期值后返回新值。他们的实现大致一样，只是返回值前者为return current;而后者为return next; 来看看incrementAndGet() 方法，下面是具体的代码。 12345678910111213/** * Atomically increments by one the current value. * * @return the updated value */ public final int incrementAndGet() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return next; &#125; &#125; 通过源码，可以知道，这个方法的做法为先获取到当前的 value 属性值，然后将 value 加 1，赋值给一个局部的 next 变量，然而，这两步都是非线程安全的，但是内部有一个死循环，不断去做compareAndSet操作，直到成功为止，也就是修改的根本在compareAndSet方法里面，compareAndSet()方法的代码如下： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; 我们继续跟踪到compareAndSet()方法调用的compareAndSwapInt()方法，他是一个native方法。 1publicfinal native boolean compareAndSwapInt(Object var1, long var2, int var4, intvar5); compareAndSet 传入的为执行方法时获取到的 value 属性值，next 为加 1 后的值， compareAndSet所做的为调用 sun.misc.Unsafe的 compareAndSwapInt 方法来完成，此方法为 native 方法，compareAndSwapInt 基于的是CPU 的 CAS指令来实现的。所以基于 CAS 的操作可认为是无阻塞的，一个线程的失败或挂起不会引起其它线程也失败或挂起。并且由于 CAS 操作是 CPU 原语，所以性能比较好。 类似的，还有decrementAndGet()方法。它和incrementAndGet()的区别是将 value 减 1，赋值给next 变量。","tags":[{"name":"高并发与多线程","slug":"高并发与多线程","permalink":"http://yoursite.com/tags/高并发与多线程/"}]},{"title":"JQuery插件总结","date":"2017-03-19T14:46:23.000Z","path":"2017/03/19/JQuery插件总结/","text":"一、Jquery Full Page 全屏滚动","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"CSS3入坑记（二）","date":"2017-03-14T05:38:34.000Z","path":"2017/03/14/CSS3入坑记（二）/","text":"一、边框 边框圆角 border-radiusa)border-top-left-radius：水平半径 垂直半径b)border-radius：顺时针四个方向的切圆水平半径/顺时针四个方向的切圆垂直半径 c)单位：百分比(相对于自身宽高)和像素d)最好使用%e)img 也可以使用圆角，但是效果通常不怎么样 边框图片a)路径border-image-sourceb)裁剪border-image-slicec)平铺border-image-repeat:可选value值如下i.repeat平铺（无优化，就是普通的平铺，在四角交界处可能会有误差）ii.round：平铺（优化过的repeat,很完美哦）iii.stretch：拉伸(默认值，宽和高谁长就拉伸谁，不平铺)d)边框宽度：border-image-width:通常设置和裁剪slice一个数值，但是slice没单位，width单位为px eg:先选择一张边框素材图： 由fireworks测量得知一个小方块大小27px，所以border-image-slice值为27，同时，border-image-width值为27px;CSS: 12345678910111213div&#123; width: 500px; height: 400px; border: 1px solid transparent; /*新版chrome浏览器需要先写border，在把border-image属性设置在 border之后才能显示图片边框*/ border-image-source: url(\"images/border.png\"); border-image-slice: 27; border-image-width: 27px; border-image-repeat: round; margin: 100px auto; padding: 2em; box-sizing: border-box;/*内减模式*/&#125; html: 123&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 效果： 二、背景一）backgrounf-size：背景大小，其可选value值如下： 1.背景尺寸：数值，百分比，和普通的图片设置一样 2.cover覆盖：图片等比例放大，保证完全覆盖混盒子，不保证完全显示。会超出，但是这个值使得背景图片，有一定的自适应效果【背景绝对会完全铺满，不留空白，但是有可能会超出部分不显示】 3.contain包含 : 最大化的等比例显示在盒子中。不会铺满盒子，有一定的自适应效果【可能会背景铺不满，有空白】 4.cover,contain都会自适应盒子尺寸,个人偏爱cover一点，因为他不会留白啊 二） background-origin ： 背景原点 a) 默认背景从padding-box开始平铺 b) background-origin 可选value值： border-box、padding-box(默认)、 content-box 效果图： padding-box(默认值) border-box： content-box： 三）background-clip ： 背景裁剪 ,可选属性值如下： a) border-box b) padding-box c) content-box d) 设置谁，超出谁的就裁减掉 e) clip属性值要是比原点的范围大，不起作用 tips1.背景裁剪和背景原点移动，移动web会用到tips2.多背景用逗号隔开tips3.背景颜色写在最后或者单独写 三、渐变：还是属于背景，是颜色渐变一） 线形渐变【linear-gradient】 (等同于background-image)【用的是to】 1.设置完gradient之后仍然可以当作background-image 来设置宽高，repeat之类属性 2.background-image：linear-gradient（方向，起始颜色，终止颜色）； 方向： to right：从左到右 to left 到左 to top 到上 方向还可以定义角度 ，单位为 deg 3.多颜色渐变(百分比就是盒子从这个方向开始，进行到百分之多少就换颜色)【渐变是模糊的样子】 1background-image: linear-gradient(to right,red 0%,blue 30%,yellow 60%); 4.颜色突变【图片就是色彩分明】 1background-image: linear-gradient(to right,red 0%,red 30%,blue 30%,blue 60%,yellow 60%,yellow 100%); （注：背景渐变可以当作background-image来设置background-size、repeat等） 二） 径向渐变【radial-gradient】【用的是at】 1.radial-gradient（辐射半径 中心点位置，起始颜色，终止颜色） 2.中心点颜色，at left，right，top，bottom，center 3.at 50px（水平距离） 50px（垂直距离） 径向渐变就是在盒子某一处为圆心，设置好半径来辐射 四、过渡（这个可厉害了!CSS3实现动画啊！） 1.transition：过渡属性 过渡持续时间 加速度（linear：匀速） 延迟时间 a)transition-property：过渡属性 b)transition-duration：过渡持续时间 (几秒动画结束) c)transition-timimg-function：加速度如何，其取值如下： 1.linear：匀速 2.ease：减速 3.ease-in：加速 4.ease-out：减速 5.ease-in-out：先加速后减速 d)transition-delay：过渡延迟 2.如果需要所有属性都过渡 a)transition-property：all 【写all性能不好】 可以写成这样:transition:transform 2s;意思为，只有transform(rotate,translate,scale)变换给他过渡,其他的宽高背景色之类的不给过渡。 最后：简写方法： 1transition:all 0.7s ease-in-out; 五、2D变换 1.transform:其value值如下： 缩放（scale）、位移（translate）、旋转（rotate） tips:变换后不会影响其他盒子，很乖巧吧！~ 2.缩放scale（倍率） a)不可以写百分数 b)大于1是放大，小于1缩小 (eg: transform:scale(2,0.5);【水平放大2倍，竖直缩小一半】) c)写一个值，宽高等比缩放 d)内容也会等比缩放e)写两个值，第一个是水平缩放倍率，第二个是垂直缩放倍率 3.位移translate（） a)右移正数，左移负数（右下为正，左下为负） b)第一个值水平移动，第二个值垂直移动距离 c)可写百分比数值，相对与自身的尺寸d)盒子在父盒子中居中方法【translate引申运用！】 width: 300px; height: 150px; ``` ```cssleft: 50%; 12margin-left: -150px; ``` ```css /*推荐方法，利用translate位移向左移动50%*/ left:50%; transform:translate(-50%); 4.旋转：rotate（角度） a) 正值顺时针，负值逆时针 b) 旋转中心：transform-origin：水平坐标 垂直坐标 c) 默认旋转中心：几何中心 未完待续。。。","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"CSS3入坑记(一)","date":"2017-03-13T16:22:15.000Z","path":"2017/03/14/CSS3入坑记(一)/","text":"一、给力的选择器 1.标签选择器。 类名选择器，id选择器。后代选择器，标签指定（交集）选择器 。并集选择器，子代选择器，通配符等基础的选择器 a)div+p：选择div后第一个兄弟p（紧跟div）还是兄弟关系哦 b)div~p：选择div后所有兄弟P 大家都是兄弟，给良辰一个面子 2.属性选择器 tips：通过标签属性来选择 ①div[属性] ②div[class^=‘aa’]：有class属性并且属性属性值以aa开头③div[class$=‘aa’]：有class属性并且属性属性值以aa结尾④div[class*=‘aa’]：有class属性并且属性属性值包含aa 3.伪类选择器 伪类，伪元素都可以修饰dom元素，但是伪类还是类，对整个类进行修饰 3.1 普通伪类 ①：link ：正常状态 ②：visited 已访问过的链接 ③：hover 鼠标经过 ④：action 点击 ⑤:lvha 3.2 结构伪类 所选到的标签类型必须是E否则无效 E ：first-child：选择E父盒子中的第一个E E ：last-child：选择E父盒子中的最后一个E E ：nth-child（5）：选择E父盒子中的第5个E（标号从1开始） E ：nth-child（odd/even）：选择E-父盒子中编号为奇数/偶数的E标签 a) E ：nth-child（2n）：选择E父盒子中的所有编号为偶数的E b) E：nth-child（2n+1）：选择E父盒子中的所有编号为奇数的E E ：nth-child（n）：选择E父盒子中的所有E a) n &lt; 1无效 E ：nth-child（n）：选择E父盒子中的所有E，-n全不选 E ：nth-child（-n+5）：选择E父盒子中的前五个E标签 E ：nth-last-child(1):倒数第一个 E ：nth-last-child（-n+5）：选择倒数第五个 E ：nth-child（7n）：选择编号为7的倍数的标签 E ：nth-child（7n-1）：选择编号为7的倍数减1的标签 3.3状态伪类 E:empty 如果盒子是空的就会被选中 E:target 通常和锚点配合使用，比如一个h2标签代表一段的标题，然后通过锚点到达该处，该h2就会显示出相应的样式 4.伪元素 伪元素只是元素，他只能修饰被修饰者内部的某一部分内容，而非整个类 1) 伪就是假的，通过css模拟出html效果，必须有content属性 2) 伪元素虽然可以单:，但是在CSS3规范中规定伪类用:，伪元素用双:: 3) ::before，在之前添加 123div::before&#123; content : \"在前面\"; &#125; 4) ::after，在之后添加 1234div::after&#123; content : \"在后面\"; color: #f00; &#125; 5) 产生的伪元素相当于div的子元素 6) 伪元素可以使用标签的属性(啥宽、高、bgc、display之类的)，如下eg: css:123456789101112span::before&#123; content: '今天'; background: paleturquoise; display: inline-block; width: 60px; height: 30px; &#125; span::after&#123; content: '真好'; background: darkseagreen; &#125; /*必须要写content*/ html: 123&lt;body&gt;&lt;span&gt;天气&lt;/span&gt;&lt;/body&gt; 效果： ::bofore和::after可以做图标放在字体前后 5 伪元素选择器选中盒子里的某一块区域1) ::frist-letter 选择第一个字母2) ::frist-line 选择第一行3) ::selection 选择区域的样式 (网页上选中一段文字一般是蓝色框和白色背景，可以自己换颜色)a)一般只设置背景颜色和字体颜色4) 通常用::first-letter和flaot:left以及字体加大设置首字下沉，如下：二、颜色的升级 设置透明色的话 传统的opcity属性会被子代继承，且子代的opacity属性不能修改，多可怕 transparent；完全透明，无法修改属性值，直接没了，你也太狠了 CSS3引入新的颜色方式 RGBA模式 a)红绿蓝 b)alpha（透明度） HSLA模式a)H:色相、色调 0-360（红橙黄绿青蓝紫）b)S:饱和度 0-100%c)L:明度 、亮度 0-100%d)A:透明度 0-1 tips：有颜色的地方都可以用半透明 三、文本阴影的引入 文本阴影a)text-shadow：水平距离 垂直距离 模糊程度 颜色*（注意：文本阴影前三个值单位为px，文本可以设置3个px属性，而box-shadow可以再多一个px属性为阴影面积）b)左下为正，右上为负c)一个文本可以有多个阴影，用逗号隔开，常用一黑一白的阴影来做凹凸字(黑白阴影模拟光照) 四、CSS3盒子模型(重点) 传统盒子模型传统盒子中，我们看到的：a)宽度 = padding+border+widthb)内容区域大小不变c)总体大小变化 CSS3盒子模型a) 可以给盒子设置box-sizing属性属性值为：content-box/padding-box/border-box 设置谁，谁不变 content-box：内容盒子，外加模式，整个盒子撑大,内容盒子不变，加大边距和边框会加大总体大小，内容区域大小不变 border-box：边框盒子，内减模式，整个盒子大小不变，内容盒子减小。加内边距和边框只会减小内容的大小 五、私有化前缀有些CSS属性浏览器无法识别时，可以在属性值前加上私有化前缀，以让浏览器识别。 可以解决兼容性 问题 -webkit- 谷歌、苹果浏览器内核 -moz- 火狐浏览器内核 -ms- IE浏览器内核 -o- 欧鹏浏览器内核 兼容性写法示例： 123456background: -webkit-linear-gradient(left,aquamarine,skyblue); background: -moz-linear-gradient(left,aquamarine,skyblue); background: -ms-linear-gradient(left,aquamarine,skyblue); background: -o-linear-gradient(left,aquamarine,skyblue); background: linear-gradient(left,aquamarine,skyblue); /*最后一行加上正常的不加私有化的*/ tips1：最后要加无前缀的样式tips2：加私有化前缀如果也无法解决，放弃 tips3：这里只是做个实例，一般线性渐变背景写法为： 1background: linear-gradient(to right,yellow 0%,pink 30%,blue 60%,red 100%); 接下来，让我们在CSS3入坑记（二）再相会！","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Html5入坑记","date":"2017-03-11T09:30:07.000Z","path":"2017/03/11/Html5入坑记（一）/","text":"一、标准改变Html4.0 网页开发： html -&gt; 结构 4.0 Css -&gt; 样式 2.0 Js -&gt; 行为 用户交互HTML5.0 html4.0 升级版: Html5 -&gt; 结构 5.0 css3 -&gt; 样式 js -&gt; 行为 js API 有所增强 地理定位 web存储 拖拽 HTML5并不仅仅只是做为HTML标记语言的一个最新版本，更重要的是它制定了Web应用开发的一系列标准，成为第一个将Web做为应用开发平台的HTML语言。广义概念：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器呈现技术得到了一个飞跃发展和广泛支持，它包括：HTML5，CSS3，Javascript，API在内的一套技术组合 H5范称HTML + CSS3 + JS优点：HTML5的优点 二、Html结构 新增语义化标签①语法规范，去除冗余内容，书写规则简洁、清晰。 dtd简洁、标签不用写关闭符号、双标签省略结束标签、html、head、body、colgroup、tbody可以完全省略 实际开发中应规范书写，不建议太随意 ！如图 ②新增语义标签12345678910&lt;nav&gt; //表示导航&lt;header&gt; //表示页眉&lt;footer&gt; //表示页脚&lt;section&gt; //表示区块&lt;article&gt; //表示文章 如文章、评论、帖子、博客&lt;aside&gt; //表示侧边栏 如文章的侧栏&lt;figure&gt; //表示媒介内容分组 与 ul &gt; li 做个比较&lt;mark&gt; //表示标记 (带用“UI”，不怎么用)&lt;progress&gt; //表示进度 (带用“UI”，不怎么用)&lt;time&gt; //表示日期本质上新语义标签与div、span没有区别，只是其具有表意性，使用时除了在HTML结构上需要注意外，其它和普通标签的使用无任何差别对于传统的网页布局，采用div+css，给div给定header,nav,section,aside,article,footer等class，h5新增了该语义化标签，便于理解和网站seoH5经典网页布局123456789101112&lt;!-- 头部 --&gt;&lt;header&gt;&lt;/header&gt;&lt;nav&gt;&lt;/nav&gt;&lt;!-- 主体部分 --&gt;&lt;section&gt; &lt;!-- 文章 --&gt; &lt;article&gt;&lt;/article&gt; &lt;!-- 侧边栏 --&gt; &lt;aside&gt;&lt;/aside&gt;&lt;/section&gt;&lt;!-- 底部 --&gt;&lt;footer&gt;&lt;/footer&gt;h5兼容IE处理l less 小于t than 比e equal 等于g great 大于三、表单新特性——–①输入类型123456789101112email 输入email格式tel 手机号码 url 只能输入url格式number 只能输入数字search 搜索框range 范围 滑动条color 拾色器time 时间date 日期 不是绝对的--datetime 时间日期month 月份week 星期部分类型是针对移动设备生效的，且具有一定的兼容性，在实际应用当中可选择性的使用。 ②新的表单标签 datalist : 可以和input关联起来,变成特殊的select 12345678910&lt;input type=\"text\" list=\"car\" title=\"\"&gt;&lt;!--可以用datalist和input关联起来--&gt;&lt;datalist id=\"car\"&gt; &lt;option&gt;宝马&lt;/option&gt; &lt;option&gt;宝骏&lt;/option&gt; &lt;option&gt;宝强&lt;/option&gt; &lt;option&gt;奥拓&lt;/option&gt; &lt;option&gt;奥迪&lt;/option&gt; &lt;option&gt;大众&lt;/option&gt;&lt;/datalist&gt; keygen 生成加密字符串 1234keygen 元素的作用是提供一种验证用户的可靠方法。 keygen 元素是密钥对生成器（key-pair generator）。当提交表单时，会生成两个键，一个是私钥，一个公钥。 私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。公钥可用于之后验证用户的客户端证书（client certificate）。 服务器获取客户端的私钥后可用来和公钥比较判断是否被劫持过。 output 仅仅在页面表单里展示数据，没啥用，还不能提交 meter 表示度量器，不建议用作进度条 progress Min-width 三、表单属性 placeholder 占位符 multiple 文件上传多选或多个邮箱地址 autocomplete 自动完成，用于表单元素，也可用于表单自身(on[默认开启]/off) ‘ autofocus：自动获取焦点 novalidate 关闭验证，可用于form标签 required 必填项 pattern 正则表达式 验证表单 1手机号:&lt;input type=\"tel\" name=\"tel\" required=\"required\" pattern=\"^(\\+86)?1[3,5,8](\\d&#123;9&#125;)$\"&gt; 四、表单事件 oninput 用户输入内容时触发，可用于移动端输入字数统计 oninvalid 验证不通过时触发 五、多媒体 之前在网页上播放多媒体必须依赖第三方插件 mediaplay、flash插件等 现在在H5里面提高了视频、音频标签，可以不求人啦 audio音频标签、video视频标签 a)controls:播放控制条 b)autoplay：自动播放 c)loop：循环播放 d)音频支持：mp3/wav/ogg e)视频支持：mp4、ogg、webm tips：vidio格式为行内块 f)source引用方式来做兼容 123456&lt;audio controls&gt; &lt;source src = \"music.mp3\"&gt; &lt;source src = \"music.ogg\"&gt; &lt;source src = \"music.wav\"&gt; 抱歉，你的浏览器不支持音频标签 &lt;/audio&gt; 六、dom扩展Tips:Html5对dom进行了扩展，使得多出很多api来操作document(dom)，跟JQuery一样方便，还不用引入JQ的类库，妈妈再也不用担心我忘记带JQ类库啦! document 文档对象①类操作 1234561.var new = document.querySelector（“选择器”）//只会选择符合条件的第一个元素2.var newArr = document.querySelectorAll(“选择器”)3.box.classList.add(“类名”)：//添加类名4.box.classList.remove(“类名”)://删除类名5.box.classList.contains（“类名”）：//是否包含某个类名6.box.classList.toggle(“类名”)://切换类名 ②自定义属性（假设有一个class为box的div）1.自定义属性必须以data开头（格式：data-属性名=””） 1eg:&lt;div class=&quot;box&quot; data-myData=&quot;lalala&quot;&gt;&lt;/div&gt; 2.获取标签属性 a)原有属性 .box.属性名 b)自定义属性 .box.dataset[‘data后的部分’] eg: .box.dataset[‘myData’] 特别注意！:如果自定义属性的属性名为data-my-name，那么获取的时候要 .box.dataset[“myName”]","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"JQuery动画之动画队列和stop方法","date":"2017-03-06T12:08:39.000Z","path":"2017/03/06/JQuery动画之动画队列和stop方法/","text":"在介绍动画队列之前，先谈谈js的单线程和浏览器的事件驱动。 Javascript是单线程的【转】因为JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，在某个特定的时刻只有特定的代码能够被执行，并阻塞其它的代码。而浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，会创建事件并放入执行队列中。javascript引擎是单线程处理它的任务队列，你可以理解成就是普通函数和回调函数构成的队列。当异步事件发生时，如mouse click, a timer firing, or an XMLHttpRequest completing（鼠标点击事件发生、定时器触发事件发生、XMLHttpRequest完成回调触发等），将他们放入执行队列，等待当前代码执行完成。 异步事件驱动前面已经提到浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生的时候，它就进入事件队列。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。每个浏览器具体实现主事件队列不尽相同，在此不赘述。 浏览器不是单线程的虽然JS运行在浏览器中，是单线程的，每个window一个JS线程，但浏览器不是单线程的，例如Webkit或是Gecko引擎，都可能有如下线程： javascript引擎线程 界面渲染线程 浏览器事件触发线程 Http请求线程 很多人弄不清，如果js是单线程的，那么谁去轮询大的Event loop事件队列？答案是浏览器会有单独的线程去处理这个队列。 Ajax异步请求是否真的异步? 很多人不清楚，既然说JavaScript是单线程运行的，那么XMLHttpRequest在连接后是否真的异步? 其实请求确实是异步的，这请求是由浏览器新开一个线程请求（见前面的浏览器多线程）。当请求的状态变更时，如果先前已设置回调，这异步线程就产生状态变更事件放到 JavaScript引擎的事件处理队列中等待处理。当浏览器空闲的时候出队列任务被处理，JavaScript引擎始终是单线程运行回调函数。javascript引擎确实是单线程处理它的任务队列，能理解成就是普通函数和回调函数构成的队列。 总结一下，Ajax请求确实是异步的，这请求是由浏览器新开一个&gt;线程请求，事件回调的时候是放入Eventloop单线程事件队列等候处理。 setTimeout(func, 0)为什么有时候有用？ 写js多的人可能发现，有时候加一个setTimeout(func, 0)非常有用，为什么？难道是模拟多线程吗？错！前面已经说过了，javascript是JS运行在浏览器中，是单线程的，每个window一个JS线程，既然是单线程的，setTimeout(func, 0)神奇在哪儿？那就是告诉js引擎，在0ms以后把func放到主事件队列中，等待当前的代码执行完毕再执行，注意：重点是改变了代码流程，把func的执行放到了等待当前的代码执行完毕再执行。这就是它的神奇之处了。它的用处有三个： ①让浏览器渲染当前的变化（很多浏览器UI render和js执行是放在一个线程中，线程阻塞会导致界面无法更新渲染） ②重新评估”script is running too long”警告 ③改变执行顺序 接下来，我们来聊聊JQuery的动画队列。【原】在用户触发动画事件时，也将会把动画方法放入队列中，以队列的方式执行。如下图，该粉色的div盒子，可以由上方的按钮触发滑入滑出动画。(最后一个停止先不看) 12345678910111213&lt;script&gt; $(document).ready(function () &#123; $(\"button:eq(0)\").click(function () &#123; $(\"div:eq(0)\").slideDown(\"slow\"); &#125;); $(\"button:eq(1)\").click(function () &#123; $(\"div:eq(0)\").slideUp(\"slow\"); &#125;); $(\"button:eq(2)\").click(function () &#123; $(\"div:eq(0)\").stop(true,true); &#125;); &#125;); &lt;/script&gt; 当依次点击滑入、滑出按钮时，会将slideDown和slideUp方法依次放入事件队列中，待处理完之前的事件后，会按两个方法入队列的顺序依次执行，也就是先执行slideDown再执行slideUp方法。如果我们将动画的执行时间设置的再慢些(动画方法中的参数:fast:200ms,normal:400ms,slow:600ms)，如3000ms时，你会看到该盒子会慢慢地展开，等完全展开完毕后才会再收起，这就是按入队列顺序执行动画。接下来就可以聊聊JQuery中的stop方法。该方法有三个参数(type,clearQueue, gotoEnd)，第一个type参数先不谈，方法的clearQueue, gotoEnd参数分别为什么意思呢？让我们通过实验来了解。 stop方法的上述2个参数默认都为false。 默认false,false ① 第一种情况:false,false (后续动画不停止,当前动画不继续执行,原地停下) 1$(\"div:eq(0)\").stop(false,false); ②第二种情况:true,false(后续动画停止，当前动画不继续执行,原地停下) 1$(\"div:eq(0)\").stop(true,false); ③第三种情况:false,true(后续动画不停止,当前动画立马执行完成) 1$(\"div:eq(0)\").stop(false,true); ④第四种情况:true,true; (后续动画停止,当前动画立马执行完成) 1$(\"div:eq(0)\").stop(true,true) 看到这，应该已经明白。第一个clearQueue参数代表是否停止后续动画(true表示停止后续动画),第二个 gotoEnd代表当前动画是立即完成还是直接原地停下(true表示当前动画立马执行完成，false表示当前动画立马原地停下)","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"JQuery选择器小结","date":"2017-03-05T07:45:53.000Z","path":"2017/03/05/JQuery选择器小结/","text":"先贴张图 “引号内选择器”以下选择器，都在$(“”)的双引号内写 一丶基本选择器 1234$(\"#top\") //id选择器，返回单个$(\"div\") //标签选择器，返回数组 $(\".box\") //类选择器，返回数组 $(\"*\") // 选择文档中所有元素，返回数组 二丶层级选择器 1234$(\"form input\") //选择所有的后代 $(\"div &gt; .box\") //选择子代(亲儿子)$(\"label + input\") //[返回]label标签后面直接跟一个input标签的所有[input标签] $(\"#prev ~ div\") //同胞选择器，[返回]id为prev的所有同父[div同胞] 三丶基本过滤选择器 123456789101112$(\"tr:even\") //返回偶数tr（注意：返回数组，序号从0开始,0,2,4..） $(\"tr:odd\") //返回奇数tr $(\"td:eq(2)\") //索引等于2的td $(\"td:gt(4)\") //索引大于4$(\"td:ll(4)\") //索引小于4 $(\"tr:first\") //所有tr元素的第一个 $(\"tr:last\") //所有tr元素的最后一个 $(\"input:checked\") //所有被选中的input$(\"input:not(:checked)\") //所有没被选中的input$(\":header\") //所有的标题元素(h1-h6)$(\"div:animated\") //所有正在运动的div 四丶内容过滤选择器 (根据内容来选择) 1234$(\"div:contains('github')\") //选择所有div中含有github文本的[div]$(\"td:empty\") //选择所有内容为空（也不包括文本节点）的[td]$(\"div:has(p)\") //选择所有含有p标签的[div元素] $(\"td:parent\") //选择已为人父的[td](有子标签或文本都算为人父) 五丶可视化过滤选择器 12$(\"div:hidden\") //被hidden的div元素 $(\"div:visible\") //可视化的div元素 六丶属性过滤选择器 (根据属性来选择) 1234567$(\"div[id]\") //选择所有含有id属性的div元素 $(\"input[name='news']\") //选择name属性为'news'的input元素$(\"input[name!='newsletter']\") //选择name属性不为'news'的input元素$(\"input[name^='news']\") //选择name属性以'news'开头的input元素 $(\"input[name$='news']\") //选择name属性以'news'结尾的input元素 $(\"input[name*='color']\") //选择name属性包含'color'的input元素$(\"input[id][name$='color']\") //多个属性联合选择 七丶子元素过滤选择器 123$(\"div span:first-child\") //返回所有的div元素的第一个子节点的数组 $(\"div span:last-child\") //返回所有的div元素的最后一个节点的数组 $(\"div button:only-child\") //只有唯一一个子节点的所有子节点的数组 八丶表单元素选择器： 1234567891011$(\":input\") //所有的表单元素，input, textarea, select等 $(\":text\") //所有的text input元素 $(\":password\") //所有的password input元素 $(\":radio\") //所有的radio input元素 $(\":checkbox\") //所有的checkbox input元素 $(\":submit\") //所有的submit input元素 $(\":image\") //所有的image input元素 $(\":reset\") //所有的reset input元素 $(\":button\") //所有的button input元素 $(\":file\") //所有的file input元素 $(\":hidden\")//所有hidden input元素 九丶表单元素过滤选择器 1234$(\":enabled\") //选择所有的可操作的表单元素 $(\":disabled\") //所有的不可操作的表单元素 $(\":checked\") //所有的被checked的表单元素 $(\"select option:selected\") //所有的select的子元素option中被selected的option “方法调用选择器”以下都为【方法】，需要在$(“”)外.方法() 1234567.find(selector) //后代查找.children(selector) //子代查找.parent(selector) //查找亲父亲.siblings(selector) //查找所有兄弟.eq(index) //相等查找.prev(selector) //查找前一个兄弟.next(selector) //查找后一个兄弟 1注：方法中有selector，为选择器的意思，如果方法不加参数，默认选择，加了参数就多了一层筛选，比如$(\".box\").find()为查找class为box的所有后代，而$(\".box\").find(\"ul\")为查找它的所有ul后代而非全部后代","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"JQuery","slug":"JQuery","permalink":"http://yoursite.com/tags/JQuery/"}]},{"title":"第二章 Java内存区域与内存溢出异常","date":"2017-03-02T06:10:10.000Z","path":"2017/03/02/第二章-Java内存区域与内存溢出异常/","text":"2.2 运行时数据区域 图1.1 Java虚拟机运行时数据区 2.2.1 程序计数器 (线程私有) 程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器，字节码解释器通过改变这个计数器的值来取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都依赖这个计数器。java多线程是通过处理器轮流切换并分配处理器执行时间的方式来实现，在一个处理器，或者多核处理器的一个内核中，都只会执行一条线程中的指令，为了在java多线程切换后能回到正确的执行位置，所以程序计数器是每个线程独立独占的。 线程执行：Java方法： 计数器记录的是正在执行的虚拟机字节码指令的地址。Native方法： 计数器为空。此内存区域是唯一一个在虚拟机规范中没有规定任何OOM情况的区域。 2.2.2 Java虚拟机栈 (线程私有) 生命周期与线程相同,虚拟器栈描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧用于存储 局部变量表、操作数栈、动态连接、方法入口等。每一个方法从调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：存放编译期可见的各种数据类型(boolean,byte,char,short,int,float,long,double)、对象引用(reference类型)、returnAddress类型(指向一条字节码指令的地址) Jvm栈有两种异常情况：StackOverflowError：线程请求的栈深度大于虚拟机允许的深度OutOfMemoryError：虚拟机栈可以动态扩展，当扩展时无法申请到足够内存抛出 2.2.3 本地方法栈 (线程私有) 与虚拟机栈作用非常相似，不过执行的是本地方法，语言、数据结构都没强制规定，为虚拟机使用到的Native方法服务。也会抛出StackOverflowError和OutOfMemoryError 2.2.4 Java堆 (线程共有) 在虚拟机启动时创建，是Java虚拟机管理的最大一块内存，也是垃圾收集器管理的主要区域(所以很多时候也称作GC堆)。此内存区域唯一目的就是：存放对象的实例。 从内存回收角度，Java堆可以细分为：新生代和老年代，再细点就是 Eden空间、Form Survivor空间、To Survivor空间从内存分配角度，线程共享的Java堆可以划分出： 多个线程私有的分配缓冲区(TLAB，Thread Local Allocation Buffer) 不论怎么划分，都与存放内容无关，存放的都是对象实例，划分都为了更好的回收内存或更快地分配内存。 —未完待续","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"http://yoursite.com/tags/《深入理解Java虚拟机》/"}]},{"title":"JVM常用参数种类","date":"2017-03-02T05:22:09.000Z","path":"2017/03/02/JVM常用参数种类/","text":"一、配置堆区(-Xms、-Xmx、-XX:newSize、-XX:MaxnewSize、-Xmn)①-Xms：表示Java虚拟机堆区内存初始内存分配的大小，通常为操作系统可用内存的1/64大小即可，但仍需按照实际情况进行分配。 ②-Xmx：表示Java虚拟机堆区内存可被分配的最大上限，通常为操作系统可用内存的1/4大小。但是开发时，通常会将-Xms与-Xmx两个参数配置相同的值，其目的是为了能够在Java垃圾回收机制清理完堆区后不需要重新分配隔离计算堆区大小而浪费资源。一般对堆区的内存分配只需配置上述两个参数(-Xms,-Xmx)即可，但如果想细化，可配置以下三个参数(-XX:newSize、-XX:MaxnewSize、-Xmn) 对堆区进一步细分。 1)-XX:newSize：新生代内存的大小，应小于-Xms的值2)-XX:MaxnewSize：由字面意思可知，新生代可被分配的最大内存，应小于-Xmx的值3)-Xmn：对上面两个参数同时配置，即 -Xmn = -XX:newSize = -XX:MaxnewSize 在JDK1.4以后才可用-Xmn这个很厉害的参数 二、配置非堆区①-XX:PermSize：表示非堆区初始内存分配大小.(Permanent Size)持久化内存 ②-XX:MaxPermSize：表示非堆区分配的最大内存上限 注意！在配置之前要慎重考虑该非堆区内存大小，因为此处是不会被Java垃圾回收机制进行处理同时，最大堆内存+最大非堆内存 &lt; 操作系统可用内存 eg示例: 1VM参数：-verbose : gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX : SurvivorRatio = 8 表示为：Java堆大小为20M，不可扩展，10M给新生代，10M给老年代，新生代中Eden区： Survivor区 = 8：1新生代可用总空间为: Eden区 + 1个Survivor区 即 10M * 9/10 = 9M","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"http://yoursite.com/tags/读书笔记/"},{"name":"JVM","slug":"JVM","permalink":"http://yoursite.com/tags/JVM/"}]},{"title":"正则表达式小结 ","date":"2017-03-01T15:04:47.000Z","path":"2017/03/01/正则表达式小结/","text":"一、创建方式js中，创建正则表达式的两种方式： 121.通过构造函数定义var 变量名= new RegExp(/表达式/); 122.通过直接量定义var 变量名= /表达式/; 二、五大内置对象1.预定义类① .除了换行和回车符(\\r\\n)其他的都可以 12console.log(/./.test(\"\\n\\r\"));//false console.log(/./.test(\"sa35490df574!@@$\"));//true ②\\d数字才能匹配 12console.log(/\\d/.test(\"132465465\"));//trueconsole.log(/\\d/.test(\"abs\"));//false ③\\D非数字才能匹配 12console.log(/\\D/.test(\"132465465\"));//false console.log(/\\D/.test(\"abs\"));//true ④\\s空格才能匹配 12console.log(/\\s/.test(\" \"));//true console.log(/\\s/.test(\"sad\"));//false ⑤\\S非空格才能匹配 12console.log(/\\S/.test(\" \"));//falseconsole.log(/\\S/.test(\"sad\"));//true ⑥\\w对单词的匹配12\\w：单词才能匹配，匹配字母或数字或下划线 [a-zA-Z_0-9] 单词字符\\W：非单词才能匹配[^a-zA-Z_0-9] 非单词字符 ⑦\\d代表单词的开头和结尾 1/\\dstudy\\d/ 2.简单类 12345678①/string/.test(\"string\") //中间是任意字符串，只要完整包含他即可(有他就行，完整的他)console.log(/git520/.test(\"gi\"));//fasleconsole.log(/git520/.test(\"asdgit520#$\"));//trueconsole.log(/git520/.test(\"052tig\"));//false 反向不行②/[string]/.test(\"string\") //[]整体对应一个字符，如[abc]，只要有[string]内的任意一个字符，都可以 console.log(/[520git]/.test(\"ilove\"));//true 3.负向类 123456 //[^string] 对括号内的字符取反，不够和正好返回false，多了和没有返回true(eg:[^abc]中，只有test a,ab,abc都返回false,其他的都是true)console.log(/[^abc]/.test(\"a\"));//falseconsole.log(/[^abc]/.test(\"ab\"));//falseconsole.log(/[^abc]/.test(\"abc\"));//falseconsole.log(/[^abc]/.test(\"abs\"));//true//就是/[^abc]/.test() 只要test 的是a,ab,abc就错,其他的都对 4.范围类 123456//只要存在字符在这个范围内的都行console.log(/[a-c]/.test(\"b\"));//trueconsole.log(/[a-c]/.test(\"ss\"));//falseconsole.log(/[a-c]/.test(\"sasd\"));//true 5.组合类 123456789//组合起来，存在这个范围内的字符都可以,一个[]就代表一个字符console.log(/[a-c1-3]/.test(2));//trueconsole.log(/[a-c1-3]/.test(\"a\"));//trueconsole.log(/[a-c1-3]/.test(\"abs23fz\"));//trueconsole.log(/[a-c1-3]/.test(\"z5\"));//true 三、正则边界 1.正则边界 12345//1.以^开始，以$结尾，代表精确匹配//注：^只有在[]里表示取反。在//表示正则的开头console.log(/^rick$/.test(\"rick\"));//trueconsole.log(/^rick$/.test(\"rickl\"));//fasleconsole.log(/^rick$/.test(\"ric\"));//false 四、量词 1.量词 ❤（多个字母，重复最后一个）❤ 12345678910111213141516171819202122232425// * 贪婪 大于等于0// + 懒惰 大于等于1// ? 占有 要么0要么1console.log(/^a*$/.test(\"\"));//true 0次可以console.log(/^a*$/.test(\"a\"));//trueconsole.log(/^a*$/.test(\"aaaa\"));//trueconsole.log(/^a*$/.test(\"aaab\"));//false 因为^$控制了边界内只能有大于等于0个aconsole.log(/^a*$/.test(\"b\"));//false b更错了console.log(/^zxcv*$/.test(\"zxcvv\"));//true 多个字母，重复最后一个console.log(/^zxcv*$/.test(\"zxc\"));//true 大于等于0，0个也可以console.log(/^zxcv*$/.test(\"zxzv\"));//false 边界定义了，边界内必须要完全匹配 // &#123;&#125;重复多少次的意思，&#123;n&#125; n次 &#123;n,&#125; n次即以上 &#123;n,m&#125; n&lt;=x&lt;=m// * &#123;0,&#125;// + &#123;1.&#125;// ? &#123;0.1&#125;// x|y x或者y //()括号：提高权限，优先计算 | :前后只要有一个符合即可console.log(/(abc)|(xyz)/.test(\"abcq\"));//trueconsole.log(/(abc)|(xyz)/.test(\"sxyz\"));//trueconsole.log(/(abc)|(xyz)/.test(\"abxy\"));//false 都没有完整符合abc或xyz中的一个console.log(/(abc)|(xyz)/.test(\"ab\"));//false 同上 五、练习 1.练习 12//eg: 0562-2812914 (0开头，4位)-(2开头，7位) var RegExp = /^0\\d&#123;3&#125;-2\\d&#123;6&#125;$/; —未完待续","tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"springmvc使用hibernate-validator校验框架实现后端校验","date":"2017-02-28T05:20:18.000Z","path":"2017/02/28/springmvc使用hibernate-validator校验框架实现后端校验/","text":"一 springmvc校验springmvc使用JSR-303校验规范，JSR-303是javaEE6的规范。 springmvc具体使用hibernate-validator校验框架（和hibernate的ORM没有关系），hibernate-validator基于javabean的属性校验。 二 实现步骤① 添加jar包支持 本例使用hibernate-validator 4.3.0.Final版本 maven的pom文件引入以下内容即可 123456&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator --&gt;&lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;4.3.0.Final&lt;/version&gt;&lt;/dependency&gt; jboss-logging和validation-api为其依赖。 ② 在springmvc的处理器适配器中配置validator：1&lt;mvc:annotation-driven validator=\"validator\"/&gt; 定义validator的bean 1234567891011121314151617181920&lt;!-- 定义校验器 --&gt; &lt;bean id=\"validator\" class=\"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean\"&gt; &lt;!-- 校验器 --&gt; &lt;property name=\"providerClass\" value=\"org.hibernate.validator.HibernateValidator\" /&gt; &lt;!-- 指定校验使用的资源文件，如果不指定则默认使用classpath下的ValidationMessages.properties--&gt; &lt;property name=\"validationMessageSource\" ref=\"messageSource\" /&gt; &lt;/bean&gt; &lt;bean id=\"messageSource\" class=\"org.springframework.context.support.ReloadableResourceBundleMessageSource\"&gt; &lt;!-- 资源文件名 --&gt; &lt;property name=\"basenames\"&gt; &lt;list&gt; &lt;value&gt;classpath:CustomerValidationMessages&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 资源文件编码格式 --&gt; &lt;property name=\"fileEncodings\" value=\"utf-8\"/&gt; &lt;!-- 对资源文件内容缓存时间，秒 --&gt; &lt;property name=\"cacheSeconds\" value=\"120\"/&gt; &lt;/bean&gt; ③ 在需要校验的javaben实体类中添加相关校验注解，此处以Items这个po类为例 123456789public class Items &#123; @Size(min=1,max=30,message=\"&#123;item.name.length&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) @NotNull(message=\"&#123;item.name.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private String name; private String pic; @NotNull(message=\"&#123;item.createdate.notnull&#125;\",groups=&#123;ItemsValidationForEdit.class&#125;) private Date createtime; 相关的校验规则由注解名称即可理解，这里解释下注解内的属性含义。message为出现错误时的提示信息，groups为将我们的校验器分组，因为po类是共用的，可能同一个字段在不同的场景下有不同的校验需求，所以将其分组，在controller中进行校验时，可指定分组，来进行校验。分组groups中的XXX.class为定义的一个“空的interface”，没有含义，仅仅只是为了分组。 在po类中利用注解进行校验分类和定义后，可以在后台进行校验，一般选择在service层，因为判断数据合法性属于业务需求，可是在有些情况下，对于用户的体验性来说，如果在controller就进行数据合法性校验，如果不合法可以直接返回，不调用service，响应稍微快些，用户体验好。所以此例中在controller层进行校验。 ④ 在后台通过注解校验 12345678910111213141516// 修改商品提交 @RequestMapping(\"/saveItems\") public String saveItems(Model model, Integer id, @Validated(value = &#123; ItemsValidationForEdit.class&#125;) Items item, BindingResult bindingResult) throws Exception &#123; if (bindingResult.hasErrors()) &#123; List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors(); model.addAttribute(\"allErrors\", allErrors); return \"editItem\"; &#125; // 更新 itemsService.updateItems(id, item); // 返回成功页面 // 重定向到商品查询 return \"forward:queryItems.action\"; &#125; controller方法参数中的@Validated(value = { ItemsValidationForEdit.class}) Items item, BindingResult bindingResult） 含义为： 对Items这个形参进行校验，选择他其中定义的ItemsValidationForEdit这个分组的校验规则。 注意：如果你需要进行校验，在方法参数中，需要在校验对象的前后加上@Validated和BindingResult bindingResult，他们是成对出现的。 顺便贴下hibernate-validator的校验注解 123456789101112131415161718192021Bean Validation 中内置的 constraint @Null 被注释的元素必须为 null @NotNull 被注释的元素必须不为 null @AssertTrue 被注释的元素必须为 true @AssertFalse 被注释的元素必须为 false @Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值 @DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值 @Size(max=, min=) 被注释的元素的大小必须在指定的范围内 @Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内 @Past 被注释的元素必须是一个过去的日期 @Future 被注释的元素必须是一个将来的日期 @Pattern(regex=,flag=) 被注释的元素必须符合指定的正则表达式 Hibernate Validator 附加的 constraint @NotBlank(message =) 验证字符串非null，且长度必须大于0 @Email 被注释的元素必须是电子邮箱地址 @Length(min=,max=) 被注释的字符串的大小必须在指定的范围内 @NotEmpty 被注释的字符串的必须非空 @Range(min=,max=,message=) 被注释的元素必须在合适的范围内","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"SpringMVC中post、get乱码解决","date":"2017-02-28T05:14:14.000Z","path":"2017/02/28/SpringMVC中post、get乱码解决/","text":"一 乱码原因由于中间件为Tomcat，用户请求和返回的响应都需要经过tomcat，tomcat默认编码为ISO-8859-1和我们程序的编码(一般为UTF-8)不同，导致post、get请求乱码。 二 解决方案 Post乱码解决方案：在web.xml中添加编码过滤器来解决，可以自己编写过滤器，最常用的方法是使用spring提供的编码过滤器：在Web.xml中增加如下配置（要注意的是它的位置一定要是第一个执行的过滤器） 12345678910111213&lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 该过滤器要做的其实就是强制为所有请求和响应设置编码格式：request.setCharacterEncoding(“utf-8”);response.setCharacterEncoding(“utf-8”); GET乱码解决方案 针对Get方式的乱码问题，由于参数是通过URL传递的，所以上面通过request设置的编码格式是不起作用的12345678910方法①修改tomcat目录 的conf/server.xml文件，添加URIEncoding=\"utf-8\"&lt;Connector URIEncoding=\"utf-8\" connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"/&gt;只需增加 URIEncoding=\"UTF-8\" 这一句，然后重启tomcat即可。方法②对参数进行重新编码：String userName = new String(request.getParamter(\"userName\").getBytes(\"ISO8859-1\"),\"utf-8\")ISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码 通过以上对POST和GET的处理，妈妈再也不用担心我们遇到乱码了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":"以mybatis为例浅聊SQL注入","date":"2017-02-28T05:03:08.000Z","path":"2017/02/28/以mybatis为例浅聊SQL注入/","text":"以用户登录为例，传统代码为一个form表单，输入username和password去数据库发送sql检索，用的是字符串拼接${}。 select * from t_user where password = '${password}'and username = '${username}' 如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 此时无论用户名为zhangsan的该用户密码为何值，均能查询出一条记录。 而用了预编译的#{}占位符后代码为 select * from t_user where password = #{password} and username = #{username} 即mybatis发送给数据库的sql为 select * from t_user where password = ? and username = ? 在数据库端便会对该sql进行编译，如果下次有该查询时，mabatis会发送 select * from t_user where password = #{password} and username = #{username} 作为“KEY”，页面传入的参数作为“VALUE”去数据库查询，预编译的方式使得发送至数据库的值为sql “KEY” 和 参数 “VALUE”，数据库根据KEY找到编译好的sql，将参数注入进行查询如果页面输入 zhangsan 1111&#39; or &#39;1 = 1 则sql语句为 select * from t_user where password = '1111' or '1 = 1'and username = 'zhangsan' 看到这也许会有疑问，这和传统的字符串拼接，得到的sql还是一样的啊？其实并不是，sql只是数据库端给我们看的一段字符串，真正的查询方式，传统字符串拼接查询，传入数据库的是一个参数，为在程序端拼接好的sql，直接去数据库执行。而预编译方式，传入数据库的是两个参数，一个是 select * from t_user where password = ? and username = ? 语句，一个是值。如果数据库里没该条SQL就会编译好缓存，如果缓存有的话，直接类似“函数接收参数”的方式去执行sql，那么，数据库里是不会有任何一条记录的密码为1111’ or ‘1 = 1，就不会返回记录。从某种意义上来说防止了SQL注入。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"MySQL和Oracle分页的区别","date":"2017-02-28T05:01:20.000Z","path":"2017/02/28/MySQL和Oracle分页的区别/","text":"MySQL和Oracle分页的区别 MySQL 分页 (利用LIMIT关键字） 计算参数为 开始序号(startNum)，要查的总条数 (totalNum) Oracle 分页 (利用自带的rownum) 计算参数为 开始序号(startNum) ， 结束序号 (endNum) Oracle分页利用其自带的rownum，但是rownum在表中不能使用&gt;号(比如select rownum,e.* from emp where rownum &gt; n,n为除了0以外的任何值,查出的都是空)，但是可以使用&lt;,为了避免，所以采用子查询将其rownum转换为子查询表中的一列数据列,而不是数据表自带的rownum属性使其可以使用 这种方式的好处在于，除了中间的业务查询，其余的都是固定的模版，我们只需要关心中间的业务查询即可。","tags":[{"name":"DB","slug":"DB","permalink":"http://yoursite.com/tags/DB/"}]},{"title":"OCUpload、pinyin4j、poi简单入门","date":"2017-02-28T04:50:16.000Z","path":"2017/02/28/OCUpload、pinyin4j、poi简单入门/","text":"通过几个小demo完成以上三项的简单入门，通过此篇博客，您可以对它们有初步的认识，编写日常简单的应用。具体深入可以查询相关api。 OCUpload OCUpload为JQuery的插件(One Click Upload)，意思为一键上传，封装了对于文件上传的一些方法，只需几行代码，文件上传优雅而简洁。 对于传统的文件上传，只是通过input标签，通过设置enctype为multipart/form-data，选中文件后还需点击按钮，提交表单，才能在后台进行相关字段解析，通过流来进行文件上传，上传成功后，页面多半要刷新，无法给用户良好的体验。 OCUpload实现了页面“不刷新”，选择文件后直接上传，不需要选中文件后再点击按钮上传表单。简单实现为： 在页面的head里引入JQuery的类库，由于这里使用了easyUI使按钮和提示相对美观些，所以也导入了easyUI的核心类库，当然别忘了导入我们的OCUpload的库，本篇博客使用的版本为jquery.ocupload-1.1.2.js.首先在body中使用一个元素来“占位子”，任何标签元素都可以，不过上传文件一般点击按钮，所以我们使用easyUI的linkbutton，给按钮设置id为import.123&lt;body&gt; &lt;a id=\"import\" class=\"easyui-linkbutton\" data-options=\"iconCls:'icon-redo'\"&gt;上传文档&lt;/a&gt;&lt;/body&gt; 在head中给id为import的按钮添加upload事件，这是OCUpload的上传方法，参数为json对象，由于是简单入门，在这里即使用三个主要的属性：action(处理上传文件的后台action路径)，name(给文件设置name，便于后台通过name获取)，onComplete(参数为function，执行上传完毕的回调函数)。12345678910111213141516&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#import\").upload(&#123; action:'$&#123;pageContext.request.contextPath&#125;/regionAction_importXls', name:'upload', onComplete: function (data, self, element) &#123; if(data=='1')&#123; $.messager.alert(\"提示信息\",\"数据导入成功!\",\"info\"); &#125;else&#123; $.messager.alert(\"提示信息\",\"数据导入失败!\",\"info\"); &#125; location.reload(); &#125; &#125;);&#125;);&lt;/script&gt; 到此便完成一键上传的前台代码，只需要后台对上传文件进行解析处理即可完成文件上传。 让我们来看看这些代码做了些什么。访问页面，打开F12调试。可以看到，OCUpload将我们的linkbutton底部添加了一个带有文件input的form和一个display:none 不可见的iframe。 选择文件后form中的input触发onChange事件，直接提交表单，实现了选择文件后直接上传 文件上传后，本来页面是要刷新的，但是OCUpload将target指向底部隐藏的iframe，使得隐藏的iframe刷新，从而达到我们的页面“不刷新”的效果 poixls文件解析 在后台使用poi对上传的xls文件进行解析，将文件中的一行(row)解析成javabean，通过hibernate存入数据库。 12345678910111213141516171819202122232425262728293031public class RegionAction extends BaseAction&lt;Region&gt; &#123; private File upload; public String importXls() throws FileNotFoundException, IOException &#123; HSSFWorkbook workbook = new HSSFWorkbook(new FileInputStream(upload));//此为poi的核心对象，通过构造方法中的InputStream生成HSSWorkbook对象。 HSSFSheet sheetAt = workbook.getSheetAt(0);//这里得到第一张表格(sheet) List&lt;Region&gt; regions = new ArrayList&lt;Region&gt;(); for (Row row : sheetAt) &#123; //通过遍历sheetAt获取每一行(row),再通过每一行获取每一个值 String value1 = row.getCell(0).getStringCellValue();//id String value2 = row.getCell(1).getStringCellValue();//province String value3 = row.getCell(2).getStringCellValue();//city String value4 = row.getCell(3).getStringCellValue();//district String value5 = row.getCell(4).getStringCellValue();//postcode Region region = new Region(value1, value2, value3, value4, value5); region.setShortcode(StringUtils.join(PinYin4jUtils.getHeadByString(value2+value3), \"\"));//此处利用PinYin4jUtils将表格中的字段转成拼音封装到javabean，暂且不提 region.setCitycode(PinYin4jUtils.hanziToPinyin(value3)); regions.add(region); &#125; String flag = \"1\"; try&#123; regionService.saveBatch(regions);//批处理保存到数据库中，如果抛异常返回标志字符串回前台，做出相应友好提示 &#125;catch(Exception e)&#123; flag = \"0\"; &#125; ServletActionContext.getResponse().setContentType(\"text/html;charset=UTF-8\"); ServletActionContext.getResponse().getWriter().print(flag); return NONE;//上传文件，不需要配视图 &#125; ｝ 那么在poi中，sheet、row、cell分别是什么呢？ sheet: xls中的工作表 row: xls中的行 cell: xls中的每一个数据 xls文件生成 在后台查询出数据list，封装进HSSFWorkbook对象生成xls文件,提供一个输出流，告知浏览器文件名和文件类型，在前台提供按钮或链接，指向此action，实现xls文件导出。 12345678910111213141516171819202122232425262728293031public String exportXls() throws IOException&#123; List&lt;Subarea&gt; list = subareaService.findAll(); HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(\"分区数据\"); HSSFRow headRow = sheet.createRow(0);//标题行 headRow.createCell(0).setCellValue(\"分区编号\"); headRow.createCell(1).setCellValue(\"省\"); headRow.createCell(2).setCellValue(\"市\"); headRow.createCell(3).setCellValue(\"区\"); headRow.createCell(4).setCellValue(\"信息\"); headRow.createCell(5).setCellValue(\"城市编码\"); if(list!=null &amp;&amp; list.size()&gt;0)&#123; for (Subarea subarea : list) &#123; HSSFRow dataRow = sheet.createRow(sheet.getLastRowNum()+ 1); dataRow.createCell(0).setCellValue(subarea.getId()); dataRow.createCell(1).setCellValue(subarea.getRegion().getProvince()); dataRow.createCell(2).setCellValue(subarea.getRegion().getCity()); dataRow.createCell(3).setCellValue(subarea.getRegion().getDistrict()); dataRow.createCell(4).setCellValue(subarea.getRegion().getInfo()); dataRow.createCell(5).setCellValue(subarea.getRegion().getCitycode()); &#125; &#125; String filename = URLEncoder.encode(\"分区数据.xls\", \"UTF-8\"); ServletActionContext.getResponse().setContentType(ServletActionContext.getServletContext().getMimeType(filename));//完成文件下载不要忘了\"一个流，两个头\" ServletActionContext.getResponse().setHeader(\"content-disposition\", \"attachment;filename=\"+filename);//完成文件下载不要忘了\"一个流，两个头\" ServletOutputStream out = ServletActionContext.getResponse().getOutputStream(); workbook.write(out);//通过HSSFWorkbook的write方法，关联一个输出流 return NONE; &#125; pinyin4j主要利用PinYin4jUtils的相关方法进行汉字转拼音。","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]},{"title":" EasyUI的datagrid组件实现分页","date":"2017-02-28T04:40:30.000Z","path":"2017/02/28/EasyUI的datagrid组件实现分页/","text":"本篇博客用于EasyUI的datagrid组件实现分页展示，后台为Struts2+Spring+Hibernate，利用DetachedCriteria对象进行简单的分页查询。 要点： datagrid组件的参数和响应格式 DetachedCriteria对象的条件查询 首先利用EasyUI渲染出datagrid数据表格 先在body中声明一个table 123&lt;div&gt; &lt;table id=\"grid\"&gt;&lt;/table&gt;&lt;/div&gt; 再去head中通过JQuery代码将table渲染为datagrid对象 123456789101112131415161718192021222324&lt;script type=\"text/javascript\"&gt; $(function()&#123; $('#grid').datagrid( &#123; border : false, rownumbers : true, pageList: [10,20,30],//选择一页显示多少数据 pagination : true,//在DataGrid控件底部显示分页工具栏。 columns :[ [ &#123; field : 'name',//简单的测试字段 title : '姓名', width : 120, align : 'center' &#125;, &#123; field : 'telephone', title : '手机号', width : 120, align : 'center' &#125; ] ], url :\"$&#123;pageContext.request.contextPath&#125;/staffAction_pageQuery\", //提交的url地址 idField : 'id' &#125;); &#125;);&lt;/script&gt; 此时你的页面应该是(因为没有在后台提供数据，所以现在页面为空表格) 接下来我们来看下这个datagrid组件发送了什么请求数据 打开浏览器的F12调试，我用的是火狐浏览器，不同的浏览器调试工具页面不同。找到网络栏，我们重新刷新下网页，可以看到 该条post请求是向后台获取数据 点开可以查看到他的请求参数为page、rows ###tips注意：在datagrid的请求参数中，page为当前页码，rows为所要展示的数据条数，而在datagrid的响应参数中，必须有total和rows，返回来的响应参数中，total为通过该条件查询到的总记录数，而这里的rows为所有的记录内容，为一个List集合。 有了请求参数，我们就可以去后台编写了。接下来为后台代码。 后台采用的是Struts2+Spring+Hibernate，我们利用struts2的驱动获取页面请求的page和rows参数。 在StaffAction中，我们提供了page、rows字段以及他们的get、set方法。为了方便起见，我们将分页有关的数据封装成一个名称为PageBean的Class对象。 PageBean StaffAction的pageQuery方法 StaffServiceImpl StaffDao 相关介绍在代码截图中有注释。最后，通过dao查询出来的数据，经过service传到action，在action中通过Jsonlib将数据转成json格式，返回前台。 接下来我们就可以在前台显示出数据库里的数据了！","tags":[{"name":"j2ee","slug":"j2ee","permalink":"http://yoursite.com/tags/j2ee/"}]}]